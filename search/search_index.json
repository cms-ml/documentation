{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":"<p>Welcome to the documentation hub for the CMS Machine Learning Group! The goal of this page is to provide CMS analyzers a centralized place to gather machine learning information relevant to their work. However, we are not seeking to rewrite external documentation. Whenever applicable, we will link to external documentation, such as the iML groups HEP Living Review or their ML Resources repository. What you will find here are pages covering:</p> <ul> <li>ML best practices</li> <li>How to optimize a NN</li> <li>Common pitfalls for CMS analyzers</li> <li>Direct and indirect inferencing using a variety of ML packages</li> <li>How to get a model integrated into CMSSW</li> </ul> <p>And much more!</p> <p>We recently launched v1 of the ML Knowledge Newsletter located here, and we're also looking for new writers and contributors. If you would like to be featured in this newsletter or would like to nominate someone to be featured, please let us know!</p> <p>If you think we are missing some important information, please contact the ML Knowledge Subgroup!</p>"},{"location":"general_advice/intro.html","title":"Introduction","text":"<p>In general, ML models don't really work out of the box. For example, most often it is not sufficient to simply instantiate the model class, call its <code>fit()</code> method followed by <code>predict()</code>, and then proceed straight to the inference step of the analysis.</p> <pre><code>from sklearn.datasets import make_circles\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.svm import SVC\n\nX, y = make_circles(noise=0.2, factor=0.5, random_state=1)\nX_train, X_test, y_train, y_test = \\\n        train_test_split(X, y, test_size=.4, random_state=42)\n\nclf = SVC(kernel=\"linear\", C=0.025)\nclf.fit(X_train, y_train)\nprint(f'Accuracy: {clf.score(X_test, y_test)}')\n# Accuracy: 0.4\n</code></pre> <p>Being an extremely simplified and naive example, one would be lucky to have the code above produce a valid and optimal model. This is because it explicitly doesn't check for those things which could've gone wrong and therefore is prone to producing undesirable results. Indeed, there are several pitfalls which one may encounter on the way towards implementation of ML into their analysis pipeline. These can be easily avoided by being aware of those and performing a few simple checks here and there.</p> <p>Therefore, this section is intended to review potential issues on the ML side and how they can be approached in order to train a robust and optimal model. The section is designed to be, to a large extent, analysis-agnostic. It will focus on common, generalized validation steps from ML perspective, without paying particular emphasis on the physical context. However, for illustrative purposes, it will be supplemented with some examples from HEP and additional links for further reading. As the last remark, in the following there will mostly an emphasis on the validation items specific to supervised learning. This includes classification and regression problems as being so far the most common use cases amongst HEP analysts.</p> <p>The General Advice chapter is divided into into 3 sections. Things become logically aligned if presented from the perspective of the training procedure (fitting/loss minimisation part). That is, the sections will group validation items as they need to be investigated:</p> <ul> <li>Before training</li> <li>During training</li> <li>After training</li> </ul> <p>Authors: Oleg Filatov</p>"},{"location":"general_advice/after/after.html","title":"After training","text":"<p>After the necessary steps to design the ML experiment has been made, the training has been performed and verified to be stable and consistent, there are still a few things to be checked to further solidify the confidence in the model performance.</p>"},{"location":"general_advice/after/after.html#final-evaluation","title":"Final evaluation","text":"<p>Before the training, initial data set is to be split into the train and test parts, where the former is used to train the model (possibly, with cross-validation), while the latter remains blinded. Once all the optimisations to the model architecture have been made and the model is \"frozen\", one proceeds to the evaluation of the metrics' values on the test set. This would be the very last check of the model for overfitting and in case there is none, one expects to see little or no difference comparing to the values on (cross)validation set used throughout the training. In turn, any discrepancies could point to possible overfitting happening in the training stage (or also possibly data leakage), which requires further investigation.</p> <p>The next step to check is the output score of the model (probability<sup>1</sup>) for each class. It can be done, for example, in the form of a TMVA-like overtraining check (see Figure 1) which also allows to spot overtraining:</p> Figure 1.  Comparison of model output for signal and background classes overlaid for train and test data sets. [source: root-forum.cern.ch] <p>In general, what is important to look at is that in the category for class C (defined as <code>argmax(score_i)</code>), the score for a class C peaks at values closer to 1. Whereas the other classes doesn't have such property with peaking on the left side of 1 and smoothly falling down to zero as the model score in the category approaches 1. Or, in other words, that the distributions of the model score for various classes are not overlapping and are as far apart as possible. This would be an indication that the model indeed distinguishes between the classes.</p> <p>Another thing to look at is the data/simulation agreement for class categories. Since it is the output of the model for each category which is used in further statistical inference step, it is important to verify that data/simulation agreement of input features is properly propagated through the model into categories' distribution. This can be achieved by producing the plot similar to the one shown on Figure 2: the stacked templates for backround processes are fitted and compared with the actual predictions for the data for the set of events classified to be in the given category (jet-fakes in the example). If the output data/simulation agreement is worse than the input one, it might point to an existing bias of the model in the way it treats data and simulation events.</p> Figure 2.  Postfit jet-fake NN score for the mutau channel. Note that the distribution for jet-fakes class is dominant in this category and also peaks at value 1 (mind the log scale), which is an indication of good identification of this background process by the model. Furthermore, ratio of data and MC templates is equal to 1 within uncertainties. [source: CMS-PAS-HIG-20-006]"},{"location":"general_advice/after/after.html#robustness","title":"Robustness","text":"<p>Once there is high confidence that the model isn't overtrained and no distortion in the input feature data/MC agreement is introduced, one can consider studying the robustness of the model to the parameter/input variations. Effectively, the model can be considered as a \"point estimate\", and any variations are helpful to understand the variance of the model outputs - hence, the model's robustness to changes.</p> <p>A simple example would be a hyperparameter optimisation, where various model parameters a varied to find the best one in terms of performance. Moreover, in HEP there is a helpful (for this particular case) notion of systematic uncertainties, which is a perfect tool to study model robustness to input data variations.</p> <p>Since in any case they need to be incorporated into the final statistical fit (to be performed on some interpretation of the model score), it implies that these uncertainties need to be \"propagated\" through the model. A sizeable fraction of those uncertainties are so-called \"up/down\" (or shape) variations, and therefore it is a good opportunity to study, how the model output responds to those up/down input feature changes. If there is a high sensitivity observed, one need to consider removing the most influencing feature from the training, or trying decorrelation techniques to decrease the impact of systematic-affected feature on the model output.</p>"},{"location":"general_advice/after/after.html#systematic-biases","title":"Systematic biases","text":"<p>Lastly, possible systematic biases arising the ML approach should be estimated. Being a broad and not fully formalised topic, a few examples will be given below to outline the possible sources of those.</p> <ul> <li>The first one could be a domain shift, that is the situation where the model is trained on one data domain, but is apllied to a different one (e.g. trained on simulated data, applied on real one). In order to account for that, corresponding scale factor corrections are traditionally derived, and those will come with some uncertainty as well.  </li> <li>Another example would be the case of undertraining. Consider the case of fitting a complex polynomial data with a simple linear function. In that case, the model has high bias (and low variance) which results in a systematic shift of its prediction to be taken into account.</li> <li>Care needs to be taken in cases where a cut is applied on the model output. Cuts might potentially introduce shifts and in case of the model score, which is a variable with a complex and non-linear relationship with input features, it might create undesirable biases. For example, in case of cutting on the output score and looking at the invariant mass distribution (e.g. of two jets), one can observe an effect which is known as mass sculpting (see Figure 3). In that case, the background distribution peaks at the mass of the signal resonance used as a signal in the classification task. After applying such cut, signal and background shapes overlap and become very similar, which dillutes the discrimination power between two hypotheses if invariant mass was to be used as the observable to be fitted.</li> </ul> Figure 3.  Left: Distributions of signal and background events without selection. Right: Background distributions at 50% signal efficiency (true positive rate) for different classifiers. The unconstrained classifier sculpts a peak at the W-boson mass, while other classifiers do not. [source: arXiv:2010.09745] <ol> <li> <p>Here it is assumed that it can be treated as probability to be assigned to a given class. This is mostly the case if there is a sigmoid/softmax used on the output layer of the neural network and the model is trained with a cross-entropy loss function.\u00a0\u21a9</p> </li> </ol>"},{"location":"general_advice/before/domains.html","title":"Domains","text":"<p>Data plays a crucial role in the process of training any ML model. It is something from which the model learns to solve a given task and therefore care needs to be taken with its handling. There are two main considerations when collecting and preparing data for an ML task:</p> <ol> <li>The data set should be relevant to the problem and should represent the underlying structure of the problem without containing potential biases and irrelevant deviations (e.g. MC simulation artefacts).</li> <li>A proper preprocessing of the data set should be performed so that the training step goes smoothly.</li> </ol> <p>In this section a general domain perspective on data will be covered. In the following sections a more granular look will be taken from the side of features and construction of inputs to the model.</p>"},{"location":"general_advice/before/domains.html#coverage","title":"Coverage","text":"<p>To begin with, one needs to bear in mind that training data should be as close as possible to data they expect to have in the context of analysis. Speaking in more formal terms,</p> <p>Domains of training (used to train the model) and inference (used to make final predictions) data sets should not sizeably diverge.</p> Examples <ul> <li>In most of the cases the model is usually trained on MC simulated data and later on applied to data to produce predictions which are then passed on to statistical inference step. MC simulation isn't perfect and therefore there are always differences between simulation and data domains. This can lead to the cases when model learns simulation artefacts which come e.g. from detector response mismodelling. Thus, its performance on data may be at least suboptimal and at most meaningless.</li> <li>Consider the model which is trained to predict the energy of a hadron given its energy deposits in the calorimeter (represented e.g. in the form of image or graph). Data consists of the showers initiated by a particle generated by a particle gun and having discrete values of energies (e.g. 1 GeV, 10 GeV, 20 GeV, etc.). However, in the real world settings, the model will be applied to showers produced by particles with underlying continuous energy spectrum. Although ML models are known for their capability to interpolate beyond their training domain, without apropriate tests model performance in the parts of the energy spectrum outside of its training domain is not a priori clear.  </li> </ul>"},{"location":"general_advice/before/domains.html#solution","title":"Solution","text":"<p>It is particularly not easy to build a model entirely robust to domain shift, so there is no general framework yet to approach and recover for discrepancies between training and inference domains altogether. However, there is research ongoing in this direction and several methods to recover for specific deviations have been already proposed.</p> <p>It is a widely known practice to introduce scale factor (SF) corrections to account for possible discrepancies between data and MC simulation. Effectively, that means that the model is probed on some part of the domain on which it wasn't trained on (data) and then corrected for any differences by using a meaningful set of observables to derive SFs. One particularly promising approaches to remedy for data/MC domain difference is to use adversarial approaches to fully leverage the multidimensionality of the problem, as described in a DeepSF note.</p> <p>Another solution would be to incorporate methods of domain adaptation into an ML pipeline, which essentially guide the model to be invariant and robust towards domain shift. Particularly in HEP, a Learning to Pivot with Adversarial Networks paper was one of the pioneers to investigate how a pile-up dependency can be mitigated, which can also be easily expanded to building a model robust to domain shift<sup>1</sup>.  </p> <p>Last but not the least, a usage of Bayesian neural networks has a great advantage of getting uncertainties estimate along with each prediction. If these uncertainties are significantly larger for some samples, this could indicate that they come from the domain beyond the training one (a so-called out-of-distribution samples). This post hoc analysis of prediction uncertainties, for example, can point to inconsistencies in or incompleteness of MC simulation/ data-driven methods of the background estimation.</p>"},{"location":"general_advice/before/domains.html#population","title":"Population","text":"<p>Furthermore, nowadays analyses are searching for very rare processes and therefore are interested in low-populated regions of the phase space. And even though the domain of interest may be covered in the training data set, it may also not be sufficiently covered in terms of the number of samples in the training data set, which populate those regions. That makes the model behaviour on an event which falls into those regions unpredictable - because it couldn't learn how to generalise in those areas due to a lack of data to learn from. Therefore,</p> <p>It is important to make sure that the phase space of interest is well-represented in the training data set.</p> Example <p>This is what is often called in HEP jargon \"little statistics in the tails\": meaning that too few events can be found in the tails of the corresponding distribution, e.g. in the high-pt region. This might be important because the topology of events changes when one enters high-pt areas of the phase space (aka boosted regime). This further means that the model should be able to capture this change in the event signature. However, it might fail to do so due to a little available data to learn from comparing to a low-pt region.   </p>"},{"location":"general_advice/before/domains.html#solution_1","title":"Solution","text":"<p>Clearly, a way out in that case would be to provide enough training data to cover those regions (also ensuring that the model has enough capacity to embrace diverse and complex topologies). </p> <p>Another solution would be to communicate to the model importance of specific topologies, which can be done for example by upweighting those events' contribution to the loss function. </p> <p>Lastly, it might be worth trying to train several models, each targeting its specific region, instead of a general-purpose one (e.g. low-pt &amp; boosted/merged topology tagger). Effectively, factorisation of various regions disentangle the problem of their separation for a single model and delegates it to an ensemble of dedicated models, each targeting its specific region.</p> <ol> <li> <p>From that paper on, the HEP community started to explore a similar topic of model decorrelation, i.e. how to build a model which would be invariant to a particular variable or property of data. For a more detailed overview please refer to Section 2 of this paper.\u00a0\u21a9</p> </li> </ol>"},{"location":"general_advice/before/features.html","title":"Features","text":"<p>In the previous section, the data was considered from a general \"domain\" perspective and in this section a more low level view will be outlined. In particular, an emphasis will be made on features (input variables) as they play a crucial role in the training of any ML model. Essentially being the handle on and the gateway into data for the model, they are expected to reflect the data from the perspective which is important to the problem at hand and therefore define the model performance on the task.</p> <p>The topic of feature engineering is very extensive and complex to be covered in this section, so the emphasis will be made primarily on the general aspects relevant to the HEP context. Broadly speaking, one should ask themselves the following questions during the data preparation:</p> <ul> <li>Are features understood?</li> <li>Are features correctly modelled?</li> <li>Are features appropriately processed?</li> </ul>"},{"location":"general_advice/before/features.html#understanding","title":"Understanding","text":"<p>Clearly one should motivate for themselves (and then possibly for analysis reviewers) why this exact set of features and not the other one has been selected<sup>1</sup>. Aside from physical understanding and intuition it would be good if a priori expert knowledge is supplemented by running further experiments.</p> <p>Here one can consider either studies done prior to the training or after it. As for the former, studying feature correlations (with the target variable as well) e.g. by computing Pearson and/or Spearman correlation coefficients and plotting several histogram/scatter plots could bring some helpful insights. As for the latter, exploring feature importances as the trained model deems it important can boost the understanding of both the data and the model altogether.</p>"},{"location":"general_advice/before/features.html#modelling","title":"Modelling","text":"<p>Although seemingly obvious, for the sake of completeness the point of achieving good data/MC agreement should be mentioned. It has always been a must to be checked in a cut-based approach and ML-based one is of no difference: the principle \"garbage in, garbage out\" still holds.</p> Example <p>For example, classical feed-forward neural network is just a continuous function mapping the input space to the output one, so any discrepancies in the input might propagate to the output. In case of boosted decision trees it is also applicable: any (domain) differences in the shape of input (training) distribution w.r.t. true \"data\" distribution might sizeably affect the construction of decision boundary in the feature space.  </p> Figure 1.  Control plot for a visible mass of tau lepton pair in emu final state. [source: CMS-TAU-18-001] <p>Since features are the handle on the data, checking for each input feature that the ratio of data to MC features' histograms is close to 1 within uncertainties (aka by eye) is one of the options. For a more formal approach, one can perform goodness of fit (GoF) tests in 1D and 2D, checking that as it was used for example in the analysis of Higgs boson decaying into tau leptons.</p> <p>If the modelling is shown to be insufficient, the corresponding feature should be either removed, or mismodelling needs to be investigated and resolved.</p>"},{"location":"general_advice/before/features.html#processing","title":"Processing","text":"<p>Feature preprocessing can also be understood from a broader perspective of data preprocessing, i.e. transformations which need to be performed with data prior to training a model. Another way to look at this is of a step where raw data is converted into prepared data. That makes it an important part of any ML pipeline since it ensures that a smooth convergence and stability of the training is reached.</p> Example <p>In fact, the training process might not even begin (presence of NaN values) or break in the middle (outlier causing the gradients to explode). Furthermore, data can be completely misunderstood by the model which can potentially caused undesirable interpretation and performance (treatment of categorical variables as numerical).</p> <p>Therefore, below there is a non-exhaustive list of the most common items to be addressed during the preprocessing step to ensure the good quality of training. For a more comprehensive overview and also code examples please refer to a detailed documentation of <code>sklearn</code> package and also on possible pitfalls which can arise at this point.</p> <ul> <li>Feature encoding</li> <li>NaN/inf/missing values<sup>2</sup></li> <li>Outliers &amp; noisy data</li> <li>Standartisation &amp; transformations</li> </ul> <p>Finally, these are the items which are worth considering in the preprocessing of data in general. However, one can also apply transformations at the level of batches as they are passed through the model. This will be briefly covered in the following section.</p> <ol> <li> <p>Here it is already assumed that a proper data representation has been chosen, i.e. the way to vectorize the data to form a particular structure (e.g. image -&gt; tensor, social network -&gt; graph, text -&gt; embeddings). Being on its own a whole big topic, it is left for a curious reader to dive into.\u00a0\u21a9</p> </li> <li> <p>Depending on the library and how particular model is implemented there, these values can be handled automatically under the hood.\u00a0\u21a9</p> </li> </ol>"},{"location":"general_advice/before/inputs.html","title":"Inputs","text":"<p>After data is preprocessed as a whole, there is a question of how this data should be supplied to the model. On its way there it potentially needs to undergo a few splits which will be described below. Plus, a few additional comments about training weights and motivation for their choice will be outlined.</p>"},{"location":"general_advice/before/inputs.html#data-split","title":"Data split","text":"<p>The first thing one should consider to do is to perform a split of the entire data set into train/validation(/test) data sets. This is an important one because it serves the purpose of diagnosis for overfitting. The topic will be covered in more details in the corresponding section and here a brief introduction will be given.</p> Figure 1.  Decision boundaries for underfitted, optimal and overfitted models. [source: ibm.com/cloud/learn/overfitting] <p>The trained model is called to be overfitted (or overtrained) when it fails to generalise to solve a given problem.</p> <p>One of examples would be that the model learns to predict exactly the training data and once given a new unseen data drawn from the same distribution it fails to predict the target corrrectly (right plot on Figure 1). Obviously, this is an undesirable behaviour since one wants their model to be \"universal\" and provide robust and correct decisions regardless of the data subset sampled from the same population.</p> <p>Hence the solution to check for ability to generalise and to spot overfitting: test a trained model on a separate data set, which is the same<sup>1</sup> as the training one. If the model performance gets significantly worse there, it is a sign that something went wrong and the model's predictive power isn't generalising to the same population.       </p> Figure 2.  Data split worflow before the training. Also cross-validation is shown as the technique to find optimal hyperparameters. [source: scikit-learn.org/stable/modules/cross_validation.html] <p>Clearly, the simplest way to find this data set is to put aside a part of the original one and leave it untouched until the final model is trained - this is what is called \"test\" data set in the first paragraph of this subsection. When the model has been finalised and optimised, this data set is \"unblinded\" and model performance on it is evaluated. Practically, this split can be easily performed with <code>train_test_split()</code> method of <code>sklearn</code> library.</p> But it might be not that simple <p>Indeed, there are few things to be aware of. Firstly, there is a question of how much data needs to be left for validation. Usually it is common to take the test fraction in the range [0.1, 0.4], however it is mostly up for analyzers to decide. The important trade-off which needs to be taken into account here is that between robustness of the test metric estimate (too small test data set - poorly estimated metric) and robustness of the trained model (too little training data - less performative model).</p> <p>Secondly, note that the split should be done in a way that each subset is as close as possible to the one which the model will face at the final inference stage. But since usually it isn't feasible to bridge the gap between domains, the split at least should be uniform between training/testing to be able to judge fairly the model performance.</p> <p>Lastly, in extreme case there might be no sufficient amount of data to perform the training, not even speaking of setting aside a part of it for validation. Here a way out would be to go for a few-shot learning, using cross-validation during the training, regularising the model to avoid overfitting or to try to find/generate more (possibly similar) data.</p> <p>Lastly, one can also considering to put aside yet another fraction of original data set, what was called \"validation\" data set. This can be used to monitor the model during the training and more details on that will follow in the overfitting section.</p>"},{"location":"general_advice/before/inputs.html#batches","title":"Batches","text":"<p>Usually it is the case the training/validation/testing data set can't entirely fit into the memory due to a large size. That is why it gets split into batches (chunks) of a given size which are then fed one by one into the model during the training/testing.</p> <p>While forming the batches it is important to keep in mind that batches should be sampled uniformly (i.e. from the same underlying PDF as of the original data set).</p> <p>That means that each batch is populated similarly to the others according to features which are important to the given task (e.g. particles' pt/eta, number of jets, etc.). This is needed to ensure that gradients computed for each batch aren't different from each other and therefore the gradient descent doesn't encounter any sizeable stochasticities during the optimisation step.<sup>2</sup></p> <p>Lastly, it was already mentioned that one should perform preprocessing of the data set prior to training. However, this step can be substituted and/or complemented with an addition of a layer into the architecture, which will essentially do a specified part of preprocessing on every batch as they go through the model. One of the most prominent examples could be an addition of batch/group normalization, coupled with weight standardization layers which turned out to sizeably boost the performance on the large variety of benchmarks.</p>"},{"location":"general_advice/before/inputs.html#training-weights","title":"Training weights","text":"<p>Next, one can zoom into the batch and consider the level of single entries there (e.g. events). This is where the training weights come into play. Since the value of a loss function for a given batch is represented as a sum over all the entries in the batch, this sum can be naturally turned into a weighted sum. For example, in case of a cross-entropy loss with <code>y_pred</code>, <code>y_true</code>, <code>w</code> being vectors of predicted labels, true labels and weights respectively:</p> <pre><code>def CrossEntropy(y_pred, y_true, w): # assuming y_true = {0, 1}\n    return -w*[y_true*log(y_pred) + (1-y_true)*log(1-y_pred)]\n</code></pre> <p>It is important to disentangle here two factors which define the weight to be applied on a per-event basis because of the different motivations behind them:</p> <ul> <li>accounting for imbalance in training data</li> <li>accounting for imbalance in nature</li> </ul>"},{"location":"general_advice/before/inputs.html#imbalance-in-training-data","title":"Imbalance in training data","text":"<p>The first point is related to the fact, that in case of classification we may have significantly more (<code>&gt;O(1)</code> times) training data for one class than for the other. Since the training data usually comes from MC simulation, that corresponds to the case when there is more events generated for one physical process than for another. Therefore, here we want to make sure that model is equally presented with instances of each class - this may have a significant impact on the model performance depending on the loss/metric choice.</p> Example <p>Consider the case when there is 1M events of <code>target = 0</code> and 100 events of <code>target = 1</code> in the training data set and a model is fitted by minimising cross-entropy to distinguish between those classes. In that case the resulted model can easily turn out to be a constant function predicting the majority <code>target = 0</code>, simply because this would be the optimal solution in terms of the loss function minimisation. If using accuracy as a metric for validation, this will result in a value close to 1 on the training data.</p> <p>To account for this type of imbalance, the following weight simply needs to be introduced according to the <code>target</code> label of an object: <pre><code>train_df['weight'] = 1\ntrain_df.loc[train_df.target == 0, 'weight'] /= np.sum(train_df.loc[train_df.target == 0, 'weight'])\ntrain_df.loc[train_df.target == 1, 'weight'] /= np.sum(train_df.loc[train_df.target == 1, 'weight'])\n</code></pre></p> <p>Alternatively, one can consider using other ways of balancing classes aside of those with training weights. For a more detailed description of them and also a general problem statement see <code>imbalanced-learn</code> documentation.</p>"},{"location":"general_advice/before/inputs.html#imbalance-in-nature","title":"Imbalance in nature","text":"<p>The second case corresponds to the fact that in experiment we expect some classes to be more represented than the others. For example, the signal process usually has way smaller cross-section than background ones and therefore we expect to have in the end fewer events of the signal class. So the motivation of using weights in that case would be to augment the optimisation problem with additional knowledge of expected contribution of physical processes.</p> <p>Practically, the notion of expected number of events is incorporated into the weights per physical process so that the following conditions hold<sup>3</sup>:</p> <p></p> <p>As a part of this reweighting, one would naturally need to perform the normalisation as of the previous point, however the difference between those two is something which is worth emphasising.</p> <ol> <li> <p>That is, sampled independently and identically (i.i.d) from the same distribution.\u00a0\u21a9</p> </li> <li> <p>Although this is a somewhat intuitive statement which may or may not be impactful for a given task and depends on the training procedure itself, it is advisable to keep this aspect in mind while preparing batches for training.\u00a0\u21a9</p> </li> <li> <p>See also Chapter 2 of the HiggsML overview document \u21a9</p> </li> </ol>"},{"location":"general_advice/before/metrics.html","title":"Metrics & Losses","text":""},{"location":"general_advice/before/metrics.html#metric","title":"Metric","text":"<p>Metric is a function which evaluates model's performance given true labels and model predictions for a particular data set. </p> <p>That makes it an important ingredient in the model training as being a measure of the model's quality. However, metrics as estimators can be sensitive to some effects (e.g. class imbalance) and provide biased or over/underoptimistic results. Additionally, they might not be relevant to a physical problem in mind and to the undestanding of what is a \"good\" model<sup>1</sup>. This in turn can result in suboptimally tuned hyperparameters or in general to suboptimally trained model.</p> <p>Therefore, it is important to choose metrics wisely, so that they reflect the physical problem to be solved and additionaly don't introduce any biases in the performance estimate. The whole topic of metrics would be too broad to get covered in this section, so please refer to a corresponding documentation of <code>sklearn</code> as it provides an exhaustive list of available metrics with additional materials and can be used as a good starting point.  </p> Examples of HEP-specific metrics <p>Speaking of those metrics which were developed in the HEP field, the most prominent one is approximate median significance (AMS), firstly introduced in Asymptotic formulae for likelihood-based tests of new physics and then adopted in the HiggsML challenge on Kaggle.</p> <p>Essentially being an estimate of the expected signal sensitivity and hence being closely related to the final result of analysis, it can also be used not only as a metric but also as a loss function to be directly optimised in the training.</p>"},{"location":"general_advice/before/metrics.html#loss-function","title":"Loss function","text":"<p>In fact, metrics and loss functions are very similar to each other: they both give an estimate of how well (or bad) model performs and both used to monitor the quality of the model. So the same comments as in the metrics section apply to loss functions too. However, loss function plays a crucial role because it is additionally used in the training as a functional to be optimised. That makes its choice a handle to explicitly steer the training process towards a more optimal and relevant solution.</p> Example of things going wrong <p>It is known that L2 loss (MSE) is sensitive to outliers in data and L1 loss (MAE) on the other hand is robust to them. Therefore, if outliers were overlooked in the training data set and the model was fitted, it may result in significant bias in its predictions. As an illustration, this toy example compares Huber vs Ridge regressors, where the latter shows a more robust behaviour.</p> <p>A simple example of that was already mentioned in domains section - namely, one can emphasise specific regions in the phase space by attributing events there a larger weight in the loss function. Intuitively, for the same fraction of mispredicted events in the training data set, the class with a larger attributed weight should bring more penalty to the loss function. This way model should be able to learn to pay more attention to those \"upweighted\" events<sup>2</sup>.</p> Examples in HEP beyond classical MSE/MAE/cross entropy <ul> <li>b-jet energy regression, being a part of nonresonant HH to bb gamma gamma analysis, uses Huber and two quantile loss terms for simultaneous prediction of point and dispersion estimators of the target disstribution.  </li> <li>DeepTau, a CMS deployed model for tau identification, uses several focal loss terms to give higher weight to more misclassified cases</li> </ul> <p>However, one can go further than that and consider the training procedure from a larger, statistical inference perspective. From there, one can try to construct a loss function which would directly optimise the end goal of the analysis. INFERNO is an example of such an approach, with a loss function being an expected uncertainty on the parameter of interest. Moreover, one can try also to make the model aware of nuisance parameters which affect the analysis by incorporating those into the training procedure, please see this review for a comprehensive overview of the corresponding methods.    </p> <ol> <li> <p>For example, that corresponds to asking oneself a question: \"what is more suitable for the purpose of the analysis: F1-score, accuracy, recall or ROC AUC?\"\u00a0\u21a9</p> </li> <li> <p>However, these are expectations one may have in theory. In practise, optimisation procedure depends on many variables and can go in different ways. Therefore, the weighting scheme should be studied by running experiments on the case-by-case basis.\u00a0\u21a9</p> </li> </ol>"},{"location":"general_advice/before/model.html","title":"Model","text":"<p>There is definitely an enormous variety of ML models available on the market, which makes the choice of a suitable one for a given problem at hand not entirely straightforward. So far being to a large extent an experimental field, the general advice here would be to try various and pick the one giving the best physical result.</p> <p>However, there are in any case several common remarks to be pointed out, all glued together with a simple underlying idea:</p> <p>Start off from a simple baseline, then gradually increase the complexity to improve upon it.</p> <ol> <li> <p>In the first place, one need to carefully consider whether there is a need for training an ML model at all. There might be problems where this approach would be a (time-consuming) overkill and a simple conventional statistical methods would deliver results faster and even better.</p> </li> <li> <p>If ML methods are expected to bring improvement, then it makes sense to try out simple models first. Assuming a proper set of high-level features has been selected, ensemble of trees (random forest/boosted decision tree) or simple feedforward neural networks might be a good choice here. If time and resources permit, it might be beneficial to compare the results of these trainings to a no-ML approach (e.g. cut-based) to get the feeling of how much the gain in performance is. In most of the use cases, those models will be already sufficient to solve a given classification/regression problem in case of dealing with high-level variables.</p> </li> <li> <p>If it feels like there is still room for improvement, try hyperparameter tuning first to see if it is possible to squeeze more performance out of the current model and data. It can easily be that the model is sensitive to a hyperparameter choice and a have a sizeable variance in performance across hyperparameter space.</p> </li> <li> <p>If the hyperparameter space has been thoroughly explored and optimal point has been found, one can additionally try to play around with the data, for example, by augmenting the current data set with more samples. Since in general the model performance profits from having more training data, augmentation might also boost the overall performance.  </p> </li> <li> <p>Lastly, more advanced architectures can be probed. At this point the choice of data representation plays a crucial role since more complex architectures are designed to adopt more sophisticated patterns in data. While in ML research is still ongoing to unify together all the complexity of such models (and promisingly, also using effective field theory approach), in HEP there's an ongoing process of probing various architectures to see which type fits the most in HEP field.</p> </li> </ol> Models in HEP <p>One of the most prominent benchmarks so far is the one done by G. Kasieczka et. al on the top tagging data set, where in particular ParticleNet turned out to be a state of the art. This had been a yet another solid argument in favour of using graph neural networks in HEP due to its natural suitability in terms of data representation.</p> <p> Illustration from G. Kasieczka et. al showing ROC curves for all evaluated algorithms. </p>"},{"location":"general_advice/during/opt.html","title":"Optimisation problems","text":"Figure 1.  The loss surfaces of ResNet-56 with/without skip connections. [source: \"Visualizing the Loss Landscape of Neural Nets\" paper] <p>However, it might be that for a given task overfitting is of no concern, but there are still instabilities in loss function convergence happening during the training<sup>1</sup>. The loss landscape is a complex object having multiple local minima and which is moreover not at all understood due to the high dimensionality of the problem. That makes the gradient descent procedure of finding a minimum not that simple. However, if instabilities are observed, there are a few common things which could explain that:</p> <ul> <li> <p>The main candidate for a problem might be the learning rate (LR). Being an important hyperparameter which steers the optimisation, setting it too high make cause extremily stochastic behaviour which will likely cause the optimisation to get stuck in some random minimum being way far from optimum. Oppositely, setting it too low may cause the convergence to take very long time. The optimal value in between those extremes can still be problematic due to a chance of getting stuck in a local minimum on the way towards a better one. That is why several approaches on LR schedulers (e.g. cosine annealing) and also adaptive LR (e.g. Adam being the most prominent one) have been developed to have more flexibility during the training, as opposed to setting LR fixed from the very beginning of the training until its end.</p> </li> <li> <p>Another possibility is that there are NaN/inf values or uniformities/outliers appearing in the input batches. It can cause the gradient updates to go beyond the normal scale and therefore dramatically affect the stability of the loss optimisation. This can be avoided by careful data preprocessing and batch formation.  </p> </li> <li> <p>Last but not the least, there is a chance that gradients will explode or vanish during the training, which will reveal itself as a rapid increase/stagnation in the loss function values. This is largely the feature of deep architectures, where during the backpropagation gradients are accumulated from one layer to another, and therefore any minor deviations in scale can exponentially amplify/diminish as they get multiplied. Since it is the scale of the trainable weights themselves which defines the weight gradients, a proper weight initialisation can foster smooth and consistent gradient updates. Also, batch normalisation together with weight standartization showed to be a powerful technique to consistently improve performance across various domains. Finally, a choice of activation function is particularly important since it directly contributes to a gradient computation. For example, a sigmoid function is known to cause gradients to vanish due to its gradient being 0 at large input values. Therefore, it is often suggested to stick to classical ReLU or try other alternatives to see if it brings improvement in performance.</p> </li> </ul> <ol> <li> <p>Sometimes particularly peculiar.\u00a0\u21a9</p> </li> </ol>"},{"location":"general_advice/during/overfitting.html","title":"Overfitting","text":"<p>Given that the training experiment has been set up correctly (with some of the most common problems described in before training section), actually few things can go wrong during the training process itself. Broadly speaking, they fall into two categories: overfitting related and optimisation problem related. Both of them can be easily spotted by closely monitoring the training procedure, as will be described in the following.</p>"},{"location":"general_advice/during/overfitting.html#overfitting","title":"Overfitting","text":"<p>The concept of overfitting (also called overtraining) was previously introduced in inputs section and here we will elaborate a bit more on that. In its essence, overfitting as the situation where the model fails to generalise to a given problem can have several underlying explanations:</p> <p>The first one would be the case where the model complexity is way too large for a problem and a data set being considered.</p> Example <p>A simple example would be fitting of some linearly distributed data with a polynomial function of a large degree. Or in general, when the number of trainable parameters is significantly larger when the size of the training data set.</p> <p>This can be solved prior to training by applying regularisation to the model, which in it essence means constraining its capacity to learn the data representation. This is somewhat related also to the concept of Ockham's razor: namely that the less complex an ML model, the more likely that a good empirical result is not just due to the peculiarities of the data sample. As of the practical side of regularisation, please have a look at this webpage for a detailed overview and implementation examples.</p> <p>Furthermore, a recipe for training neural networks by A. Karpathy is a highly-recommended guideline not only on regularisation, but on training ML models in general.</p> <p>The second case is a more general idea that any reasonable model at some point starts to overfit.</p> Example <p>Here one can look at overfitting as the point where the model considers noise to be of the same relevance and start to \"focus\" on it way too much. Since data almost always contains noise, this makes it in principle highly probable to reach overfitting at some point.   </p> <p>Both of the cases outlined above can be spotted simply by tracking the evolution of loss/metrics on the validation data set . Which means that additionally to the train/test split done prior to training (as described in inputs section), one need to set aside also some fraction of the training data to perform validation throughout the training. By plotting the values of loss function/metric both on train and validation sets as the training proceeds, overfitting manifests itself as the increase in the value of the metric on the validation set while it is still continues to decrease on the training set:</p> Figure 1.  Error metric as a function of number of iterations for train and validation sets. Vertical dashed line represents the separation between the region of underfitting (model hasn't captured well the data complexity to solve the problem) and overfitting (model does not longer generalise to unseen data). The point between these two regions is the optimal moment when the training should stop. [source: ibm.com/cloud/learn/overfitting] <p>Essentially, it means that from that turning point onwards the model is trying to learn better and better the noise in training data at the expense of generalisation power. Therefore, it doesn't make sense to train the model from that point on and the training should be stopped.</p> <p>To automate the process of finding this \"sweat spot\", many ML libraries include early stopping as one of its parameters in the <code>fit()</code> function. If early stopping is set to, for example, 10 iterations, the training will automatically stop once the validation metric is no longer improving for the last 10 iterations.  </p>"},{"location":"general_advice/during/xvalidation.html","title":"Cross-validation","text":"<p>However, in practice what one often deals with is a hyperparameter optimisation - running of several trainings to find the optimal hyperparameter for a given family of models (e.g. BDT or feed-forward NN).</p> <p>The number of trials in the hyperparameter space can easily reach hundreds or thousands, and in that case naive approach of training the model for each hyperparameters' set on the same train data set and evaluating its performance on the same test data set is very likely prone to overfitting. In that case, an experimentalist overfits to the test data set by choosing the best value of the metric and effectively adapting the model to suit the test data set best, therefore loosing the model's ability to generalise.</p> <p>In order to prevent that, a cross-validation (CV) technique is often used:</p> Figure 1.  Illustration of the data set split for cross-validation. [source: scikit-learn.org/stable/modules/cross_validation.html] <p>The idea behind it is that instead of a single split of the data into train/validation sets, the training data set is split into N folds. Then, the model with the same fixed hyperparameter set is trained N times in a way that at the i-th iteration the i-th fold is left out of the training and used only for validation, while the other N-1 folds are used for the training. </p> <p>In this fashion, after the training of N models in the end there is N values of a metric computed on each fold. The values now can be averaged to give a more robust estimate of model performance for a given hyperparameter set. Also a variance can be computed to estimate the range of metric values. After having completed the N-fold CV training, the same approach is to be repeated for other hyperparameter values and the best set of those is picked based on the best fold-averaged metric value.</p> Further insights <p>Effectively, with CV approach the whole training data set plays the role of a validation one, which makes the overfitting to a single chunk of it (as in naive train/val split) less likely to happen. Complementary to that, more training data is used to train a single model oppositely to a single and fixed train/val split, moreover making the model less dependant on the choice of the split.</p> <p>Alternatively, one can think of this procedure is of building a model ensemble which is inherently an approach more robust to overfitting and in general performing better than a single model.</p>"},{"location":"inference/checklist.html","title":"Integration checklist","text":"<p>Todo.</p>"},{"location":"inference/conifer.html","title":"Direct inference with conifer","text":""},{"location":"inference/conifer.html#introduction","title":"Introduction","text":"<p>conifer is a Python package developed by the Fast Machine Learning Lab for the deployment of Boosted Decision Trees in FPGAs for Level 1 Trigger applications. Documentation, examples, and tutorials are available from the conifer website, GitHub, and the hls4ml tutorial respectively. conifer is on the Python Package Index and can be installed like <code>pip install conifer</code>. Targeting FPGAs requires Xilinx's Vivado/Vitis suite of software. Here's a brief summary of features:</p> <ul> <li>conversion from common BDT training frameworks: scikit-learn, XGBoost, Tensorflow Decision Forests (TF DF), TMVA, and ONNX</li> <li>conversion to FPGA firmware with backends: HLS (C++ for FPGA), VHDL, C++ (for CPU)</li> <li>utilities for bit- and cycle-accurate firmware simulation, and interface to FPGA synthesis tools for evaluation and deployment from Python</li> </ul>"},{"location":"inference/conifer.html#emulation-in-cmssw","title":"Emulation in CMSSW","text":"<p>All L1T algorithms require bit-exact emulation for performance studies and validation of the hardware system. For conifer this is provided with a single header file at <code>L1Trigger/Phase2L1ParticleFlow/interface/conifer.h</code>. The user must also provide the BDT JSON file exported from the conifer Python tool for their model. JSON loading in CMSSW uses the <code>nlohmann/json</code> external.</p> <p>Both the conifer FPGA firmware and C++ emulation use Xilinx's arbitrary precision types for fixed-point arithmetic (<code>hls</code> external of CMSSW). This is cheaper and faster in the FPGA fabric than floating-point types. An important part of the model preparation process is choosing the proper fixed-point data types to avoid loss of performance compared to the trained model. Input preprocessing, in particular scaling, can help constrain the input variables to a smaller numerical range, but may also have a hardware cost to implement. In C++ the arbitrary precision types are specified like: <code>ap_fixed&lt;width, integer, rounding mode, saturation mode&gt;</code>. </p> <p>Minimal preparation from Python: <pre><code>import conifer\nmodel = conifer. ... # convert or load a conifer model\n# e.g. model = conifer.converters.convert_from_xgboost(xgboost_model)\nmodel.save('my_bdt.json')\n</code></pre></p> <p>CMSSW C++ user code: <pre><code>// include the conifer emulation header file\n#include \"L1Trigger/Phase2L1ParticleFlow/interface/conifer.h\"\n\n... model setup\n// define the input/threshold and score types\n// important: this needs to match the firmware settings for bit-exactness!\n// note: can use native types like float/double for development/debugging\ntypedef ap_fixed&lt;18,8&gt; input_t;\ntypedef ap_fixed&lt;12,3,AP_RND_CONV,AP_SAT&gt; score_t;\n\n// create a conifer BDT instance\n// 'true' to use balanced add-tree score aggregation (needed for bit-exactness)\nbdt = conifer::BDT&lt;input_t, score_t, true&gt;(\"my_bdt.json\");\n\n... inference\n// prepare the inputs, vector length same as model n_features\nstd::vector&lt;input_t&gt; inputs = ... \n// run inference, scores vector length same as model n_classes (or 1 for binary classification/regression)\nstd::vector&lt;score_t&gt; scores = bdt.decision_function(inputs);\n</code></pre></p> <p>conifer does not compute class probabilities from the raw predictions for the avoidance of extra resource and latency cost in the L1T deployment. Cuts or working points should therefore be applied on the raw predictions.</p>"},{"location":"inference/hls4ml.html","title":"Direct inference with hls4ml","text":"<p>hls4ml is a Python package developed by the Fast Machine Learning Lab. It's primary purpose is to create firmware implementations of machine learning (ML) models to be run on FPGAs. The package interfaces with a high-level synthesis (HLS) backend (i.e. Xilinx Vivado HLS) to transpile the ML model into hardware description language (HDL). The primary hls4ml documentation, including API reference pages, is located here.</p> <p> </p> <p>The main hls4ml tutorial code is kept on GitHub. Users are welcome to walk through the notebooks at their own pace. There is also a set of slides linked to the README.</p> <p>That said, there have been several cases where the hls4ml developers have given live demonstrations and tutorials. Below is a non-exhaustive list of tutorials given in the last few years (newest on top).</p> Workshop/Conference Date Links 23<sup>rd</sup> Virtual IEEE Real Time Conference August 03, 2022 Indico 2022 CMS ML Town Hall July 22, 2022 Contribution Link a3d3 hls4ml @ Snowmass CSS 2022: Tutorial July 21, 2022 Slides, Recording, JupyterHub Fast Machine Learning for Science Workshop December 3, 2020 Indico, Slides, GitHub, Interactive Notebooks hls4ml @ UZH ML Workshop November 17, 2020 Indico, Slides ICCAD 2020 November 5, 2020 https://events-siteplex.confcats.io/iccad2022/wp-content/uploads/sites/72/2021/12/2020_ICCAD_ConferenceProgram.pdf, GitHub 4<sup>th</sup> IML Workshop October 19, 2020 Indico, Slides, Instructions, Notebooks, Recording 22<sup>nd</sup> Virtual IEEE Real Time Conference October 15, 2020 Indico, Slides, Notebooks 30<sup>th</sup> International Conference on Field-Programmable Logic and Applications September 4, 2020 Program hls4ml tutorial @ CERN June 3, 2020 Indico, Slides, Notebooks Fast Machine Learning September 12, 2019 Indico 1<sup>st</sup> Real Time Analysis Workshop, Universit\u00e9 Paris-Saclay July 16, 2019 Indico, Slides, Autoencoder Tutorial"},{"location":"inference/onnx.html","title":"Direct inference with ONNX Runtime","text":"<p>ONNX is an open format built to represent machine learning models. It is designed to improve interoperability across a variety of frameworks and platforms in the AI tools community\u2014most deep learning frameworks (e.g. XGBoost, TensorFlow, PyTorch which are frequently used in CMS) support converting their model into the ONNX format or loading a model from an ONNX format.</p> The figure showing the ONNX interoperability. (Source from website.) <p>ONNX Runtime is a tool aiming for the acceleration of machine learning inferencing across a variety of deployment platforms. It allows to \"run any ONNX model using a single set of inference APIs that provide access to the best hardware acceleration available\". It includes \"built-in optimization features that trim and consolidate nodes without impacting model accuracy.\"</p> <p>The CMSSW interface to ONNX Runtime is avaiable since CMSSW_11_1_X (cmssw#28112, cmsdist#5020). Its functionality is improved in CMSSW_11_2_X. The final implementation is also backported to CMSSW_10_6_X to facilitate Run 2 UL data reprocessing. The inference of a number of deep learning tagger models (e.g. DeepJet, DeepTauID, ParticleNet, DeepDoubleX, etc.) has been made with ONNX Runtime in the routine of UL processing and has gained substantial speedup.</p> <p>On this page, we will use a simple example to show how to use ONNX Runtime for deep learning model inference in the CMSSW framework, both in C++ (e.g. to process the MiniAOD file) and in Python (e.g. using NanoAOD-tools to process the NanoAODs). This may help readers who will deploy an ONNX model into their analyses or in the CMSSW framework.</p>"},{"location":"inference/onnx.html#software-setup","title":"Software Setup","text":"<p>We use CMSSW_11_2_5_patch2 to show the simple example for ONNX Runtime inference. The example can also work under the new 12 releases (note that inference with C++ can also run on CMSSW_10_6_X)</p> <pre><code>export SCRAM_ARCH=\"slc7_amd64_gcc900\"\nexport CMSSW_VERSION=\"CMSSW_11_2_5_patch2\"\n\nsource /cvmfs/cms.cern.ch/cmsset_default.sh\n\ncmsrel \"$CMSSW_VERSION\"\ncd \"$CMSSW_VERSION/src\"\n\ncmsenv\nscram b\n</code></pre>"},{"location":"inference/onnx.html#converting-model-to-onnx","title":"Converting model to ONNX","text":"<p>The model deployed into CMSSW or our analysis needs to be converted to ONNX from the original framework format where it is trained. Please see here for a nice deck of tutorials on converting models from different mainstream frameworks into ONNX.</p> <p>Here we take PyTorch as an example. A PyTorch model can be converted by <code>torch.onnx.export(...)</code>. As a simple illustration, we convert a randomly initialized feed-forward network implemented in PyTorch, with 10 input nodes and 2 output nodes, and two hidden layers with 64 nodes each. The conversion code is presented below. The output model <code>model.onnx</code> will be deployed under the CMSSW framework in our following tutorial.</p> Click to expand <pre><code>import torch\nimport torch.nn as nn\ntorch.manual_seed(42)\n\nclass SimpleMLP(nn.Module):\n\n    def __init__(self, **kwargs):\n        super(SimpleMLP, self).__init__(**kwargs)\n        self.mlp = nn.Sequential(\n            nn.Linear(10, 64), nn.BatchNorm1d(64), nn.ReLU(), \n            nn.Linear(64, 64), nn.BatchNorm1d(64), nn.ReLU(), \n            nn.Linear(64, 2), nn.ReLU(), \n            )\n    def forward(self, x):\n        # input x: (batch_size, feature_dim=10)\n        x = self.mlp(x)\n        return torch.softmax(x, dim=1)\n\nmodel = SimpleMLP()\n\n# create dummy input for the model\ndummy_input = torch.ones(1, 10, requires_grad=True) # batch size = 1\n\n# export model to ONNX\ntorch.onnx.export(model, dummy_input, \"model.onnx\", verbose=True, input_names=['my_input'], output_names=['my_output'])\n</code></pre>"},{"location":"inference/onnx.html#inference-in-cmssw-c","title":"Inference in CMSSW (C++)","text":"<p>We will introduce how to write a module to run inference on the ONNX model under the CMSSW framework. CMSSW is known for its multi-threaded ability. In a threaded framework, multiple threads are served for processing events in the event loop. The logic is straightforward: a new event is assigned to idled threads following the first-come-first-serve princlple.</p> <p>In most cases, each thread is able to process events individually as the majority of event processing workflow can be accomplished only by seeing the information of that event. Thus, the <code>stream</code> modules (<code>stream</code> <code>EDAnalyzer</code> and <code>stream</code> <code>EDFilter</code>) are used frequently as each thread holds an individual copy of the module instance\u2014they do not need to communicate with each other. It is however also possible to share a global cache object between all threads in case sharing information across threads is necessary. In all, such CMSSW EDAnalyzer modules are declared by <code>class MyPlugin : public edm::stream::EDAnalyzer&lt;edm::GlobalCache&lt;CacheData&gt;&gt;</code> (similar for <code>EDFilter</code>). Details can be found in documentation on the C++ interface of <code>stream</code> modules.</p> <p>Let's then think about what would happen when interfacing CMSSW with ONNX for model inference. When ONNX Runtime accepts a model, it converts the model into an in-memory representation, and performance a variety of optimizations depending on the operators in the model. The procedure is done when an ONNX Runtime <code>Session</code> is created with an inputting model. The economic method will then be to hold only one <code>Session</code> for all threads\u2014this may save memory to a large extent, as the model has only one copy in memory. Upon request from multiple threads to do inference with their input data, the <code>Session</code> accepts those requests and serializes them, then produces the output data. ONNX Runtime has by design accepted that multithread threads invoke the <code>Run()</code> method on the same inference <code>Session</code> object. Therefore, what has left us to do is to</p> <ol> <li>create a <code>Session</code> as a global object in our CMSSW module and share it among all threads;</li> <li>in each thread, we process the input data and then call the <code>Run()</code> method from that global <code>Session</code>.</li> </ol> <p>That's the main logic for implementing ONNX inference in CMSSW. For details of high-level designs of ONNX Runtime, please see documentation here.</p> <p>With this concept, let's build the module.</p>"},{"location":"inference/onnx.html#1-includes","title":"1. includes","text":"<pre><code>#include \"FWCore/Framework/interface/stream/EDAnalyzer.h\"\n#include \"PhysicsTools/ONNXRuntime/interface/ONNXRuntime.h\"\n// further framework includes\n...\n</code></pre> <p>We include <code>stream/EDAnalyzer.h</code> to build the <code>stream</code> CMSSW module.</p>"},{"location":"inference/onnx.html#2-global-cache-object","title":"2. Global cache object","text":"<p>In CMSSW there exists a class <code>ONNXRuntime</code> which can be used directly as the global cache object. Upon initialization from a given model, it holds the ONNX Runtime <code>Session</code> object and provides the handle to invoke the <code>Run()</code> for model inference.</p> <p>We put the <code>ONNXRuntime</code> class in the <code>edm::GlobalCache</code> template argument:</p> <pre><code>class MyPlugin : public edm::stream::EDAnalyzer&lt;edm::GlobalCache&lt;ONNXRuntime&gt;&gt; {\n  ...\n};\n</code></pre>"},{"location":"inference/onnx.html#3-initiate-objects","title":"3. Initiate objects","text":"<p>In the <code>stream</code> <code>EDAnlyzer</code> module, it provides a hook <code>initializeGlobalCache()</code> to initiate the global object. We simply do</p> <pre><code>std::unique_ptr&lt;ONNXRuntime&gt; MyPlugin::initializeGlobalCache(const edm::ParameterSet &amp;iConfig) {\n  return std::make_unique&lt;ONNXRuntime&gt;(iConfig.getParameter&lt;edm::FileInPath&gt;(\"model_path\").fullPath());\n}\n</code></pre> <p>to initiate the <code>ONNXRuntime</code> object upon a given model path.</p>"},{"location":"inference/onnx.html#4-inference","title":"4. Inference","text":"<p>We know the event processing step is implemented in the <code>void EDAnalyzer::analyze</code> method. When an event is assigned to a valid thread, the content will be processed in that thread. This can go in parallel with other threads processing other events.</p> <p>We need to first construct the input data dedicated to the event. Here we create a dummy input: a sequence of consecutive integers of length 10. The input is set by replacing the values of our pre-booked vector, <code>data_</code>. This member variable has <code>vector&lt;vector&lt;float&gt;&gt;</code> format and is initialised as <code>{ {0, 0, ..., 0} }</code> (contains only one element, which is a vector of 10 zeros). In processing of each event, the input <code>data_</code> is modified:</p> <pre><code>std::vector&lt;float&gt; &amp;group_data = data_[0];\nfor (size_t i = 0; i &lt; 10; i++){\n  group_data[i] = float(iEvent.id().event() % 100 + i);\n}\n</code></pre> <p>Then, we send <code>data_</code> to the inference engine and get the model output:</p> <pre><code>std::vector&lt;float&gt; outputs = globalCache()-&gt;run(input_names_, data_, input_shapes_)[0];\n</code></pre> <p>We clarify a few details here.</p> <p>First, we use <code>globalCache()</code> which is a class method in our <code>stream</code> CMSSW module to access the global object shared across all threads. In our case it is the <code>ONNXRuntime</code> instance.</p> <p>The <code>run()</code> method is a wrapper to call <code>Run()</code> on the ONNX <code>Session</code>. Definations on the method arguments are (code from link): <pre><code>// Run inference and get outputs\n// input_names: list of the names of the input nodes.\n// input_values: list of input arrays for each input node. The order of `input_values` must match `input_names`.\n// input_shapes: list of `int64_t` arrays specifying the shape of each input node. Can leave empty if the model does not have dynamic axes.\n// output_names: names of the output nodes to get outputs from. Empty list means all output nodes.\n// batch_size: number of samples in the batch. Each array in `input_values` must have a shape layout of (batch_size, ...).\n// Returns: a std::vector&lt;std::vector&lt;float&gt;&gt;, with the order matched to `output_names`.\n// When `output_names` is empty, will return all outputs ordered as in `getOutputNames()`.\nFloatArrays run(const std::vector&lt;std::string&gt;&amp; input_names,\n                FloatArrays&amp; input_values,\n                const std::vector&lt;std::vector&lt;int64_t&gt;&gt;&amp; input_shapes = {},\n                const std::vector&lt;std::string&gt;&amp; output_names = {},\n                int64_t batch_size = 1) const;\n</code></pre> where we have <pre><code>typedef std::vector&lt;std::vector&lt;float&gt;&gt; FloatArrays;\n</code></pre></p> <p>In our case, <code>input_names</code> is set to <code>{\"my_input\"}</code> which corresponds to the names upon model creation. <code>input_values</code> is a length-1 vector, and <code>input_values[0]</code> is a vector of float of length 10, which are inputs to the 10 nodes. <code>input_shapes</code> can be set empty here and will be necessary for advanced usage, when our input has dynamic lengths (e.g., in boosed jet tagging, we use different numbers of particle-flow candidates and secondary vertices as input).</p> <p>For the usual model design, we have only one vector of output. In such a case, the output is simply a length-1 vector, and we use <code>[0]</code> to get the vector of two float numbers\u2014the output of the model.</p>"},{"location":"inference/onnx.html#full-example","title":"Full example","text":"<p>Let's construct the full example.</p> Click to expand <p>The example assumes the following directory structure:</p> <pre><code>MySubsystem/MyModule/\n\u2502\n\u251c\u2500\u2500 plugins/\n\u2502   \u251c\u2500\u2500 MyPlugin.cpp\n\u2502   \u2514\u2500\u2500 BuildFile.xml\n\u2502\n\u251c\u2500\u2500 test/\n\u2502   \u2514\u2500\u2500 my_plugin_cfg.py\n\u2502\n\u2514\u2500\u2500 data/\n    \u2514\u2500\u2500 model.onnx\n</code></pre> plugins/MyPlugin.cppplugins/BuildFile.xmltest/my_plugin_cfg.pydata/model.onnx <pre><code>/*\n * Example plugin to demonstrate the direct multi-threaded inference with ONNX Runtime.\n */\n\n#include &lt;memory&gt;\n#include &lt;iostream&gt;\n\n#include \"FWCore/Framework/interface/Event.h\"\n#include \"FWCore/Framework/interface/Frameworkfwd.h\"\n#include \"FWCore/Framework/interface/MakerMacros.h\"\n#include \"FWCore/Framework/interface/stream/EDAnalyzer.h\"\n#include \"FWCore/ParameterSet/interface/ParameterSet.h\"\n\n#include \"PhysicsTools/ONNXRuntime/interface/ONNXRuntime.h\"\n\nusing namespace cms::Ort;\n\nclass MyPlugin : public edm::stream::EDAnalyzer&lt;edm::GlobalCache&lt;ONNXRuntime&gt;&gt; {\npublic:\n  explicit MyPlugin(const edm::ParameterSet &amp;, const ONNXRuntime *);\n  static void fillDescriptions(edm::ConfigurationDescriptions&amp;);\n\n  static std::unique_ptr&lt;ONNXRuntime&gt; initializeGlobalCache(const edm::ParameterSet &amp;);\n  static void globalEndJob(const ONNXRuntime *);\n\nprivate:\n  void beginJob();\n  void analyze(const edm::Event&amp;, const edm::EventSetup&amp;);\n  void endJob();\n\n  std::vector&lt;std::string&gt; input_names_;\n  std::vector&lt;std::vector&lt;int64_t&gt;&gt; input_shapes_;\n  FloatArrays data_; // each stream hosts its own data\n};\n\n\nvoid MyPlugin::fillDescriptions(edm::ConfigurationDescriptions&amp; descriptions) {\n  // defining this function will lead to a *_cfi file being generated when compiling\n  edm::ParameterSetDescription desc;\n  desc.add&lt;edm::FileInPath&gt;(\"model_path\", edm::FileInPath(\"MySubsystem/MyModule/data/model.onnx\"));\n  desc.add&lt;std::vector&lt;std::string&gt;&gt;(\"input_names\", std::vector&lt;std::string&gt;({\"my_input\"}));\n  descriptions.addWithDefaultLabel(desc);\n}\n\n\nMyPlugin::MyPlugin(const edm::ParameterSet &amp;iConfig, const ONNXRuntime *cache)\n    : input_names_(iConfig.getParameter&lt;std::vector&lt;std::string&gt;&gt;(\"input_names\")),\n      input_shapes_() {\n    // initialize the input data arrays\n    // note there is only one element in the FloatArrays type (i.e. vector&lt;vector&lt;float&gt;&gt;) variable\n    data_.emplace_back(10, 0);\n}\n\n\nstd::unique_ptr&lt;ONNXRuntime&gt; MyPlugin::initializeGlobalCache(const edm::ParameterSet &amp;iConfig) {\n  return std::make_unique&lt;ONNXRuntime&gt;(iConfig.getParameter&lt;edm::FileInPath&gt;(\"model_path\").fullPath());\n}\n\nvoid MyPlugin::globalEndJob(const ONNXRuntime *cache) {}\n\nvoid MyPlugin::analyze(const edm::Event &amp;iEvent, const edm::EventSetup &amp;iSetup) {\n  // prepare dummy inputs for every event\n  std::vector&lt;float&gt; &amp;group_data = data_[0];\n  for (size_t i = 0; i &lt; 10; i++){\n      group_data[i] = float(iEvent.id().event() % 100 + i);\n  }\n\n  // run prediction and get outputs\n  std::vector&lt;float&gt; outputs = globalCache()-&gt;run(input_names_, data_, input_shapes_)[0];\n\n  // print the input and output data\n  std::cout &lt;&lt; \"input data -&gt; \";\n  for (auto &amp;i: group_data) { std::cout &lt;&lt; i &lt;&lt; \" \"; }\n  std::cout &lt;&lt; std::endl &lt;&lt; \"output data -&gt; \";\n  for (auto &amp;i: outputs) { std::cout &lt;&lt; i &lt;&lt; \" \"; }\n  std::cout &lt;&lt; std::endl;\n\n}\n\nDEFINE_FWK_MODULE(MyPlugin);\n</code></pre> <pre><code>&lt;use name=\"FWCore/Framework\" /&gt;\n&lt;use name=\"FWCore/PluginManager\" /&gt;\n&lt;use name=\"FWCore/ParameterSet\" /&gt;\n&lt;use name=\"PhysicsTools/ONNXRuntime\" /&gt;\n\n&lt;flags EDM_PLUGIN=\"1\" /&gt;\n</code></pre> <pre><code># coding: utf-8\n\nimport os\n\nimport FWCore.ParameterSet.Config as cms\nfrom FWCore.ParameterSet.VarParsing import VarParsing\n\n\n# setup minimal options\noptions = VarParsing(\"python\")\noptions.setDefault(\"inputFiles\", \"/store/mc/RunIISummer20UL18MiniAODv2/DYJetsToLL_M-50_TuneCP5_13TeV-amcatnloFXFX-pythia8/MINIAODSIM/106X_upgrade2018_realistic_v16_L1v1-v2/230000/4C8619B2-D0C0-4647-B946-B33754F4ED16.root\")  # noqa\noptions.parseArguments()\n\n# define the process to run\nprocess = cms.Process(\"TEST\")\n\n# minimal configuration\nprocess.load(\"FWCore.MessageService.MessageLogger_cfi\")\nprocess.MessageLogger.cerr.FwkReport.reportEvery = 1\nprocess.maxEvents = cms.untracked.PSet(input=cms.untracked.int32(10))\nprocess.source = cms.Source(\"PoolSource\",\n    fileNames=cms.untracked.vstring(options.inputFiles))\n\n# process options\nprocess.options = cms.untracked.PSet(\n    allowUnscheduled=cms.untracked.bool(True),\n    wantSummary=cms.untracked.bool(True),\n)\n\n# setup options for multithreaded\nprocess.options.numberOfThreads=cms.untracked.uint32(1)\nprocess.options.numberOfStreams=cms.untracked.uint32(0)\nprocess.options.numberOfConcurrentLuminosityBlocks=cms.untracked.uint32(1)\n\n\n# setup MyPlugin by loading the auto-generated cfi (see MyPlugin.fillDescriptions)\nprocess.load(\"MySubsystem.MyModule.myPlugin_cfi\")\n# specify the path of the ONNX model\nprocess.myPlugin.model_path = \"MySubsystem/MyModule/data/model.onnx\"\n# input names as defined in the model\n# the order of name strings should also corresponds to the order of input data array feed to the model\nprocess.myPlugin.input_names = [\"my_input\"]\n\n# define what to run in the path\nprocess.p = cms.Path(process.myPlugin)\n</code></pre> <p>The model is produced by code in the section \"Converting model to ONNX\" and can be downloaded here.</p>"},{"location":"inference/onnx.html#test-our-module","title":"Test our module","text":"<p>Under <code>MySubsystem/MyModule/test</code>, run <code>cmsRun my_plugin_cfg.py</code> to launch our module. You may see the following from the output, which include the input and output vectors in the inference process.</p> Click to see the output <pre><code>...\n19-Jul-2022 10:50:41 CEST  Successfully opened file root://xrootd-cms.infn.it//store/mc/RunIISummer20UL18MiniAODv2/DYJetsToLL_M-50_TuneCP5_13TeV-amcatnloFXFX-pythia8/MINIAODSIM/106X_upgrade2018_realistic_v16_L1v1-v2/230000/4C8619B2-D0C0-4647-B946-B33754F4ED16.root\nBegin processing the 1st record. Run 1, Event 27074045, LumiSection 10021 on stream 0 at 19-Jul-2022 10:50:43.494 CEST\ninput data -&gt; 45 46 47 48 49 50 51 52 53 54\noutput data -&gt; 0.995657 0.00434343\nBegin processing the 2nd record. Run 1, Event 27074048, LumiSection 10021 on stream 0 at 19-Jul-2022 10:50:43.495 CEST\ninput data -&gt; 48 49 50 51 52 53 54 55 56 57\noutput data -&gt; 0.996884 0.00311563\nBegin processing the 3rd record. Run 1, Event 27074059, LumiSection 10021 on stream 0 at 19-Jul-2022 10:50:43.495 CEST\ninput data -&gt; 59 60 61 62 63 64 65 66 67 68\noutput data -&gt; 0.999081 0.000919373\nBegin processing the 4th record. Run 1, Event 27074061, LumiSection 10021 on stream 0 at 19-Jul-2022 10:50:43.495 CEST\ninput data -&gt; 61 62 63 64 65 66 67 68 69 70\noutput data -&gt; 0.999264 0.000736247\nBegin processing the 5th record. Run 1, Event 27074046, LumiSection 10021 on stream 0 at 19-Jul-2022 10:50:43.496 CEST\ninput data -&gt; 46 47 48 49 50 51 52 53 54 55\noutput data -&gt; 0.996112 0.00388828\nBegin processing the 6th record. Run 1, Event 27074047, LumiSection 10021 on stream 0 at 19-Jul-2022 10:50:43.496 CEST\ninput data -&gt; 47 48 49 50 51 52 53 54 55 56\noutput data -&gt; 0.996519 0.00348065\nBegin processing the 7th record. Run 1, Event 27074064, LumiSection 10021 on stream 0 at 19-Jul-2022 10:50:43.496 CEST\ninput data -&gt; 64 65 66 67 68 69 70 71 72 73\noutput data -&gt; 0.999472 0.000527586\nBegin processing the 8th record. Run 1, Event 27074074, LumiSection 10021 on stream 0 at 19-Jul-2022 10:50:43.496 CEST\ninput data -&gt; 74 75 76 77 78 79 80 81 82 83\noutput data -&gt; 0.999826 0.000173664\nBegin processing the 9th record. Run 1, Event 27074050, LumiSection 10021 on stream 0 at 19-Jul-2022 10:50:43.496 CEST\ninput data -&gt; 50 51 52 53 54 55 56 57 58 59\noutput data -&gt; 0.997504 0.00249614\nBegin processing the 10th record. Run 1, Event 27074060, LumiSection 10021 on stream 0 at 19-Jul-2022 10:50:43.496 CEST\ninput data -&gt; 60 61 62 63 64 65 66 67 68 69\noutput data -&gt; 0.999177 0.000822734\n19-Jul-2022 10:50:43 CEST  Closed file root://xrootd-cms.infn.it//store/mc/RunIISummer20UL18MiniAODv2/DYJetsToLL_M-50_TuneCP5_13TeV-amcatnloFXFX-pythia8/MINIAODSIM/106X_upgrade2018_realistic_v16_L1v1-v2/230000/4C8619B2-D0C0-4647-B946-B33754F4ED16.root\n</code></pre> <p>Also we could try launching the script with more threads. Change the corresponding line in <code>my_plugin_cfg.py</code> as follows to activate the multi-threaded mode with 4 threads.</p> <pre><code>process.options.numberOfThreads=cms.untracked.uint32(4)\n</code></pre> <p>Launch the script again, and one could see the same results, but with the inference processed concurrently on 4 threads.</p>"},{"location":"inference/onnx.html#inference-in-cmssw-python","title":"Inference in CMSSW (Python)","text":"<p>Doing ONNX Runtime inference with python is possible as well. For those releases that have the ONNX Runtime C++ package installed, the <code>onnxruntime</code> python package is also installed in <code>python3</code> (except for CMSSW_10_6_X). We still use CMSSW_11_2_5_patch2 to run our examples. We could quickly check if <code>onnxruntime</code> is available by:</p> <pre><code>python3 -c \"import onnxruntime; print('onnxruntime available')\"\n</code></pre> <p>The python code is simple to construct: following the quick examples \"Get started with ORT for Python\", we create the file <code>MySubsystem/MyModule/test/my_standalone_test.py</code> as follows:</p> <pre><code>import onnxruntime as ort\nimport numpy as np\n\n# create input data in the float format (32 bit)\ndata = np.arange(45, 55).astype(np.float32)\n\n# create inference session using ort.InferenceSession from a given model\nort_sess = ort.InferenceSession('../data/model.onnx')\n\n# run inference\noutputs = ort_sess.run(None, {'my_input': np.array([data])})[0]\n\n# print input and output\nprint('input -&gt;', data)\nprint('output -&gt;', outputs)\n</code></pre> <p>Under the directory <code>MySubsystem/MyModule/test</code>, run the example with <code>python3 my_standalone_test.py</code>. Then we see the output:</p> <pre><code>input -&gt; [45. 46. 47. 48. 49. 50. 51. 52. 53. 54.]\noutput -&gt; [[0.9956566  0.00434343]]\n</code></pre> <p>Using ONNX Runtime on NanoAOD-tools follows the same logic. Here we create the ONNX <code>Session</code> in the beginning stage and run inference in the event loop. Note that NanoAOD-tools runs the event loop in the single-thread mode.</p> <p>Please find details in the following block.</p> Click to see the NanoAOD-tools example <p>We run the NanoAOD-tools example following the above CMSSW_11_2_5_patch2 environment. According to the setup instruction in NanoAOD-tools, do</p> <pre><code>cd $CMSSW_BASE/src\ngit clone https://github.com/cms-nanoAOD/nanoAOD-tools.git PhysicsTools/NanoAODTools\ncd PhysicsTools/NanoAODTools\ncmsenv\nscram b\n</code></pre> <p>Now we add our custom module to run ONNX Runtime inference. Create a file <code>PhysicsTools/NanoAODTools/python/postprocessing/examples/exampleOrtModule.py</code> with the content:</p> <pre><code>from PhysicsTools.NanoAODTools.postprocessing.framework.datamodel import Collection\nfrom PhysicsTools.NanoAODTools.postprocessing.framework.eventloop import Module\nimport ROOT\nROOT.PyConfig.IgnoreCommandLineOptions = True\n\nimport onnxruntime as ort\nimport numpy as np\nimport os \n\nclass exampleOrtProducer(Module):\n    def __init__(self):\n        pass\n\n    def beginJob(self):\n        model_path = os.path.join(os.getenv(\"CMSSW_BASE\"), 'src', 'MySubsystem/MyModule/data/model.onnx')\n        self.ort_sess = ort.InferenceSession(model_path)\n\n    def endJob(self):\n        pass\n\n    def beginFile(self, inputFile, outputFile, inputTree, wrappedOutputTree):\n        self.out = wrappedOutputTree\n        self.out.branch(\"OrtScore\", \"F\")\n\n    def endFile(self, inputFile, outputFile, inputTree, wrappedOutputTree):\n        pass\n\n    def analyze(self, event):\n        \"\"\"process event, return True (go to next module) or False (fail, go to next event)\"\"\"\n\n        # create input data\n        data = np.arange(event.event % 100, event.event % 100 + 10).astype(np.float32)\n        # run inference\n        outputs = self.ort_sess.run(None, {'my_input': np.array([data])})[0]\n        # print input and output\n        print('input -&gt;', data)\n        print('output -&gt;', outputs)\n\n        self.out.fillBranch(\"OrtScore\", outputs[0][0])\n        return True\n\n\n# define modules using the syntax 'name = lambda : constructor' to avoid having them loaded when not needed\n\nexampleOrtModuleConstr = lambda: exampleOrtProducer()\n</code></pre> <p>Please notice the highlighted lines for the creation of ONNX Runtime <code>Session</code> and launching the inference.</p> <p>Finally, following the test command from NanoAOD-tools, we run our custom module in <code>python3</code> by <pre><code>python3 scripts/nano_postproc.py outDir /eos/cms/store/user/andrey/f.root -I PhysicsTools.NanoAODTools.postprocessing.examples.exampleOrtModule exampleOrtModuleConstr -N 10\n</code></pre></p> <p>We should see the output as follows <pre><code>processing.examples.exampleOrtModule exampleOrtModuleConstr -N 10\nLoading exampleOrtModuleConstr from PhysicsTools.NanoAODTools.postprocessing.examples.exampleOrtModule\nWill write selected trees to outDir\nPre-select 10 entries out of 10 (100.00%)\ninput -&gt; [11. 12. 13. 14. 15. 16. 17. 18. 19. 20.]\noutput -&gt; [[0.83919346 0.16080655]]\ninput -&gt; [ 7.  8.  9. 10. 11. 12. 13. 14. 15. 16.]\noutput -&gt; [[0.76994413 0.2300559 ]]\ninput -&gt; [ 4.  5.  6.  7.  8.  9. 10. 11. 12. 13.]\noutput -&gt; [[0.7116992 0.2883008]]\ninput -&gt; [ 2.  3.  4.  5.  6.  7.  8.  9. 10. 11.]\noutput -&gt; [[0.66414535 0.33585465]]\ninput -&gt; [ 9. 10. 11. 12. 13. 14. 15. 16. 17. 18.]\noutput -&gt; [[0.80617136 0.19382869]]\ninput -&gt; [ 6.  7.  8.  9. 10. 11. 12. 13. 14. 15.]\noutput -&gt; [[0.75187963 0.2481204 ]]\ninput -&gt; [16. 17. 18. 19. 20. 21. 22. 23. 24. 25.]\noutput -&gt; [[0.9014619  0.09853811]]\ninput -&gt; [18. 19. 20. 21. 22. 23. 24. 25. 26. 27.]\noutput -&gt; [[0.9202239  0.07977609]]\ninput -&gt; [ 5.  6.  7.  8.  9. 10. 11. 12. 13. 14.]\noutput -&gt; [[0.7330253  0.26697478]]\ninput -&gt; [10. 11. 12. 13. 14. 15. 16. 17. 18. 19.]\noutput -&gt; [[0.82333535 0.17666471]]\nProcessed 10 preselected entries from /eos/cms/store/user/andrey/f.root (10 entries). Finally selected 10 entries\nDone outDir/f_Skim.root\nTotal time 1.1 sec. to process 10 events. Rate = 9.3 Hz.\n</code></pre></p>"},{"location":"inference/onnx.html#links-and-further-reading","title":"Links and further reading","text":"<ul> <li>ONNX/ONNX Runtime<ul> <li>Tutorials on converting models to ONNX format</li> <li>ONNX Runtime C++ example</li> <li>ONNX Runtime C++ API</li> <li>ONNX Runtime python example</li> <li>ONNX Runtime python API</li> <li>ONNX Runtime in CMSSW (talk)</li> </ul> </li> </ul> <p>Developers: Huilin Qu</p> <p>Authors: Congqiao Li</p>"},{"location":"inference/particlenet.html","title":"ParticleNet","text":"<p>ParticleNet [arXiv:1902.08570] is an advanced neural network architecture that has many applications in CMS, including heavy flavour jet tagging, jet mass regression, etc. The network is fed by various low-level point-like objects as input, e.g., the particle-flow candidates, to predict a feature of a jet.</p> The full architecture of the ParticleNet model. We'll walk through the details in the following sections. <p>On this page, we introduce several user-specific aspects of the ParticleNet model. We cover the following items in three sections:</p> <ol> <li> <p>An introduction to ParticleNet, including</p> <ul> <li>a general description of ParticleNet</li> <li>the advantages brought from the architecture by concept</li> <li>a sketch of ParticleNet applications in CMS and other relevant works</li> </ul> </li> <li> <p>An introduction to <code>Weaver</code> and model implementations, introduced in a step-by-step manner:</p> <ul> <li>build three network models and understand them from the technical side; use the out-of-the-box commands to run these examples on a benchmark task. The three networks are (1) a simple feed-forward NN, (2) a DeepAK8 model (based on 1D CNN), and eventually (3) the ParticleNet model (based on DGCNN).</li> <li>try to reproduce the original performance and make the ROC plots.</li> </ul> <p>This section is friendly to the ML newcomers. The goal is to help readers understand the underlying structure of the \"ParticleNet\".</p> </li> <li> <p>Tuning the ParticleNet model, including</p> <ul> <li>tips for readers who are using/modifying the ParticleNet model to achieve a better performance</li> </ul> <p>This section can be helpful in practice. It provides tips on model training, tunning, validation, etc. It targets the situations when readers apply their own ParticleNet (or ParticleNet-like) model to the custom task.</p> </li> </ol> <p>Corresponding persons:</p> <ul> <li>Huilin Qu, Loukas Gouskos (original developers of ParticleNet)</li> <li>Congqiao Li (author of the page)</li> </ul>"},{"location":"inference/particlenet.html#introduction-to-particlenet","title":"Introduction to ParticleNet","text":""},{"location":"inference/particlenet.html#1-general-description","title":"1. General description","text":"<p>ParticleNet is a graph neural net (GNN) model. The key ingredient of ParticleNet is the graph convolutional operation, i.e., the edge convolution (EdgeConv) and the dynamic graph CNN (DGCNN) method [arXiv:1801.07829] applied on the \"point cloud\" data structure.</p> <p>We will disassemble the ParticleNet model and provide a detailed exploration in the next section, but here we briefly explain the key features of the model.</p> <p>Intuitively, ParticleNet treats all candidates inside an object as a \"point cloud\", which is a permutational-invariant set of points (e.g. a set of PF candidates), each carrying a feature vector (\u03b7, \u03c6, p<sub>T</sub>, charge, etc.). The DGCNN uses the EdgeConv operation to exploit their spatial correlations (two-dimensional on the \u03b7-\u03c6 plain) by finding the k-nearest neighbours of each point and generate a new latent graph layer where points are scattered on a high-dimensional latent space. This is a graph-type analogue of the classical 2D convolution operation, which acts on a regular 2D grid (e.g., a picture) using a 3\u00d73 local patch to explore the relations of a single-pixel with its 8 nearest pixels, then generates a new 2D grid.</p> The cartoon illustrates the convolutional operation acted on the regular grid and on the point cloud (plot from ML4Jets 2018 talk). <p>As a consequence, the EdgeConv operation transforms the graph to a new graph, which has a changed spatial relationship among points. It then acts on the second graph to produce the third graph, showing the stackability of the convolution operation. This illustrates the \"dynamic\" property as the graph topology changes after each EdgeConv layer.</p>"},{"location":"inference/particlenet.html#2-advantage","title":"2. Advantage","text":"<p>By concept, the advantage of the network may come from exploiting the permutational-invariant symmetry of the points, which is intrinsic to our physics objects. This symmetry is held naturally in a point cloud representation.</p> <p>In a recent study on jet physics or event-based analysis using ML techniques, there are increasing interest to explore the point cloud data structure. We explain here conceptually why a \"point cloud\" representation outperforms the classical ones, including the variable-length 2D vector structure passing to a 1D CNN or any type of RNN, and imaged-based representation passing through a 2D CNN. By using the 1D CNN, the points (PF candidates) are more often ordered by p<sub>T</sub> to fix on the 1D grid. Only correlations with neighbouring points with similar p<sub>T</sub> are learned by the network with a convolution operation. The Long Short-Term Memory (LSTM) type recurrent neural network (RNN) provides the flexibility to feed in a variant-length sequence and has a \"memory\" mechanism to cooperate the information it learns from an early node to the latest node. The concern is that such ordering of the sequence is somewhat artificial, and not an underlying property that an NN must learn to accomplish the classification task. As a comparison, in the task of the natural language processing where LSTM has a huge advantage, the order of words are important characteristic of a language itself (reflects the \"grammar\" in some circumstances) and is a feature the NN must learn to master the language. The imaged-based data explored by a 2D CNN stems from the image recognition task. A jet image with proper standardization is usually performed before feeding into the network. In this sense, it lacks local features which the 2D local patch is better at capturing, e.g. the ear of the cat that a local patch can capture by scanning over the entire image. The jet image is appearing to hold the features globally (e.g. two-prong structure for W-tagging). The sparsity of data is another concern in that it introduces redundant information to present a jet on the regular grid, making the network hard to capture the key properties.</p>"},{"location":"inference/particlenet.html#3-applications-and-other-related-work","title":"3. Applications and other related work","text":"<p>Here we briefly summarize the applications and ongoing works on ParticleNet. Public CMS results include</p> <ul> <li>large-R jet with R=0.8 tagging (for W/Z/H/t) using ParticleNet [CMS-DP-2020/002]</li> <li>regression on the large-R jet mass based on the ParticleNet model [CMS-DP-2021/017]</li> </ul> <p>ParticleNet architecture is also applied on small radius R=0.4 jets for the b/c-tagging and quark/gluon classification (see this talk (CMS internal)). A recent ongoing work applies the ParticleNet architecture in heavy flavour tagging at HLT (see this talk (CMS internal)). The ParticleNet model is recently updated to ParticleNeXt and see further improvement (see the ML4Jets 2021 talk).</p> <p>Recent works in the joint field of HEP and ML also shed light on exploiting the point cloud data structure and GNN-based architectures. We see very active progress in recent years. Here list some useful materials for the reader's reference.</p> <ul> <li>Some pheno-based work are summarized in the HEP \u00d7 ML living review, especially in the \"graph\" and \"sets\" categories.</li> <li>An overview of GNN applications to CMS, see CMS ML forum (CMS internal). Also see more recent GNN application progress in ML forums: Oct 20, Nov 3.</li> <li>At the time of writing, various novel GNN-based models are explored and introduced in the recent ML4Jets2021 meeting.</li> </ul>"},{"location":"inference/particlenet.html#introduction-to-weaver-and-model-implementations","title":"Introduction to <code>Weaver</code> and model implementations","text":"<p><code>Weaver</code> is a machine learning R&amp;D framework for high energy physics (HEP) applications. It trains the neural net with PyTorch and is capable of exporting the model to the ONNX format for fast inference. A detailed guide is presented on <code>Weaver</code> README page.</p> <p>Now we walk through three solid examples to get you familiar with <code>Weaver</code>. We use the benchmark of the top tagging task [arXiv:1707.08966] in the following example. Some useful information can be found in the \"top tagging\" section in the IML public datasets webpage (the gDoc).</p> <p>Our goal is to do some warm-up with <code>Weaver</code>, and more importantly, to explore from a technical side the neural net architectures: a simple multi-layer perceptron (MLP) model, a more complicated \"DeepAK8 tagger\" model based on 1D CNN with ResNet, and the \"ParticleNet model,\" which is based on DGCNN. We will dig deeper into their implementations in <code>Weaver</code> and try to illustrate as many details as possible. Finally, we compare their performance and see if we can reproduce the benchmark record with the model. Please clone the repo <code>weaver-benchmark</code> and we'll get started. The <code>Weaver</code> repo will be cloned as a submodule. <pre><code>git clone --recursive https://github.com/colizz/weaver-benchmark.git\n\n# Create a soft link inside weaver so that it can find data/model cards\nln -s ../top_tagging weaver-benchmark/weaver/top_tagging\n</code></pre></p>"},{"location":"inference/particlenet.html#1-build-models-in-weaver","title":"1. Build models in <code>Weaver</code>","text":"<p>When implementing a new training in <code>Weaver</code>, two key elements are crucial: the model and the data configuration file. The model defines the network architecture we are using, and the data configuration includes which variables to use for training, which pre-selection to apply, how to assign truth labels, etc.</p> <p>Technically, The model configuration file includes a <code>get_model</code> function that returns a <code>torch.nn.Module</code> type model and a dictionary of model info used to export an ONNX-format model. The data configuration is a YAML file describing how to process the input data. Please see the <code>Weaver</code> README for details.</p> <p>Before moving on, we need a preprocessing of the benchmark datasets. The original sample is an H5 file including branches like energy <code>E_i</code> and 3-momenta <code>PX_i</code>, <code>PY_i</code>, <code>PZ_i</code> for each jet constituent i (i=0, ..., 199) inside a jet. All branches are in the 1D flat structure. We reconstruct the data in a way that the jet features are 2D vectors (e.g., in the <code>vector&lt;float&gt;</code> format): <code>Part_E</code>, <code>Part_PX</code>, <code>Part_PY</code>, <code>Part_PZ</code>, with variable-length that corresponds to the number of constituents. Note that this is a commonly used data structure, similar to the NanoAOD format in CMS.</p> <p>The datasets can be found at CERN EOS space <code>/eos/user/c/coli/public/weaver-benchmark/top_tagging/samples</code>. The input files used in this page are in fact the ROOT files produced by the preprocessing step, stored under the <code>prep/</code> subdirectory. It includes three sets of data for training, validation, and test.</p> <p>Note</p> <p>To preprocess the input files from the original datasets manually, direct to the <code>weaver-benchmark</code> base directory and run <pre><code>python utils/convert_top_datasets.py -i &lt;your-sample-dir&gt;\n</code></pre> This will convert the <code>.h5</code> file to ROOT ntuples and create some new variables for each jet, including the relative \u03b7 and \u03c6 value w.r.t. main axis of the jet of each jet constituent. The converted files are stored in <code>prep/</code> subfolder of the original directory.</p> <p>Then, we show three NN model configurations below and provide detailed explanations of the code. We make meticulous efforts on the illustration of the model architecture, especially in the ParticleNet case.</p> A simple MLPDeepAK8 (1D CNN)ParticleNet (DGCNN) <p> The full architecture of the proof-of-concept multi-layer perceptron model. </p> <p>A simple multi-layer perceptron model is first provided here as proof of the concept. All layers are based on the linear transformation of the 1D vectors. The model configuration card is shown in <code>top_tagging/networks/mlp_pf.py</code>. First, we implement an MLP network in the <code>nn.Module</code> class.</p> MLP implementation <p>Also, see <code>top_tagging/networks/mlp_pf.py</code>. We elaborate here on several aspects.</p> <ul> <li> <p>A sequence of linear layers and ReLU activation functions is defined in <code>nn.Sequential(nn.Linear(channels[i], channels[i + 1]), nn.ReLU())</code>. By combining multiple of them, we construct a simple multi-layer perceptron.</p> </li> <li> <p>The input data <code>x</code> takes the 3D format, in the dimension <code>(N, C, P)</code>, which is decided by our data structure and the data configuration card. Here, <code>N</code> is the mini-batch size, <code>C</code> is the feature size, and <code>P</code> is the size of constituents per jet. To feed into our MLP, we flatten the last two dimensions by <code>x = x.flatten(start_dim=1)</code> to form the vector of dimension <code>(N, L)</code>.</p> </li> </ul> <pre><code>class MultiLayerPerceptron(nn.Module):\n    r\"\"\"Parameters\n    ----------\n    input_dims : int\n        Input feature dimensions.\n    num_classes : int\n        Number of output classes.\n    layer_params : list\n        List of the feature size for each layer.\n    \"\"\"\n\n    def __init__(self, input_dims, num_classes,\n                layer_params=(1024, 256, 256),\n                **kwargs):\n\n        super(MultiLayerPerceptron, self).__init__(**kwargs)\n        channels = [input_dims] + list(layer_params) + [num_classes]\n        layers = []\n        for i in range(len(channels) - 1):\n            layers.append(nn.Sequential(nn.Linear(channels[i], channels[i + 1]),\n                                        nn.ReLU()))\n        self.mlp = nn.Sequential(*layers)\n\n    def forward(self, x):\n        # x: the feature vector initally read from the data structure, in dimension (N, C, P)\n        x = x.flatten(start_dim=1) # (N, L), where L = C * P\n        return self.mlp(x)\n</code></pre> <p>Then, we write the <code>get_model</code> and <code>get_loss</code> functions which will be sent into <code>Weaver</code>'s training code.</p> <code>get_model</code> and <code>get_loss</code> function <p>Also see <code>top_tagging/networks/mlp_pf.py</code>. We elaborate here on several aspects.</p> <ul> <li>Inside <code>get_model</code>, the <code>model</code> is essentially the MLP class we define, and the <code>model_info</code> takes the default definition, including the input/output shape, the dimensions of the dynamic axes for the input/output data shape that will guide the ONNX model exportation.</li> <li>The <code>get_loss</code> function is not changed as in the classification task we always use the cross-entropy loss function.</li> </ul> <pre><code>def get_model(data_config, **kwargs):\n    layer_params = (1024, 256, 256)\n    _, pf_length, pf_features_dims = data_config.input_shapes['pf_features']\n    input_dims = pf_length * pf_features_dims\n    num_classes = len(data_config.label_value)\n    model = MultiLayerPerceptron(input_dims, num_classes, layer_params=layer_params)\n\n    model_info = {\n        'input_names':list(data_config.input_names),\n        'input_shapes':{k:((1,) + s[1:]) for k, s in data_config.input_shapes.items()},\n        'output_names':['softmax'],\n        'dynamic_axes':{**{k:{0:'N', 2:'n_' + k.split('_')[0]} for k in data_config.input_names}, **{'softmax':{0:'N'}}},\n        }\n\n    print(model, model_info)\n    return model, model_info\n\n\ndef get_loss(data_config, **kwargs):\n    return torch.nn.CrossEntropyLoss()\n</code></pre> <p>The output below shows the full structure of the MLP network printed by PyTorch. You will see it in the <code>Weaver</code> output during the training.</p> The full-scale structure of the MLP network <pre><code>MultiLayerPerceptron(\n  |0.739 M, 100.000% Params, 0.001 GMac, 100.000% MACs|\n  (mlp): Sequential(\n    |0.739 M, 100.000% Params, 0.001 GMac, 100.000% MACs|\n    (0): Sequential(\n      |0.411 M, 55.540% Params, 0.0 GMac, 55.563% MACs|\n      (0): Linear(in_features=400, out_features=1024, bias=True, |0.411 M, 55.540% Params, 0.0 GMac, 55.425% MACs|)\n      (1): ReLU(|0.0 M, 0.000% Params, 0.0 GMac, 0.138% MACs|)\n    )\n    (1): Sequential(\n      |0.262 M, 35.492% Params, 0.0 GMac, 35.452% MACs|\n      (0): Linear(in_features=1024, out_features=256, bias=True, |0.262 M, 35.492% Params, 0.0 GMac, 35.418% MACs|)\n      (1): ReLU(|0.0 M, 0.000% Params, 0.0 GMac, 0.035% MACs|)\n    )\n    (2): Sequential(\n      |0.066 M, 8.899% Params, 0.0 GMac, 8.915% MACs|\n      (0): Linear(in_features=256, out_features=256, bias=True, |0.066 M, 8.899% Params, 0.0 GMac, 8.880% MACs|)\n      (1): ReLU(|0.0 M, 0.000% Params, 0.0 GMac, 0.035% MACs|)\n    )\n    (3): Sequential(\n      |0.001 M, 0.070% Params, 0.0 GMac, 0.070% MACs|\n      (0): Linear(in_features=256, out_features=2, bias=True, |0.001 M, 0.070% Params, 0.0 GMac, 0.069% MACs|)\n      (1): ReLU(|0.0 M, 0.000% Params, 0.0 GMac, 0.000% MACs|)\n    )\n  )\n)\n</code></pre> <p>The data card is shown in <code>top_tagging/data/pf_features.yaml</code>. It defines one input group, <code>pf_features</code>, which takes four variables <code>Etarel</code>, <code>Phirel</code>, <code>E_log</code>, <code>P_log</code>. This is based on our data structure, where these variables are 2D vectors with variable lengths. The <code>length</code> is chosen as 100 in a way that the last dimension (the jet constituent dimension) is always truncated or padded to have length 100.</p> MLP data config <code>top_tagging/data/pf_features.yaml</code> <p>Also see <code>top_tagging/data/pf_features.yaml</code>. See a tour guide to the data configuration card in <code>Weaver</code> README. <pre><code>selection:\n### use `&amp;`, `|`, `~` for logical operations on numpy arrays\n### can use functions from `math`, `np` (numpy), and `awkward` in the expression\n\nnew_variables:\n### [format] name: formula\n### can use functions from `math`, `np` (numpy), and `awkward` in the expression\nis_bkg: np.logical_not(is_signal_new)\n\npreprocess:\n### method: [manual, auto] - whether to use manually specified parameters for variable standardization\nmethod: manual\n### data_fraction: fraction of events to use when calculating the mean/scale for the standardization\ndata_fraction:\n\ninputs:\npf_features:\n    length: 100\n    vars:\n    ### [format 1]: var_name (no transformation)\n    ### [format 2]: [var_name,\n    ###              subtract_by(optional, default=None, no transf. if preprocess.method=manual, auto transf. if preprocess.method=auto),\n    ###              multiply_by(optional, default=1),\n    ###              clip_min(optional, default=-5),\n    ###              clip_max(optional, default=5),\n    ###              pad_value(optional, default=0)]\n        - Part_Etarel\n        - Part_Phirel\n        - [Part_E_log, 2, 1]\n        - [Part_P_log, 2, 1]\n\nlabels:\n### type can be `simple`, `custom`\n### [option 1] use `simple` for binary/multi-class classification, then `value` is a list of 0-1 labels\ntype: simple\nvalue: [\n    is_signal_new, is_bkg\n    ]\n### [option 2] otherwise use `custom` to define the label, then `value` is a map\n# type: custom\n# value:\n    # target_mass: np.where(fj_isQCD, fj_genjet_sdmass, fj_gen_mass)\n\nobservers:\n- origIdx\n- idx\n- Part_E_tot\n- Part_PX_tot\n- Part_PY_tot\n- Part_PZ_tot\n- Part_P_tot\n- Part_Eta_tot\n- Part_Phi_tot\n\n# weights:\n### [option 1] use precomputed weights stored in the input files\n# use_precomputed_weights: true\n# weight_branches: [weight, class_weight]\n### [option 2] compute weights on-the-fly using reweighting histograms\n</code></pre></p> <p>In the following two models (i.e., the DeepAK8 and the ParticleNet model) you will see that the data card is very similar. The change will only be the way we present the input group(s).</p> <p> The full architecture of the DeepAK8 model, which is based on 1D CNN with ResNet architecture. </p> <p>Note</p> <p>The DeepAK8 tagger is a widely used highly-boosted jet tagger in the CMS community. The design of the model can be found in the CMS paper [arXiv:2004.08262]. The original model is trained on MXNet and its configuration can be found here.</p> <p>We now migrate the model architecture to <code>Weaver</code> and train it on PyTorch. Also, we narrow the multi-class output score to the binary output to adapt our binary classification task (top vs. QCD jet).</p> <p>The model card is given in <code>top_tagging/networks/deepak8_pf.py</code>. The DeepAK8 model is inspired by the ResNet architecture. The key ingredient is the ResNet unit constructed by multiple CNN layers with a shortcut connection. First, we define the ResNet unit in the model card.</p> ResNet unit implementation <p>See <code>top_tagging/networks/deepak8_pf.py</code>. We elaborate here on several aspects.</p> <ul> <li>A ResNet unit is made of two 1D CNNs with batch normalization and ReLU activation function.</li> <li>The shortcut is introduced here by directly adding the input data to the processed data after passing the CNN layers. The shortcut connection help to ease the training for the \"deeper\" model [arXiv:1512.03385]. Note that a trivial linear transformation is applied (<code>self.conv_sc</code>) if the feature dimension of the input and output data does not match.</li> </ul> <pre><code>class ResNetUnit(nn.Module):\n    r\"\"\"Parameters\n    ----------\n    in_channels : int\n        Number of channels in the input vectors.\n    out_channels : int\n        Number of channels in the output vectors.\n    strides: tuple\n        Strides of the two convolutional layers, in the form of (stride0, stride1)\n    \"\"\"\n\n    def __init__(self, in_channels, out_channels, strides=(1,1), **kwargs):\n\n        super(ResNetUnit, self).__init__(**kwargs)\n        self.conv1 = nn.Conv1d(in_channels, out_channels, kernel_size=3, stride=strides[0], padding=1)\n        self.bn1 = nn.BatchNorm1d(out_channels)\n        self.conv2 = nn.Conv1d(out_channels, out_channels, kernel_size=3, stride=strides[1], padding=1)\n        self.bn2 = nn.BatchNorm1d(out_channels)\n        self.relu = nn.ReLU()\n        self.dim_match = True\n        if not in_channels == out_channels or not strides == (1,1): # dimensions not match\n            self.dim_match = False\n            self.conv_sc = nn.Conv1d(in_channels, out_channels, kernel_size=1, stride=strides[0]*strides[1], bias=False)\n\n    def forward(self, x):\n        identity = x\n        x = self.conv1(x)\n        x = self.bn1(x)\n        x = self.relu(x)\n        x = self.conv2(x)\n        x = self.bn2(x)\n        x = self.relu(x)\n        # print('resnet unit', identity.shape, x.shape, self.dim_match)\n        if self.dim_match:\n            return identity + x\n        else:\n            return self.conv_sc(identity) + x\n</code></pre> <p>With the ResNet unit, we construct the DeepAK8 model. The model hyperparameters are chosen as follows. <pre><code>conv_params = [(32,), (64, 64), (64, 64), (128, 128)]\nfc_params = [(512, 0.2)]\n</code></pre></p> DeepAK8 model implementation <p>See <code>top_tagging/networks/deepak8_pf.py</code>. Note that the main architecture is a PyTorch re-implementation of the code here based on the MXNet.</p> <pre><code>class ResNet(nn.Module):\n    r\"\"\"Parameters\n    ----------\n    features_dims : int\n        Input feature dimensions.\n    num_classes : int\n        Number of output classes.\n    conv_params : list\n        List of the convolution layer parameters.\n        The first element is a tuple of size 1, defining the transformed feature size for the initial feature convolution layer.\n        The following are tuples of feature size for multiple stages of the ResNet units. Each number defines an individual ResNet unit.\n    fc_params: list\n        List of fully connected layer parameters after all EdgeConv blocks, each element in the format of\n        (n_feat, drop_rate)\n    \"\"\"\n\n    def __init__(self, features_dims, num_classes,\n                conv_params=[(32,), (64, 64), (64, 64), (128, 128)],\n                fc_params=[(512, 0.2)],\n                **kwargs):\n\n        super(ResNet, self).__init__(**kwargs)\n        self.conv_params = conv_params\n        self.num_stages = len(conv_params) - 1\n        self.fts_conv = nn.Sequential(nn.Conv1d(in_channels=features_dims, out_channels=conv_params[0][0], kernel_size=3, stride=1, padding=1),\n                                    nn.BatchNorm1d(conv_params[0][0]),\n                                    nn.ReLU())\n\n        # define ResNet units for each stage. Each unit is composed of a sequence of ResNetUnit block\n        self.resnet_units = nn.ModuleDict()\n        for i in range(self.num_stages):\n            # stack units[i] layers in this stage\n            unit_layers = []\n            for j in range(len(conv_params[i + 1])):\n                in_channels, out_channels = (conv_params[i][-1], conv_params[i + 1][0]) if j == 0 \\\n                                            else (conv_params[i + 1][j - 1], conv_params[i + 1][j])\n                strides = (2, 1) if (j == 0 and i &gt; 0) else (1, 1)\n                unit_layers.append(ResNetUnit(in_channels, out_channels, strides))\n\n            self.resnet_units.add_module('resnet_unit_%d' % i, nn.Sequential(*unit_layers))\n\n        # define fully connected layers\n        fcs = []\n        for idx, layer_param in enumerate(fc_params):\n            channels, drop_rate = layer_param\n            in_chn = conv_params[-1][-1] if idx == 0 else fc_params[idx - 1][0]\n            fcs.append(nn.Sequential(nn.Linear(in_chn, channels), nn.ReLU(), nn.Dropout(drop_rate)))\n        fcs.append(nn.Linear(fc_params[-1][0], num_classes))\n        self.fc = nn.Sequential(*fcs)\n\n    def forward(self, x):\n        # x: the feature vector, (N, C, P)\n        x = self.fts_conv(x)\n        for i in range(self.num_stages):\n            x = self.resnet_units['resnet_unit_%d' % i](x) # (N, C', P'), P'&lt;P due to kernal_size&gt;1 or stride&gt;1\n\n        # global average pooling\n        x = x.sum(dim=-1) / x.shape[-1] # (N, C')\n        # fully connected\n        x = self.fc(x) # (N, out_chn)\n        return x\n\n\ndef get_model(data_config, **kwargs):\n    conv_params = [(32,), (64, 64), (64, 64), (128, 128)]\n    fc_params = [(512, 0.2)]\n\n    pf_features_dims = len(data_config.input_dicts['pf_features'])\n    num_classes = len(data_config.label_value)\n    model = ResNet(pf_features_dims, num_classes,\n                conv_params=conv_params,\n                fc_params=fc_params)\n\n    model_info = {\n        'input_names':list(data_config.input_names),\n        'input_shapes':{k:((1,) + s[1:]) for k, s in data_config.input_shapes.items()},\n        'output_names':['softmax'],\n        'dynamic_axes':{**{k:{0:'N', 2:'n_' + k.split('_')[0]} for k in data_config.input_names}, **{'softmax':{0:'N'}}},\n        }\n\n    print(model, model_info)\n    print(data_config.input_shapes)\n    return model, model_info\n\n\ndef get_loss(data_config, **kwargs):\n    return torch.nn.CrossEntropyLoss()\n</code></pre> <p>The output below shows the full structure of the DeepAK8 model based on 1D CNN with ResNet. It is printed by PyTorch and you will see it in the <code>Weaver</code> output during training.</p> The full-scale structure of the DeepAK8 architecture <pre><code>ResNet(\n  |0.349 M, 100.000% Params, 0.012 GMac, 100.000% MACs|\n  (fts_conv): Sequential(\n    |0.0 M, 0.137% Params, 0.0 GMac, 0.427% MACs|\n    (0): Conv1d(4, 32, kernel_size=(3,), stride=(1,), padding=(1,), |0.0 M, 0.119% Params, 0.0 GMac, 0.347% MACs|)\n    (1): BatchNorm1d(32, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True, |0.0 M, 0.018% Params, 0.0 GMac, 0.053% MACs|)\n    (2): ReLU(|0.0 M, 0.000% Params, 0.0 GMac, 0.027% MACs|)\n  )\n  (resnet_units): ModuleDict(\n    |0.282 M, 80.652% Params, 0.012 GMac, 99.010% MACs|\n    (resnet_unit_0): Sequential(\n      |0.046 M, 13.124% Params, 0.005 GMac, 38.409% MACs|\n      (0): ResNetUnit(\n        |0.021 M, 5.976% Params, 0.002 GMac, 17.497% MACs|\n        (conv1): Conv1d(32, 64, kernel_size=(3,), stride=(1,), padding=(1,), |0.006 M, 1.778% Params, 0.001 GMac, 5.175% MACs|)\n        (bn1): BatchNorm1d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True, |0.0 M, 0.037% Params, 0.0 GMac, 0.107% MACs|)\n        (conv2): Conv1d(64, 64, kernel_size=(3,), stride=(1,), padding=(1,), |0.012 M, 3.538% Params, 0.001 GMac, 10.296% MACs|)\n        (bn2): BatchNorm1d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True, |0.0 M, 0.037% Params, 0.0 GMac, 0.107% MACs|)\n        (relu): ReLU(|0.0 M, 0.000% Params, 0.0 GMac, 0.107% MACs|)\n        (conv_sc): Conv1d(32, 64, kernel_size=(1,), stride=(1,), bias=False, |0.002 M, 0.587% Params, 0.0 GMac, 1.707% MACs|)\n      )\n      (1): ResNetUnit(\n        |0.025 M, 7.149% Params, 0.003 GMac, 20.912% MACs|\n        (conv1): Conv1d(64, 64, kernel_size=(3,), stride=(1,), padding=(1,), |0.012 M, 3.538% Params, 0.001 GMac, 10.296% MACs|)\n        (bn1): BatchNorm1d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True, |0.0 M, 0.037% Params, 0.0 GMac, 0.107% MACs|)\n        (conv2): Conv1d(64, 64, kernel_size=(3,), stride=(1,), padding=(1,), |0.012 M, 3.538% Params, 0.001 GMac, 10.296% MACs|)\n        (bn2): BatchNorm1d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True, |0.0 M, 0.037% Params, 0.0 GMac, 0.107% MACs|)\n        (relu): ReLU(|0.0 M, 0.000% Params, 0.0 GMac, 0.107% MACs|)\n      )\n    )\n    (resnet_unit_1): Sequential(\n      |0.054 M, 15.471% Params, 0.003 GMac, 22.619% MACs|\n      (0): ResNetUnit(\n        |0.029 M, 8.322% Params, 0.001 GMac, 12.163% MACs|\n        (conv1): Conv1d(64, 64, kernel_size=(3,), stride=(2,), padding=(1,), |0.012 M, 3.538% Params, 0.001 GMac, 5.148% MACs|)\n        (bn1): BatchNorm1d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True, |0.0 M, 0.037% Params, 0.0 GMac, 0.053% MACs|)\n        (conv2): Conv1d(64, 64, kernel_size=(3,), stride=(1,), padding=(1,), |0.012 M, 3.538% Params, 0.001 GMac, 5.148% MACs|)\n        (bn2): BatchNorm1d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True, |0.0 M, 0.037% Params, 0.0 GMac, 0.053% MACs|)\n        (relu): ReLU(|0.0 M, 0.000% Params, 0.0 GMac, 0.053% MACs|)\n        (conv_sc): Conv1d(64, 64, kernel_size=(1,), stride=(2,), bias=False, |0.004 M, 1.173% Params, 0.0 GMac, 1.707% MACs|)\n      )\n      (1): ResNetUnit(\n        |0.025 M, 7.149% Params, 0.001 GMac, 10.456% MACs|\n        (conv1): Conv1d(64, 64, kernel_size=(3,), stride=(1,), padding=(1,), |0.012 M, 3.538% Params, 0.001 GMac, 5.148% MACs|)\n        (bn1): BatchNorm1d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True, |0.0 M, 0.037% Params, 0.0 GMac, 0.053% MACs|)\n        (conv2): Conv1d(64, 64, kernel_size=(3,), stride=(1,), padding=(1,), |0.012 M, 3.538% Params, 0.001 GMac, 5.148% MACs|)\n        (bn2): BatchNorm1d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True, |0.0 M, 0.037% Params, 0.0 GMac, 0.053% MACs|)\n        (relu): ReLU(|0.0 M, 0.000% Params, 0.0 GMac, 0.053% MACs|)\n      )\n    )\n    (resnet_unit_2): Sequential(\n      |0.182 M, 52.057% Params, 0.005 GMac, 37.982% MACs|\n      (0): ResNetUnit(\n        |0.083 M, 23.682% Params, 0.002 GMac, 17.284% MACs|\n        (conv1): Conv1d(64, 128, kernel_size=(3,), stride=(2,), padding=(1,), |0.025 M, 7.075% Params, 0.001 GMac, 5.148% MACs|)\n        (bn1): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True, |0.0 M, 0.073% Params, 0.0 GMac, 0.053% MACs|)\n        (conv2): Conv1d(128, 128, kernel_size=(3,), stride=(1,), padding=(1,), |0.049 M, 14.114% Params, 0.001 GMac, 10.269% MACs|)\n        (bn2): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True, |0.0 M, 0.073% Params, 0.0 GMac, 0.053% MACs|)\n        (relu): ReLU(|0.0 M, 0.000% Params, 0.0 GMac, 0.053% MACs|)\n        (conv_sc): Conv1d(64, 128, kernel_size=(1,), stride=(2,), bias=False, |0.008 M, 2.346% Params, 0.0 GMac, 1.707% MACs|)\n      )\n      (1): ResNetUnit(\n        |0.099 M, 28.375% Params, 0.002 GMac, 20.698% MACs|\n        (conv1): Conv1d(128, 128, kernel_size=(3,), stride=(1,), padding=(1,), |0.049 M, 14.114% Params, 0.001 GMac, 10.269% MACs|)\n        (bn1): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True, |0.0 M, 0.073% Params, 0.0 GMac, 0.053% MACs|)\n        (conv2): Conv1d(128, 128, kernel_size=(3,), stride=(1,), padding=(1,), |0.049 M, 14.114% Params, 0.001 GMac, 10.269% MACs|)\n        (bn2): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True, |0.0 M, 0.073% Params, 0.0 GMac, 0.053% MACs|)\n        (relu): ReLU(|0.0 M, 0.000% Params, 0.0 GMac, 0.053% MACs|)\n      )\n    )\n  )\n  (fc): Sequential(\n    |0.067 M, 19.210% Params, 0.0 GMac, 0.563% MACs|\n    (0): Sequential(\n      |0.066 M, 18.917% Params, 0.0 GMac, 0.555% MACs|\n      (0): Linear(in_features=128, out_features=512, bias=True, |0.066 M, 18.917% Params, 0.0 GMac, 0.551% MACs|)\n      (1): ReLU(|0.0 M, 0.000% Params, 0.0 GMac, 0.004% MACs|)\n      (2): Dropout(p=0.2, inplace=False, |0.0 M, 0.000% Params, 0.0 GMac, 0.000% MACs|)\n    )\n    (1): Linear(in_features=512, out_features=2, bias=True, |0.001 M, 0.294% Params, 0.0 GMac, 0.009% MACs|)\n  )\n)\n</code></pre> <p>The data card is the same as the MLP case, shown in <code>top_tagging/data/pf_features.yaml</code>.</p> <p> The full architecture of the ParticleNet model, which is based on DGCNN and EdgeConv. </p> <p>Note</p> <p>The ParticleNet model applied to the CMS analysis is provided in <code>weaver/networks/particle_net_pf_sv.py</code>, and the data card in <code>weaver/data/ak15_points_pf_sv.yaml</code>. Here we use a similar configuration card to deal with the benchmark task.</p> <p>We will elaborate on the ParticleNet model and focus more on the technical side in this section. The model is defined in <code>top_tagging/networks/particlenet_pf.py</code>, but it imports some constructor, the EdgeConv block, in <code>weaver/utils/nn/model/ParticleNet.py</code>. The EdgeConv is illustrated in the cartoon.</p> <p> Illustration of the EdgeConv block </p> <p>From an EdgeConv block's point of view, it requires two classes of features as input: the \"coordinates\" and the \"features\". These features are the per point properties, in the 2D shape with dimensions <code>(C, P)</code>, where <code>C</code> is the size of the features (the feature size of \"coordinates\" and the \"features\" can be different, marked as <code>C_pts</code>, <code>C_fts</code> in the following code), and P is the number of points. The block outputs the new features that the model learns, also in the 2D shape with dimensions <code>(C_fts_out, P)</code>.</p> <p>What happens inside the EdgeConv block? And how is the output feature vector transferred from the input features using the topology of the point cloud? The answer is encoded in the edge convolution (EdgeConv).</p> <p></p> <p>The edge convolution is an analogue convolution method defined on a point cloud, whose shape is given by the \"coordinates\" of points. Specifically, the input \"coordinates\" provide a view of spatial relations of the points in the Euclidean space. It determines the k-nearest neighbouring points for each point that will guide the update of the feature vector of a point. For each point, the updated feature vector is based on the current state of the point and its k neighbours. Guided by this spirit, all features of the point cloud forms a 3D vector with dimensions <code>(C, P, K)</code>, where <code>C</code> is the per-point feature size (e.g., \u03b7, \u03c6, p<sub>T</sub>\uff0c...), <code>P</code> is the number of points, and K the k-NN number. The structured vector is linearly transformed by acting 2D CNN on the feature dimension <code>C</code>. This helps to aggregate the feature information and exploit the correlations of each point with its adjacent points. A shortcut connection is also introduced inspired by the ResNet.</p> <p>Note</p> <p>The feature dimension <code>C</code> after exploring the k neighbours of each point actually doubles the value of the initial feature dimension. Here, a new set of features is constructed by subtracting the feature a point carries to the features its k neighbours carry (namely x<sub>i</sub> \u2013 x<sub>i_j</sub> for point i, and j=1,...,k). This way, the correlation of each point with its neighbours are well captured.</p> <p>Below shows how the EdgeConv structure is implemented in the code.</p> EdgeConv block implementation <p>See <code>weaver/utils/nn/model/ParticleNet.py</code>, or the following code block annotated with more comments. We elaborate here on several aspects.</p> <ul> <li>The <code>EdgeConvBlock</code> takes the feature dimension <code>in_feat</code>, <code>out_feats</code> which are <code>C_fts</code>, <code>C_fts_out</code> we introduced above.</li> <li>The input data vectors to <code>forward()</code> are \"coordinates\" and \"features\" vector, in the dimension of <code>(N, C_pts(C_fts), P)</code> as introduced above. The first dimension is the mini-batch size.</li> <li><code>self.get_graph_feature()</code> helps to aggregate k-nearest neighbours for each point. The resulting vector is in the dimension of <code>(N, C_fts(0), P, K)</code> as we discussed above, <code>K</code> being the k-NN number. Note that the <code>C_fts(0)</code> doubles the value of the original input feature dimension <code>C_fts</code> as mentioned above.</li> <li>After convolutions, the per-point features are merged by taking the mean of all k-nearest neighbouring vectors:   <pre><code>fts = x.mean(dim=-1)  # (N, C, P)\n</code></pre></li> </ul> <pre><code>class EdgeConvBlock(nn.Module):\n    r\"\"\"EdgeConv layer.\n    Introduced in \"`Dynamic Graph CNN for Learning on Point Clouds\n    &lt;https://arxiv.org/pdf/1801.07829&gt;`__\".  Can be described as follows:\n    .. math::\n    x_i^{(l+1)} = \\max_{j \\in \\mathcal{N}(i)} \\mathrm{ReLU}(\n    \\Theta \\cdot (x_j^{(l)} - x_i^{(l)}) + \\Phi \\cdot x_i^{(l)})\n    where :math:`\\mathcal{N}(i)` is the neighbor of :math:`i`.\n    Parameters\n    ----------\n    in_feat : int\n        Input feature size.\n    out_feat : int\n        Output feature size.\n    batch_norm : bool\n        Whether to include batch normalization on messages.\n    \"\"\"\n\n    def __init__(self, k, in_feat, out_feats, batch_norm=True, activation=True, cpu_mode=False):\n        super(EdgeConvBlock, self).__init__()\n        self.k = k\n        self.batch_norm = batch_norm\n        self.activation = activation\n        self.num_layers = len(out_feats)\n        self.get_graph_feature = get_graph_feature_v2 if cpu_mode else get_graph_feature_v1\n\n        self.convs = nn.ModuleList()\n        for i in range(self.num_layers):\n            self.convs.append(nn.Conv2d(2 * in_feat if i == 0 else out_feats[i - 1], out_feats[i], kernel_size=1, bias=False if self.batch_norm else True))\n\n        if batch_norm:\n            self.bns = nn.ModuleList()\n            for i in range(self.num_layers):\n                self.bns.append(nn.BatchNorm2d(out_feats[i]))\n\n        if activation:\n            self.acts = nn.ModuleList()\n            for i in range(self.num_layers):\n                self.acts.append(nn.ReLU())\n\n        if in_feat == out_feats[-1]:\n            self.sc = None\n        else:\n            self.sc = nn.Conv1d(in_feat, out_feats[-1], kernel_size=1, bias=False)\n            self.sc_bn = nn.BatchNorm1d(out_feats[-1])\n\n        if activation:\n            self.sc_act = nn.ReLU()\n\n    def forward(self, points, features):\n        # points:   (N, C_pts, P)\n        # features: (N, C_fts, P)\n        # N: batch size, C: feature size per point, P: number of points\n\n        topk_indices = knn(points, self.k) # (N, P, K)\n        x = self.get_graph_feature(features, self.k, topk_indices) # (N, C_fts(0), P, K)\n\n        for conv, bn, act in zip(self.convs, self.bns, self.acts):\n            x = conv(x)  # (N, C', P, K)\n            if bn:\n                x = bn(x)\n            if act:\n                x = act(x)\n\n        fts = x.mean(dim=-1)  # (N, C, P)\n\n        # shortcut\n        if self.sc:\n            sc = self.sc(features)  # (N, C_out, P)\n            sc = self.sc_bn(sc)\n        else:\n            sc = features\n\n        return self.sc_act(sc + fts)  # (N, C_out, P)\n</code></pre> <p>With the EdgeConv architecture as the building block, the ParticleNet model is constructed as follow.</p> <p></p> <p>The ParticleNet model stacks three EdgeConv blocks to construct higher-level features and passing them through the pipeline. The points (i.e., in our case, the particle candidates inside a jet) are not changing, but the per-point \"coordinates\" and \"features\" vectors changes, in both values and dimensions.</p> <p>For the first EdgeConv block, the \"coordinates\" only include the relative \u03b7 and \u03c6 value of each particle. The \"features\" is a vector with a standard length of 32, which is linearly transformed from the initial feature vectors including the components of relative \u03b7, \u03c6, the log of p<sub>T</sub>, etc. The first EdgeConv block outputs a per-point feature vector of length 64, which is taken as both the \"coordinates\" and \"features\" to the next EdgeConv block. That is to say, the next k-NN is applied on the 64D high-dimensional spatial space to capture the new relations of points learned by the model. This is visualized by the input/output arrows showing the data flow of the model. We see that this architecture illustrates the stackability of the EdgeConv block, and is the core to the Dynamic Graph CNN (DGCNN), as the model can dynamically change the correlations of each point based on learnable features.</p> <p>A fusion technique is also used by concatenating the three EdgeConv output vectors together (adding the dimensions), instead of using the last EdgeConv output, to form an output vector. This is also one form of shortcut implementations that helps to ease the training for a complex and deep convolutional network model.</p> <p>The concatenated vectors per point are then averaged over points to produce a single 1D vector of the whole point cloud. The vector passes through one fully connected layer, with a dropout rate of p=0.1 to prevent overfitting. Then, in our example, the full network outputs two scores after a softmax, representing the one-hot encoding of the top vs. QCD class.</p> <p>The ParticleNet implementation is shown below.</p> ParticleNet model implementation <p>See <code>weaver/utils/nn/model/ParticleNet.py</code>, or the following code block annotated with more comments. We elaborate here on several mean points.</p> <ul> <li>The stack of multiple EdgeConv blocks are implemented in     <pre><code>for idx, conv in enumerate(self.edge_convs):\n    pts = (points if idx == 0 else fts) + coord_shift\n    fts = conv(pts, fts) * mask\n</code></pre></li> <li>The multiple EdgeConv layer parameters are given by <code>conv_params</code>, which takes a list of tuples, each tuple in the format of <code>(K, (C1, C2, C3))</code>. <code>K</code> for the k-NN number, <code>C1,2,3</code> for convolution feature sizes of three layers in an EdgeConv block.</li> <li>The fully connected layer parameters are given by <code>fc_params</code>, which takes a list of tuples, each tuple in the format of <code>(n_feat, drop_rate)</code>.</li> </ul> <pre><code>class ParticleNet(nn.Module):\n    r\"\"\"Parameters\n    ----------\n    input_dims : int\n        Input feature dimensions (C_fts).\n    num_classes : int\n        Number of output classes.\n    conv_params : list\n        List of convolution parameters of EdgeConv blocks, each element in the format of (K, (C1, C2, C3)).\n        K for the kNN number, C1,2,3 for convolution feature sizes of three layers in an EdgeConv block.\n    fc_params: list\n        List of fully connected layer parameters after all EdgeConv blocks, each element in the format of\n        (n_feat, drop_rate)\n    use_fusion: bool\n        If true, concatenates all output features from each EdgeConv before the fully connected layer.\n    use_fts_bn: bool\n        If true, applies a batch norm before feeding to the EdgeConv block.\n    use_counts: bool\n        If true, uses the real count of points instead of the padded size (the max point size).\n    for_inference: bool\n        Whether this is an inference routine. If true, applies a softmax to the output.\n    for_segmentation: bool\n        Whether the model is set up for the point cloud segmentation (instead of classification) task. If true,\n        does not merge the features after the last EdgeConv, and apply Conv1D instead of the linear layer.\n        The output is hence each output_features per point, instead of output_features.\n    \"\"\"\n\n\n    def __init__(self,\n                input_dims,\n                num_classes,\n                conv_params=[(7, (32, 32, 32)), (7, (64, 64, 64))],\n                fc_params=[(128, 0.1)],\n                use_fusion=True,\n                use_fts_bn=True,\n                use_counts=True,\n                for_inference=False,\n                for_segmentation=False,\n                **kwargs):\n        super(ParticleNet, self).__init__(**kwargs)\n\n        self.use_fts_bn = use_fts_bn\n        if self.use_fts_bn:\n            self.bn_fts = nn.BatchNorm1d(input_dims)\n\n        self.use_counts = use_counts\n\n        self.edge_convs = nn.ModuleList()\n        for idx, layer_param in enumerate(conv_params):\n            k, channels = layer_param\n            in_feat = input_dims if idx == 0 else conv_params[idx - 1][1][-1]\n            self.edge_convs.append(EdgeConvBlock(k=k, in_feat=in_feat, out_feats=channels, cpu_mode=for_inference))\n\n        self.use_fusion = use_fusion\n        if self.use_fusion:\n            in_chn = sum(x[-1] for _, x in conv_params)\n            out_chn = np.clip((in_chn // 128) * 128, 128, 1024)\n            self.fusion_block = nn.Sequential(nn.Conv1d(in_chn, out_chn, kernel_size=1, bias=False), nn.BatchNorm1d(out_chn), nn.ReLU())\n\n        self.for_segmentation = for_segmentation\n\n        fcs = []\n        for idx, layer_param in enumerate(fc_params):\n            channels, drop_rate = layer_param\n            if idx == 0:\n                in_chn = out_chn if self.use_fusion else conv_params[-1][1][-1]\n            else:\n                in_chn = fc_params[idx - 1][0]\n            if self.for_segmentation:\n                fcs.append(nn.Sequential(nn.Conv1d(in_chn, channels, kernel_size=1, bias=False),\n                                        nn.BatchNorm1d(channels), nn.ReLU(), nn.Dropout(drop_rate)))\n            else:\n                fcs.append(nn.Sequential(nn.Linear(in_chn, channels), nn.ReLU(), nn.Dropout(drop_rate)))\n        if self.for_segmentation:\n            fcs.append(nn.Conv1d(fc_params[-1][0], num_classes, kernel_size=1))\n        else:\n            fcs.append(nn.Linear(fc_params[-1][0], num_classes))\n        self.fc = nn.Sequential(*fcs)\n\n        self.for_inference = for_inference\n\n    def forward(self, points, features, mask=None):\n#         print('points:\\n', points)\n#         print('features:\\n', features)\n        if mask is None:\n            mask = (features.abs().sum(dim=1, keepdim=True) != 0)  # (N, 1, P)\n        points *= mask\n        features *= mask\n        coord_shift = (mask == 0) * 1e9\n        if self.use_counts:\n            counts = mask.float().sum(dim=-1)\n            counts = torch.max(counts, torch.ones_like(counts))  # &gt;=1\n\n        if self.use_fts_bn:\n            fts = self.bn_fts(features) * mask\n        else:\n            fts = features\n        outputs = []\n        for idx, conv in enumerate(self.edge_convs):\n            pts = (points if idx == 0 else fts) + coord_shift\n            fts = conv(pts, fts) * mask\n            if self.use_fusion:\n                outputs.append(fts)\n        if self.use_fusion:\n            fts = self.fusion_block(torch.cat(outputs, dim=1)) * mask\n\n#         assert(((fts.abs().sum(dim=1, keepdim=True) != 0).float() - mask.float()).abs().sum().item() == 0)\n\n        if self.for_segmentation:\n            x = fts\n        else:\n            if self.use_counts:\n                x = fts.sum(dim=-1) / counts  # divide by the real counts\n            else:\n                x = fts.mean(dim=-1)\n\n        output = self.fc(x)\n        if self.for_inference:\n            output = torch.softmax(output, dim=1)\n        # print('output:\\n', output)\n        return output\n</code></pre> <p>Above are the capsulation of all ParticleNet building blocks. Eventually, we have the model defined in the model card <code>top_tagging/networks/particlenet_pf.py</code>, in the <code>ParticleNetTagger1Path</code> class, meaning we only use the ParticleNet pipeline that deals with one set of the point cloud (i.e., the particle candidates).</p> Info <p>Two sets of point clouds in the CMS application, namely the particle-flow candidates and secondary vertices, are used. This requires special handling to merge the clouds before feeding them to the first layer of EdgeConv.</p> ParticleNet model config <p>Also see <code>top_tagging/networks/particlenet_pf.py</code>. <pre><code>import torch\nimport torch.nn as nn\nfrom utils.nn.model.ParticleNet import ParticleNet, FeatureConv\n\n\nclass ParticleNetTagger1Path(nn.Module):\n\n    def __init__(self,\n                pf_features_dims,\n                num_classes,\n                conv_params=[(7, (32, 32, 32)), (7, (64, 64, 64))],\n                fc_params=[(128, 0.1)],\n                use_fusion=True,\n                use_fts_bn=True,\n                use_counts=True,\n                pf_input_dropout=None,\n                for_inference=False,\n                **kwargs):\n        super(ParticleNetTagger1Path, self).__init__(**kwargs)\n        self.pf_input_dropout = nn.Dropout(pf_input_dropout) if pf_input_dropout else None\n        self.pf_conv = FeatureConv(pf_features_dims, 32)\n        self.pn = ParticleNet(input_dims=32,\n                            num_classes=num_classes,\n                            conv_params=conv_params,\n                            fc_params=fc_params,\n                            use_fusion=use_fusion,\n                            use_fts_bn=use_fts_bn,\n                            use_counts=use_counts,\n                            for_inference=for_inference)\n\n    def forward(self, pf_points, pf_features, pf_mask):\n        if self.pf_input_dropout:\n            pf_mask = (self.pf_input_dropout(pf_mask) != 0).float()\n            pf_points *= pf_mask\n            pf_features *= pf_mask\n\n        return self.pn(pf_points, self.pf_conv(pf_features * pf_mask) * pf_mask, pf_mask)\n\n\ndef get_model(data_config, **kwargs):\n    conv_params = [\n        (16, (64, 64, 64)),\n        (16, (128, 128, 128)),\n        (16, (256, 256, 256)),\n        ]\n    fc_params = [(256, 0.1)]\n    use_fusion = True\n\n    pf_features_dims = len(data_config.input_dicts['pf_features'])\n    num_classes = len(data_config.label_value)\n    model = ParticleNetTagger1Path(pf_features_dims, num_classes,\n                            conv_params, fc_params,\n                            use_fusion=use_fusion,\n                            use_fts_bn=kwargs.get('use_fts_bn', False),\n                            use_counts=kwargs.get('use_counts', True),\n                            pf_input_dropout=kwargs.get('pf_input_dropout', None),\n                            for_inference=kwargs.get('for_inference', False)\n                            )\n    model_info = {\n        'input_names':list(data_config.input_names),\n        'input_shapes':{k:((1,) + s[1:]) for k, s in data_config.input_shapes.items()},\n        'output_names':['softmax'],\n        'dynamic_axes':{**{k:{0:'N', 2:'n_' + k.split('_')[0]} for k in data_config.input_names}, **{'softmax':{0:'N'}}},\n        }\n\n    print(model, model_info)\n    print(data_config.input_shapes)\n    return model, model_info\n\n\ndef get_loss(data_config, **kwargs):\n    return torch.nn.CrossEntropyLoss()\n</code></pre></p> <p>The most important parameters are <code>conv_params</code> and <code>fc_params</code>, which decides the model parameters of EdgeConv blocks and the fully connected layer. See details in the above \"ParticleNet model implementation\" box.</p> <pre><code>conv_params = [\n    (16, (64, 64, 64)),\n    (16, (128, 128, 128)),\n    (16, (256, 256, 256)),\n    ]\nfc_params = [(256, 0.1)]\n</code></pre> <p>A full structure printed from PyTorch is shown below. It will appear in the <code>Weaver</code> output during training.</p> ParticleNet full-scale structure <pre><code>ParticleNetTagger1Path(\n  |0.577 M, 100.000% Params, 0.441 GMac, 100.000% MACs|\n  (pf_conv): FeatureConv(\n    |0.0 M, 0.035% Params, 0.0 GMac, 0.005% MACs|\n    (conv): Sequential(\n      |0.0 M, 0.035% Params, 0.0 GMac, 0.005% MACs|\n      (0): BatchNorm1d(4, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True, |0.0 M, 0.001% Params, 0.0 GMac, 0.000% MACs|)\n      (1): Conv1d(4, 32, kernel_size=(1,), stride=(1,), bias=False, |0.0 M, 0.022% Params, 0.0 GMac, 0.003% MACs|)\n      (2): BatchNorm1d(32, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True, |0.0 M, 0.011% Params, 0.0 GMac, 0.001% MACs|)\n      (3): ReLU(|0.0 M, 0.000% Params, 0.0 GMac, 0.001% MACs|)\n    )\n  )\n  (pn): ParticleNet(\n    |0.577 M, 99.965% Params, 0.441 GMac, 99.995% MACs|\n    (edge_convs): ModuleList(\n      |0.305 M, 52.823% Params, 0.424 GMac, 96.047% MACs|\n      (0): EdgeConvBlock(\n        |0.015 M, 2.575% Params, 0.021 GMac, 4.716% MACs|\n        (convs): ModuleList(\n          |0.012 M, 2.131% Params, 0.02 GMac, 4.456% MACs|\n          (0): Conv2d(64, 64, kernel_size=(1, 1), stride=(1, 1), bias=False, |0.004 M, 0.710% Params, 0.007 GMac, 1.485% MACs|)\n          (1): Conv2d(64, 64, kernel_size=(1, 1), stride=(1, 1), bias=False, |0.004 M, 0.710% Params, 0.007 GMac, 1.485% MACs|)\n          (2): Conv2d(64, 64, kernel_size=(1, 1), stride=(1, 1), bias=False, |0.004 M, 0.710% Params, 0.007 GMac, 1.485% MACs|)\n        )\n        (bns): ModuleList(\n          |0.0 M, 0.067% Params, 0.001 GMac, 0.139% MACs|\n          (0): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True, |0.0 M, 0.022% Params, 0.0 GMac, 0.046% MACs|)\n          (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True, |0.0 M, 0.022% Params, 0.0 GMac, 0.046% MACs|)\n          (2): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True, |0.0 M, 0.022% Params, 0.0 GMac, 0.046% MACs|)\n        )\n        (acts): ModuleList(\n          |0.0 M, 0.000% Params, 0.0 GMac, 0.070% MACs|\n          (0): ReLU(|0.0 M, 0.000% Params, 0.0 GMac, 0.023% MACs|)\n          (1): ReLU(|0.0 M, 0.000% Params, 0.0 GMac, 0.023% MACs|)\n          (2): ReLU(|0.0 M, 0.000% Params, 0.0 GMac, 0.023% MACs|)\n        )\n        (sc): Conv1d(32, 64, kernel_size=(1,), stride=(1,), bias=False, |0.002 M, 0.355% Params, 0.0 GMac, 0.046% MACs|)\n        (sc_bn): BatchNorm1d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True, |0.0 M, 0.022% Params, 0.0 GMac, 0.003% MACs|)\n        (sc_act): ReLU(|0.0 M, 0.000% Params, 0.0 GMac, 0.001% MACs|)\n      )\n      (1): EdgeConvBlock(\n        |0.058 M, 10.121% Params, 0.081 GMac, 18.437% MACs|\n        (convs): ModuleList(\n          |0.049 M, 8.523% Params, 0.079 GMac, 17.825% MACs|\n          (0): Conv2d(128, 128, kernel_size=(1, 1), stride=(1, 1), bias=False, |0.016 M, 2.841% Params, 0.026 GMac, 5.942% MACs|)\n          (1): Conv2d(128, 128, kernel_size=(1, 1), stride=(1, 1), bias=False, |0.016 M, 2.841% Params, 0.026 GMac, 5.942% MACs|)\n          (2): Conv2d(128, 128, kernel_size=(1, 1), stride=(1, 1), bias=False, |0.016 M, 2.841% Params, 0.026 GMac, 5.942% MACs|)\n        )\n        (bns): ModuleList(\n          |0.001 M, 0.133% Params, 0.001 GMac, 0.279% MACs|\n          (0): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True, |0.0 M, 0.044% Params, 0.0 GMac, 0.093% MACs|)\n          (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True, |0.0 M, 0.044% Params, 0.0 GMac, 0.093% MACs|)\n          (2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True, |0.0 M, 0.044% Params, 0.0 GMac, 0.093% MACs|)\n        )\n        (acts): ModuleList(\n          |0.0 M, 0.000% Params, 0.001 GMac, 0.139% MACs|\n          (0): ReLU(|0.0 M, 0.000% Params, 0.0 GMac, 0.046% MACs|)\n          (1): ReLU(|0.0 M, 0.000% Params, 0.0 GMac, 0.046% MACs|)\n          (2): ReLU(|0.0 M, 0.000% Params, 0.0 GMac, 0.046% MACs|)\n        )\n        (sc): Conv1d(64, 128, kernel_size=(1,), stride=(1,), bias=False, |0.008 M, 1.420% Params, 0.001 GMac, 0.186% MACs|)\n        (sc_bn): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True, |0.0 M, 0.044% Params, 0.0 GMac, 0.006% MACs|)\n        (sc_act): ReLU(|0.0 M, 0.000% Params, 0.0 GMac, 0.003% MACs|)\n      )\n      (2): EdgeConvBlock(\n        |0.231 M, 40.128% Params, 0.322 GMac, 72.894% MACs|\n        (convs): ModuleList(\n          |0.197 M, 34.091% Params, 0.315 GMac, 71.299% MACs|\n          (0): Conv2d(256, 256, kernel_size=(1, 1), stride=(1, 1), bias=False, |0.066 M, 11.364% Params, 0.105 GMac, 23.766% MACs|)\n          (1): Conv2d(256, 256, kernel_size=(1, 1), stride=(1, 1), bias=False, |0.066 M, 11.364% Params, 0.105 GMac, 23.766% MACs|)\n          (2): Conv2d(256, 256, kernel_size=(1, 1), stride=(1, 1), bias=False, |0.066 M, 11.364% Params, 0.105 GMac, 23.766% MACs|)\n        )\n        (bns): ModuleList(\n          |0.002 M, 0.266% Params, 0.002 GMac, 0.557% MACs|\n          (0): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True, |0.001 M, 0.089% Params, 0.001 GMac, 0.186% MACs|)\n          (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True, |0.001 M, 0.089% Params, 0.001 GMac, 0.186% MACs|)\n          (2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True, |0.001 M, 0.089% Params, 0.001 GMac, 0.186% MACs|)\n        )\n        (acts): ModuleList(\n          |0.0 M, 0.000% Params, 0.001 GMac, 0.279% MACs|\n          (0): ReLU(|0.0 M, 0.000% Params, 0.0 GMac, 0.093% MACs|)\n          (1): ReLU(|0.0 M, 0.000% Params, 0.0 GMac, 0.093% MACs|)\n          (2): ReLU(|0.0 M, 0.000% Params, 0.0 GMac, 0.093% MACs|)\n        )\n        (sc): Conv1d(128, 256, kernel_size=(1,), stride=(1,), bias=False, |0.033 M, 5.682% Params, 0.003 GMac, 0.743% MACs|)\n        (sc_bn): BatchNorm1d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True, |0.001 M, 0.089% Params, 0.0 GMac, 0.012% MACs|)\n        (sc_act): ReLU(|0.0 M, 0.000% Params, 0.0 GMac, 0.006% MACs|)\n      )\n    )\n    (fusion_block): Sequential(\n      |0.173 M, 29.963% Params, 0.017 GMac, 3.925% MACs|\n      (0): Conv1d(448, 384, kernel_size=(1,), stride=(1,), bias=False, |0.172 M, 29.830% Params, 0.017 GMac, 3.899% MACs|)\n      (1): BatchNorm1d(384, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True, |0.001 M, 0.133% Params, 0.0 GMac, 0.017% MACs|)\n      (2): ReLU(|0.0 M, 0.000% Params, 0.0 GMac, 0.009% MACs|)\n    )\n    (fc): Sequential(\n      |0.099 M, 17.179% Params, 0.0 GMac, 0.023% MACs|\n      (0): Sequential(\n        |0.099 M, 17.090% Params, 0.0 GMac, 0.022% MACs|\n        (0): Linear(in_features=384, out_features=256, bias=True, |0.099 M, 17.090% Params, 0.0 GMac, 0.022% MACs|)\n        (1): ReLU(|0.0 M, 0.000% Params, 0.0 GMac, 0.000% MACs|)\n        (2): Dropout(p=0.1, inplace=False, |0.0 M, 0.000% Params, 0.0 GMac, 0.000% MACs|)\n      )\n      (1): Linear(in_features=256, out_features=2, bias=True, |0.001 M, 0.089% Params, 0.0 GMac, 0.000% MACs|)\n    )\n  )\n)\n</code></pre> <p>The data card is shown in <code>top_tagging/data/pf_points_features.yaml</code>, given in a similar way as in the MLP example. Here we group the inputs into three classes: <code>pf_points</code>, <code>pf_features</code> and <code>pf_masks</code>. They correspond to the <code>forward(self, pf_points, pf_features, pf_mask)</code> prototype of our <code>nn.Module</code> model, and will send in these 2D vectors in the mini-batch size for each iteration during training/prediction.</p> ParticleNet data config <code>top_tagging/data/pf_points_features.yaml</code> <p>See <code>top_tagging/data/pf_points_features.yaml</code>. <pre><code>selection:\n### use `&amp;`, `|`, `~` for logical operations on numpy arrays\n### can use functions from `math`, `np` (numpy), and `awkward` in the expression\n\nnew_variables:\n### [format] name: formula\n### can use functions from `math`, `np` (numpy), and `awkward` in the expression\npf_mask: awkward.JaggedArray.ones_like(Part_E)\nis_bkg: np.logical_not(is_signal_new)\n\npreprocess:\n### method: [manual, auto] - whether to use manually specified parameters for variable standardization\nmethod: manual\n### data_fraction: fraction of events to use when calculating the mean/scale for the standardization\ndata_fraction:\n\ninputs:\npf_points:\n    length: 100\n    vars:\n        - Part_Etarel\n        - Part_Phirel\npf_features:\n    length: 100\n    vars:\n    ### [format 1]: var_name (no transformation)\n    ### [format 2]: [var_name,\n    ###              subtract_by(optional, default=None, no transf. if preprocess.method=manual, auto transf. if preprocess.method=auto),\n    ###              multiply_by(optional, default=1),\n    ###              clip_min(optional, default=-5),\n    ###              clip_max(optional, default=5),\n    ###              pad_value(optional, default=0)]\n        - Part_Etarel\n        - Part_Phirel\n        - [Part_E_log, 2, 1]\n        - [Part_P_log, 2, 1]\npf_mask:\n    length: 100\n    vars:\n        - pf_mask\n\nlabels:\n### type can be `simple`, `custom`\n### [option 1] use `simple` for binary/multi-class classification, then `value` is a list of 0-1 labels\ntype: simple\nvalue: [\n    is_signal_new, is_bkg\n    ]\n### [option 2] otherwise use `custom` to define the label, then `value` is a map\n# type: custom\n# value:\n    # target_mass: np.where(fj_isQCD, fj_genjet_sdmass, fj_gen_mass)\n\nobservers:\n- origIdx\n- idx\n- Part_E_tot\n- Part_PX_tot\n- Part_PY_tot\n- Part_PZ_tot\n- Part_P_tot\n- Part_Eta_tot\n- Part_Phi_tot\n\n# weights:\n### [option 1] use precomputed weights stored in the input files\n# use_precomputed_weights: true\n# weight_branches: [weight, class_weight]\n### [option 2] compute weights on-the-fly using reweighting histograms\n</code></pre></p> <p>Now we have walked through the detailed description of three networks in their architecture as well as their implementations in <code>Weaver</code>.</p> <p>Before ending this section, we summarize the three networks on their (1) model and data configuration cards, (2) the number of parameters, and (3) computational complexity in the following table. Note that we'll refer to the shell variables provided here in the following training example.</p> Model <code>${PREFIX}</code> <code>${MODEL_CONFIG}</code> <code>${DATA_CONFIG}</code> Parameters Computational complexity MLP <code>mlp</code> <code>mlp_pf.py</code> <code>pf_features.yaml</code> 739k 0.001 GMac DeepAK8 (1D CNN) <code>deepak8</code> <code>deepak8_pf.py</code> <code>pf_features.yaml</code> 349k 0.012 GMac ParticleNet (DGCNN) <code>particlenet</code> <code>particlenet_pf.py</code> <code>pf_points_features.yaml</code> 577k 0.441 GMac"},{"location":"inference/particlenet.html#2-start-training","title":"2. Start training!","text":"<p>Now we train the three neural networks based on the provided model and data configurations.</p> <p>Here we present three ways of training. For readers who have a local machine with CUDA GPUs, please try out training on the local GPUs. Readers who would like to try on CPUs can also refer to the local GPU instruction. It is also possible to borrow the GPU resources from the lxplus HTCondor or CMS Connect. Please find in the following that meets your situation.</p> Train on local GPUsUse GPUs on lxplus HTCondorUse GPUs on CMS Connect <p>The three networks can be trained with a universal script. Enter the <code>weaver</code> base folder and run the following command. Note that <code>${DATA_CONFIG}</code>, <code>${MODEL_CONFIG}</code>, and <code>${PREFIX}</code> refers to the value in the above table for each example, and the fake path should be replaced with the correct one.</p> <pre><code>PREFIX='&lt;prefix-from-table&gt;'\nMODEL_CONFIG='&lt;model-config-from-table&gt;'\nDATA_CONFIG='&lt;data-config-from-table&gt;'\nPATH_TO_SAMPLES='&lt;your-path-to-samples&gt;'\n\npython train.py \\\n --data-train ${PATH_TO_SAMPLES}'/prep/top_train_*.root' \\\n --data-val ${PATH_TO_SAMPLES}'/prep/top_val_*.root' \\\n --fetch-by-file --fetch-step 1 --num-workers 3 \\\n --data-config top_tagging/data/${DATA_CONFIG} \\\n --network-config top_tagging/networks/${MODEL_CONFIG} \\\n --model-prefix output/${PREFIX} \\\n --gpus 0,1 --batch-size 1024 --start-lr 5e-3 --num-epochs 20 --optimizer ranger \\\n --log output/${PREFIX}.train.log\n</code></pre> <p>Here <code>--gpus 0,1</code> specifies the GPUs to run with the device ID 1 and 2. For training on CPUs, please use <code>--gpu ''</code>.</p> <p>A detailed description of the training command can be found in <code>Weaver</code> README. Below we will note a few more caveats about the data loading options, though the specific settings will depend on the specifics of the input data.</p> <p>Caveats on the data loading options</p> <p>Our goal in data loading is to guarantee that the data loaded in every mini-batch is evenly distributed with different labels, though they are not necessarily stored evenly in the file. Besides, we also need to ensure that the on-the-fly loading and preprocessing of data should be smooth and not be a bottleneck of the data delivering pipeline. The total amount of loaded data also needs to be controlled so as not to explode the entire memory. The following guidelines should be used to choose the best options for your use case:</p> <ul> <li>in the default case, data are loaded from every input file with a small proportion per fetch-step, provided by <code>--fetch-step</code> (default is 0.01). This adapts to the case when we have multiple classes of input, each class having multiple files (e.g., it adapts to the real CMS application because we may have multiple <code>nano_i.root</code> files for different input classes). The strategy gathered all pieces per fetch-step from all input files, shuffle them, and present the data we need in each regular mini-batch. One can also append <code>--num-workers n</code> with <code>n</code> being the number of paralleled workers to load the data.</li> <li><code>--fetch-step 1 --num-workers 1</code>. This strategy helps in the case we have few input files with data in different labels not evenly distributed. In the extreme case, we only have 1 file, with all data at the top being one class (signal) and data at the bottom being another class (background), or we have 2 or multiple files, each containing a specific class. In this option, <code>--fetch-step 1</code> guarantees the entire data in the file is loaded and participate in the shuffle. Therefore all classes are safely mixed before sending to the mini-batch. <code>--num-workers 1</code> means we only use one worker that takes care of all files to avoid inconsistent loading speeds of multiple workers (depending on CPUs). This strategy can further cooperate with <code>--in-memory</code> so that all data are put permanently in memory and will not be reloaded every epoch.  <code>--fetch-by-file</code> is the option we can use when all input files have a similar structure. See <code>Weaver</code> README:</li> </ul> <p>An alternative approach is the \"file-based\" strategy, which can be enabled with <code>--fetch-by-files</code>. This approach will instead read all events from every file for each step, and it will read <code>m</code> input files (<code>m</code> is set by <code>--fetch-step</code>) before mixing and shuffling the loaded events. This strategy is more suitable when each input file is already a mixture of all types of events (e.g., pre-processed with NNTools), otherwise it may lead to suboptimal training performance. However, a higher data loading speed can generally be achieved with this approach.</p> <p>Please note that you can test if all data classes are well mixed by printing the truth label in each mini-batch. Also, remember to test if data are loaded just-in-time by monitoring the GPU performance \u2014 if switching the data loading strategy helps improve the GPU efficiency, it means the previous data loader is the bottleneck in the pipeline to deliver and use the data.</p> <p>After training, we predict the score on the test datasets using the best model:</p> <pre><code>PREFIX='&lt;prefix-from-table&gt;'\nMODEL_CONFIG='&lt;model-config-from-table&gt;'\nDATA_CONFIG='&lt;data-config-from-table&gt;'\nPATH_TO_SAMPLES='&lt;your-path-to-samples&gt;'\n\npython train.py --predict \\\n --data-test ${PATH_TO_SAMPLES}'/prep/top_test_*.root' \\\n --num-workers 3 \\\n --data-config top_tagging/data/${DATA_CONFIG} \\\n --network-config top_tagging/networks/${MODEL_CONFIG} \\\n --model-prefix output/${PREFIX}_best_epoch_state.pt \\\n --gpus 0,1 --batch-size 1024 \\\n --predict-output output/${PREFIX}_predict.root\n</code></pre> <p>On lxplus HTCondor, the GPU(s) can be booked via the arguments <code>request_gpus</code>. To get familiar with the GPU service, please refer to the documentation here.</p> <p>While it is not possible to test the script locally, you can try out the <code>condor_ssh_to_job</code> command to connect to the remote condor machine that runs the jobs. This interesting feature will help you with debugging or monitoring the condor job.</p> <p>Here we provide the example executed script and the condor submitted file for the training and predicting task. Create the following two files:</p> The executable: <code>run.sh</code> <p>Still, please remember to specify <code>${DATA_CONFIG}</code>, <code>${MODEL_CONFIG}</code>, and <code>${PREFIX}</code> as shown in the above table, and replace the fake path with the correct one. <pre><code>#!/bin/bash\n\nPREFIX=$1\nMODEL_CONFIG=$2\nDATA_CONFIG=$3\nPATH_TO_SAMPLES=$4\nWORKDIR=`pwd`\n\n# Download miniconda\nwget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh -O miniconda_install.sh\nbash miniconda_install.sh -b -p ${WORKDIR}/miniconda\nexport PATH=$WORKDIR/miniconda/bin:$PATH\npip install numpy pandas scikit-learn scipy matplotlib tqdm PyYAML\npip install uproot3 awkward0 lz4 xxhash\npip install tables\npip install onnxruntime-gpu\npip install tensorboard\npip install torch\n\n# CUDA environment setup\nexport PATH=$PATH:/usr/local/cuda-10.2/bin\nexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/cuda-10.2/lib64\nexport LIBRARY_PATH=$LIBRARY_PATH:/usr/local/cuda-10.2/lib64\n\n# Clone weaver-benchmark\ngit clone --recursive https://github.com/colizz/weaver-benchmark.git\nln -s ../top_tagging weaver-benchmark/weaver/top_tagging\ncd weaver-benchmark/weaver/\nmkdir output\n\n# Training, using 1 GPU\npython train.py \\\n --data-train ${PATH_TO_SAMPLES}'/prep/top_train_*.root' \\\n --data-val ${PATH_TO_SAMPLES}'/prep/top_val_*.root' \\\n --fetch-by-file --fetch-step 1 --num-workers 3 \\\n --data-config top_tagging/data/${DATA_CONFIG} \\\n --network-config top_tagging/networks/${MODEL_CONFIG} \\\n --model-prefix output/${PREFIX} \\\n --gpus 0 --batch-size 1024 --start-lr 5e-3 --num-epochs 20 --optimizer ranger \\\n --log output/${PREFIX}.train.log\n\n# Predicting score, using 1 GPU\npython train.py --predict \\\n --data-test ${PATH_TO_SAMPLES}'/prep/top_test_*.root' \\\n --num-workers 3 \\\n --data-config top_tagging/data/${DATA_CONFIG} \\\n --network-config top_tagging/networks/${MODEL_CONFIG} \\\n --model-prefix output/${PREFIX}_best_epoch_state.pt \\\n --gpus 0 --batch-size 1024 \\\n --predict-output output/${PREFIX}_predict.root\n\n[ -d \"runs/\" ] &amp;&amp; tar -caf output.tar output/ runs/ || tar -caf output.tar output/\n</code></pre></p> HTCondor submitted file: <code>submit.sub</code> <p>Modify the argument line. These are the bash variable <code>PREFIX</code>, <code>MODEL_CONFIG</code>, <code>DATA_CONFIG</code>, <code>PATH_TO_SAMPLES</code> used in the <code>Weaver</code> command. Since the EOS directory is accessable accross all condor nodes on lxplus, one may directly specify <code>&lt;your-path-to-samples&gt;</code> as the EOS path provided above. An example is shown in the commented line. <pre><code>Universe                = vanilla\nexecutable              = run.sh\narguments               = &lt;prefix&gt; &lt;model-config&gt; &lt;data-config&gt; &lt;your-path-to-samples&gt;\n#arguments              = mlp mlp_pf.py pf_features.yaml /eos/user/c/coli/public/weaver-benchmark/top_tagging/samples\noutput                  = job.$(ClusterId).$(ProcId).out\nerror                   = job.$(ClusterId).$(ProcId).err\nlog                     = job.$(ClusterId).log\nshould_transfer_files   = YES\nwhen_to_transfer_output = ON_EXIT_OR_EVICT\ntransfer_output_files   = weaver-benchmark/weaver/output.tar\ntransfer_output_remaps  = \"output.tar = output.$(ClusterId).$(ProcId).tar\"\nrequest_GPUs = 1\nrequest_CPUs = 4\n+MaxRuntime = 604800\nqueue\n</code></pre></p> <p>Make the <code>run.sh</code> script an executable, then submit the job. <pre><code>chmod +x run.sh\ncondor_submit submit.sub\n</code></pre> A tarball will be transfered back with the <code>weaver/output</code> directory where the trained models and the predicted ROOT file are stored.</p> <p>CMS Connect provides several GPU nodes. One can request to run GPU condor jobs in a similar way as on lxplus, please refer to the link: https://ci-connect.atlassian.net/wiki/spaces/CMS/pages/80117822/Requesting+GPUs</p> <p>As the EOS user space may not be accessed from the remote node launched by CMS Connect, one may consider either (1) migrating the input files by condor, or (2) using XRootD to transfer the input file from EOS space to the condor node, before running the <code>Weaver</code> train command.</p>"},{"location":"inference/particlenet.html#3-evaluation-of-models","title":"3. Evaluation of models","text":"<p>In the <code>output</code> folder, we find the trained PyTorch models after every epoch and the log file that records the loss and accuracy in the runtime.</p> <p>The predict step also produces a predicted root file in the <code>output</code> folder, including the truth label, the predicted store, and several observer variables we provided in the data card. With the predicted root file, we make the ROC curve comparing the performance of the three trained models.</p> <p></p> <p>Here is the result from my training:</p> Model AUC Accuracy 1/e<sub>B</sub> (@e<sub>S</sub>=0.3) MLP 0.961 0.898 186 DeepAK8 (1D CNN) 0.979 0.927 585 ParticleNet (DGCNN) 0.984 0.936 1030 <p>We see that the ParticleNet model shows an outstanding performance in this classification task. Besides, the DeepAK8 and ParticleNet results are similar to the benchmark values found in the gDoc. We address that the performance can be further improved by some following tricks:</p> <ul> <li>Train an ensemble of models with different initial parametrization. For each event/jet, take the final predicted score as the mean/median of the score ensembles predicted by each model. This is a widely used ML technique to pursue an extra few percent of improvements.</li> <li>Use more input variables for training. We note that in the above training example, only four input variables are used instead of a full suite of input features as done in the ParticleNet paper [arXiv:1902.08570]. Additional variables (e.g. \u0394R or log(p<sub>T</sub> / p<sub>T</sub>(jet))) can be designed based on the given 4-momenta, and, although providing redundant information in principle, can still help the network fully exploit the point cloud structure and thus do a better discrimination job.</li> <li>The fine-tuning of the model will also bring some performance gain. See details in the next section.</li> </ul>"},{"location":"inference/particlenet.html#tuning-the-particlenet-model","title":"Tuning the ParticleNet model","text":"<p>When it comes to the real application of any DNN model, tunning the hyperparameters is an important path towards a better performance. In this section, we provide some tips on the ParticleNet model tunning. For a more detailed discussion on this topic, see more in the \"validation\" chapter in the documentation.</p>"},{"location":"inference/particlenet.html#1-choices-on-the-optimizer-and-the-learning-rate","title":"1. Choices on the optimizer and the learning rate","text":"<p>The optimizer decides how our neural network update all its parameters, and the learning rate means how fast the parameters changes in one training iteration.</p> <p>Learning rate is the most important hyperparameter to choose from before concrete training is done. Here we quote from a suggested strategy: if you only have the opportunity to optimize one hyperparameter, choose the learning rate. The optimizer is also important because a wiser strategy usually means avoid the zig-zagging updating route, avoid falling into the local minima and even adapting different strategies for the fast-changing parameters and the slow ones. Adam (and its several variations) is a widely used optimizer. Another recently developed advanced optimizer is Ranger that combines RAdam and LookAhead. However, one should note that the few percent level improvement by using different optimizers is likely to be smeared by an unoptimized learning rate.</p> <p>The above training scheme uses a start learning rate of 5e-3, and Ranger as the optimizer. It uses a <code>flat+decay</code> schedular, in a way that the LR starts to decay after processing 70% of epochs, and gradually reduce to 0.01 of its original value when nearing the completion of all epochs.</p> <p>First, we note that the current case is already well optimized. Therefore, by simply reuse the current choice, the training will converge to a stable result in general. But it is always good in practice to test several choices of the optimizer and reoptimize the learning rate.</p> <p><code>Weaver</code> integrates multiple optimizers. In the above training command, we use <code>--optimizer ranger</code> to adopt the Ranger optimizer. It is also possible to switch to <code>--optimizer adam</code> or <code>--optimizer adamW</code>.</p> <p><code>Weaver</code> also provides the interface to optimize the learning rate before real training is performed. In the ParticleNet model training, we append <pre><code>--lr-finder 5e-6,5e0,200\n</code></pre> in the command, then a specific learning-rate finder program will be launched. This setup scans over the LR from 5e-6 to 5e0 by applying 200 mini-batches of training. It outputs a plot showing the training loss for different starting learning rates. In general, a lower training loss means a better choice of the learning rate parameter.</p> <p>Below shows the results from LR finder by specifying <code>--lr-finder 5e-6,5e0,200</code>, for the <code>--optimizer adamW</code> (left) and the <code>--optimizer ranger</code> (right) case.</p> <p></p> <p>The training loss forms a basin shape which indicates that the optimal learning rate falls somewhere in the middle. We extract two aspects from the plots. First, the basin covers a wide range, meaning that the LR finder only provides a rough estimation. But it is a good attempt to first run the LR finder to have an overall feeling. For the Ranger case (right figure), one can choose the range 1e-3 to 1e-2 and further determine the optminal learning rate by delivering the full training. Second, we should be aware that different optimizer takes different optimal LR values. As can be seen here, the AdamW in general requires a small LR than Ranger.</p>"},{"location":"inference/particlenet.html#2-visualize-the-training-with-tensorboard","title":"2. Visualize the training with TensorBoard","text":"<p>To monitor the full training/evaluation accuracy and the loss for each mini-batch, we can draw support from a nicely integrated utility, TensorBoard, to employ real-time monitoring. See the introduction page from PyTorch: https://pytorch.org/tutorials/recipes/recipes/tensorboard_with_pytorch.html</p> <p>To activate TensorBoard, append (note that replace <code>${PREFIX}</code> according to the above table) <pre><code>--tensorboard ${PREFIX}\n</code></pre> to the training command. The <code>runs/</code> subfolder containing the TensorBoard monitoring log will appear in the Weaver directory (if you are launching condor jobs, the <code>runs/</code> folder will be transferred back in the tarball). Then, one can run <pre><code>tensorboard --logdir=runs\n</code></pre> to start the TensorBoard service and go to URL <code>https://localhost:6006</code> to view the TensorBoard dashboard.</p> <p>The below plots show the training and evaluation loss, in our standard choice with LR being 5e-3, and in the case of a small LR 2e-3 and a large LR 1e-2. Note that all tested LR values are within the basin in the LR finder plots.</p> <p></p> <p>We see that in the evaluated loss plot, the standard LR outperforms two variational choices. The reason may be that a larger LR finds difficulty in converging to the global minima, while a smaller LR may not be adequate to reach the minima point in a journey of 20 epochs. Overall, we see 5e-3 as a good choice as the starting LR for the Ranger optimizer.</p>"},{"location":"inference/particlenet.html#3-optimize-the-model","title":"3. Optimize the model","text":"<p>In practice, tuning the model size is also an important task. By concept, a smaller model tends to have unsatisfactory performance due to the limited ability to learn many local features. As the model size goes up, the performance will climb to some extent, but may further decrease due to the network \"degradation\" (deeper models have difficulty learning features). Besides, a heavier model may also cause the overfitting issue. In practice, it also leads to larger inference time which is the main concern when coming to real applications.</p> <p>For the ParticleNet model case, we also test between a smaller and larger variation of the model size. Recall that the original model is defined by the following layer parameters. <pre><code>conv_params = [\n    (16, (64, 64, 64)),\n    (16, (128, 128, 128)),\n    (16, (256, 256, 256)),\n    ]\nfc_params = [(256, 0.1)]\n</code></pre> We can replace the code block with <pre><code>ec_k = kwargs.get('ec_k', 16)\nec_c1 = kwargs.get('ec_c1', 64)\nec_c2 = kwargs.get('ec_c2', 128)\nec_c3 = kwargs.get('ec_c3', 256)\nfc_c, fc_p = kwargs.get('fc_c', 256), kwargs.get('fc_p', 0.1)\nconv_params = [\n    (ec_k, (ec_c1, ec_c1, ec_c1)),\n    (ec_k, (ec_c2, ec_c2, ec_c2)),\n    (ec_k, (ec_c3, ec_c3, ec_c3)),\n    ]\nfc_params = [(fc_c, fc_p)]\n</code></pre> Then we have the ability to tune the model parameters from the command line. Append the extra arguments in the training command <pre><code>--network-option ec_k 32 --network-option ec_c1 128 --network-option ec_c2 192 --network-option ec_c3 256\n</code></pre> and the model parameters will take the new values as specified.</p> <p>We test over two cases, one with the above setting to enlarge the model, and another by using <pre><code>--network-option ec_c1 64 --network-option ec_c2 64 --network-option ec_c3 96\n</code></pre> to adopt a lite version.</p> <p>The Tensorboard monitoring plots in the training/evaluation loss is shown as follows.</p> <p></p> <p>We see that the \"heavy\" model reaches even smaller training loss, meaning that the model does not meet the degradation issue yet. However, the evaluation loss is not catching up with the training loss, showing some degree of overtraining in this scheme. From the evaluation result, we see no improvement by moving to a heavy model.</p>"},{"location":"inference/particlenet.html#4-apply-preselection-and-class-weights","title":"4. Apply preselection and class weights","text":"<p>In HEP applications, it is sometimes required to train a multi-class classifier. While it is simple to specify the input classes in the <code>label</code> section of the <code>Weaver</code> data config, it is sometimes ignored to set up the preselection and assign the suitable class weights for training. Using an unoptimized configuration, the trained model will not reach the best performance although no error message will result.</p> <p>Since our top tagging example is a binary classification problem, there is no specific need to configure the preselection and class weights. Below we summarize some experiences that may be applicable in reader's custom multi-class training task.</p> <p>The preselection should be chosen in a way that all remaining events passing the selection should fall into one and only one category. In other words, events with no labels attached should not be kept since it will confuse the training process.</p> <p>Class weights (the <code>class_weights</code> option under <code>weights</code> in the data config) control the relative importance of input sample categories for training. Implementation-wise, it changes the event probability in a specific category chosen as training input events. The class weight comes into effect when one trains a multi-class classifier. Take 3-class case (denoted as [A, B, C]) as an example, the <code>class_weights: [1, 1, 1]</code> gives equal weights to all categories. Retraining the input with <code>class_weights: [10, 1, 1]</code> may result in a better discriminating power for class A vs. B or A vs. C; while the power of B separating with C will be weakened. As a trade-off between separating A vs. C and B vs. C, the class weights need to be intentionally tuned to achieve reasonable performance.</p> <p>After the class weights are tuned, one can use another method to further factor out the interplay across categories, i.e., to define a \"binarized\" score between two classes only. Suppose the raw score for the three classes are P(A), P(B), and P(C) (their sum should be 1), then one can define the discriminant P(BvsC) = P(B) / (P(B)+P(C)) to separate B vs. C. In this way, the saparating power of B vs. C will remain unchanged for <code>class_weights</code> configured as either <code>[1, 1, 1]</code> or <code>[10, 1, 1]</code>. This strategy has been widely used in CMS to define composite tagger discrimant which are applied analysis-wise.</p> <p>Above, we discuss in a very detailed manner on various attempts we can make to optimize the model. We hope the practical experiences presented here will help readers develop and deploy the complex ML model.</p>"},{"location":"inference/performance.html","title":"Performance of inference tools","text":""},{"location":"inference/pyg.html","title":"PyTorch Geometric","text":"<p>Geometric deep learning (GDL) is an emerging field focused on applying machine learning (ML) techniques to non-Euclidean domains such as graphs, point clouds, and manifolds. The PyTorch Geometric (PyG) library extends PyTorch to include GDL functionality, for example classes necessary to handle data with irregular structure. PyG is introduced at a high level in Fast Graph Representation Learning with PyTorch Geometric and in detail in the PyG docs. </p>"},{"location":"inference/pyg.html#gdl-with-pyg","title":"GDL with PyG","text":"<p>A complete reveiw of GDL is available in the following recently-published (and freely-available) textbook: Geometric Deep Learning: Grids, Groups, Graphs, Geodesics, and Gauges. The authors specify several key GDL architectures including convolutional neural networks (CNNs) operating on grids, Deep Sets architectures operating on sets, and graph neural networks (GNNs) operating on graphs, collections of nodes connected by edges. PyG is focused in particular on graph-structured data, which naturally encompases set-structured data. In fact, many state-of-the-art GNN architectures are implemented in PyG (see the docs)! A review of the landscape of GNN architectures is available in Graph Neural Networks: A Review of Methods and Applications. </p>"},{"location":"inference/pyg.html#the-data-class-pyg-graphs","title":"The Data Class: PyG Graphs","text":"<p>Graphs are data structures designed to encode data structured as a set of objects and relations. Objects are embedded as graph nodes \\(u\\in\\mathcal{V}\\), where \\(\\mathcal{V}\\) is the node set. Relations are represented by edges \\((i,j)\\in\\mathcal{E}\\) between nodes, where \\(\\mathcal{E}\\) is the edge set. Denote the sizes of the node and edge sets as \\(|\\mathcal{V}|=n_\\mathrm{nodes}\\) and \\(|\\mathcal{E}|=n_\\mathrm{edges}\\) respectively. The choice of edge connectivity determines the local structure of a graph, which has important downstream effects on graph-based learning algorithms. Graph construction is the process of embedding input data onto a graph structure. Graph-based learning algorithms are correspondingly imbued with a relational inductive bias based on the choice of graph representation; a graph's edge connectivity defines its local structure. The simplest graph construction routine is to construct no edges, yielding a permutation invariant set of objects. On the other hand, fully-connected graphs connect every node-node pair with an edge, yielding \\(n_\\mathrm{edges}=n_\\mathrm{nodes}(n_\\mathrm{nodes}-1)/2\\) edges. This representation may be feasible for small inputs like particle clouds corresponding to a jet, but is intractible for large-scale applications such as high-pileup tracking datasets. Notably, dynamic graph construction techniques operate on input point clouds, constructing edges on them dynamically during inference. For example, EdgeConv and GravNet GNN layers dynamically construct edges between nodes projected into a latent space; multiple such layers may be applied in sequence, yielding many intermediate graph representations on an input point cloud.</p> <p>In general, nodes can have positions \\(\\{p_i\\}_{i=1}^{n_\\mathrm{nodes}}\\), \\(p_i\\in\\mathbb{R}^{n_\\mathrm{space\\_dim}}\\), and features (attributes) \\(\\{x_i\\}_{i=1}^{n_\\mathrm{nodes}}\\), \\(x_i\\in\\mathbb{R}^{n_\\mathrm{node\\_dim}}\\). In some applications like GNN-based particle tracking, node positions are taken to be the features. In others, e.g. jet identification, positional information may be used to seed dynamic graph consturction while kinematic features are propagated as edge features. Edges, too, can have features \\(\\{e_{ij}\\}_{(i,j)\\in\\mathcal{E}}\\), \\(e_{ij}\\in\\mathbb{R}^{n_\\mathrm{edge\\_dim}}\\), but do not have positions; instead, edges are defined by the nodes they connect, and may therefore be represented by, for example, the distance between the respective node-node pair. In PyG, graphs are stored as instances of the <code>data</code> class, whose fields fully specify the graph:</p> <ul> <li><code>data.x</code>: node feature matrix, \\(X\\in\\mathbb{R}^{n_\\mathrm{nodes}\\times n_\\mathrm{node\\_dim}}\\)</li> <li><code>data.edge_index</code>: node indices at each end of each edge, \\(I\\in\\mathbb{R}^{2\\times n_\\mathrm{edges}}\\) </li> <li><code>data.edge_attr</code>: edge feature matrix, \\(E\\in\\mathbb{R}^{n_\\mathrm{edges}\\times n_\\mathrm{edge\\_dim}}\\) </li> <li><code>data.y</code>: training target with arbitary shape (\\(y\\in\\mathbb{R}^{n_\\mathrm{nodes}\\times n_\\mathrm{out}}\\) for node-level targets, \\(y\\in\\mathbb{R}^{n_\\mathrm{edges}\\times n_\\mathrm{out}}\\) for edge-level targets or \\(y\\in\\mathbb{R}^{1\\times n_\\mathrm{out}}\\) for node-level targets). </li> <li><code>data.pos</code>: Node position matrix, \\(P\\in\\mathbb{R}^{n_\\mathrm{nodes}\\times n_\\mathrm{space\\_dim}}\\)</li> </ul> <p>The PyG Introduction By Example tutorial covers the basics of graph creation, batching, transformation, and inference using this <code>data</code> class. </p> <p>As an example, consider the ZINC chemical compounds dataset, which available as a built-in dataset in PyG:</p> <p><pre><code>from torch_geometric.datasets import ZINC\ntrain_dataset = ZINC(root='/tmp/ZINC', subset=True, split='train')\ntest_dataset =  ZINC(root='/tmp/ZINC', subset=True, split='test')\nlen(train_dataset)\n&gt;&gt;&gt; 10000\nlen(test_dataset)\n&gt;&gt;&gt; 1000   \n</code></pre> Each graph in the dataset is a chemical compound; nodes are atoms and edges are chemical bonds. The node features <code>x</code> are categorical atom labels and the edge features <code>edge_attr</code> are categorical bond labels. The <code>edge_index</code> matrix lists all bonds present in the compound in COO format. The truth labels <code>y</code> indicate a synthetic computed property called constrained solubility; given a set of molecules represented as graphs, the task is to regress the constrained solubility. Therefore, this dataset is suitable for graph-level regression. Let's take a look at one molecule: </p> <pre><code>data = train_dataset[27]\ndata.x # node features\n&gt;&gt;&gt; tensor([[0], [0], [1], [2], [0], \n            [0], [2], [0], [1], [2],\n            [4], [0], [0], [0], [0],\n            [4], [0], [0], [0], [0]])\n\ndata.pos # node positions \n&gt;&gt;&gt; None\n\ndata.edge_index # COO edge indices\n&gt;&gt;&gt; tensor([[ 0,  1,  1,  1,  2,  3,  3,  4,  4,  \n              5,  5,  6,  6,  7,  7,  7,  8,  9, \n              9, 10, 10, 10, 11, 11, 12, 12, 13, \n              13, 14, 14, 15, 15, 15, 16, 16, 16,\n              16, 17, 18, 19], # node indices w/ outgoing edges\n            [ 1,  0,  2,  3,  1,  1,  4,  3,  5,  \n              4,  6,  5,  7,  6,  8,  9,  7,  7,\n              10,  9, 11, 15, 10, 12, 11, 13, 12, \n              14, 13, 15, 10, 14, 16, 15, 17, 18,\n              19, 16, 16, 16]]) # node indices w/ incoming edges\n\ndata.edge_attr # edge features\n&gt;&gt;&gt; tensor([1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, \n            1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1,\n            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \n            1, 1, 1, 1])\n\ndata.y # truth labels\n&gt;&gt;&gt; tensor([-0.0972])\n\ndata.num_nodes\n&gt;&gt;&gt; 20\n\ndata.num_edges\n&gt;&gt;&gt; 40\n\ndata.num_node_features\n&gt;&gt;&gt; 1 \n</code></pre> <p>We can load the full set of graphs onto an available GPU and create PyG dataloaders as follows: <pre><code>import torch\nfrom torch_geometric.data import DataLoader\n\ndevice = 'cuda:0' if torch.cuda.is_available() else 'cpu'\ntest_dataset = [d.to(device) for d in test_dataset]\ntrain_dataset = [d.to(device) for d in train_dataset]\ntest_loader = DataLoader(test_dataset, batch_size=1, shuffle=False)\ntrain_loader = DataLoader(train_dataset, batch_size=1, shuffle=True)\n</code></pre></p>"},{"location":"inference/pyg.html#the-message-passing-base-class-pyg-gnns","title":"The Message Passing Base Class: PyG GNNs","text":"<p>The 2017 paper Neural Message Passing for Quantum Chemistry presents a unified framework for a swath of GNN architectures known as message passing neural networks (MPNNs). MPNNs are GNNs whose feature updates are given by:</p> \\[x_i^{(k)} = \\gamma^{(k)} \\left(x_i^{(k-1)}, \\square_{j \\in \\mathcal{N}(i)} \\, \\phi^{(k)}\\left(x_i^{(k-1)}, x_j^{(k-1)},e_{ij}\\right) \\right)\\] <p>Here, \\(\\gamma\\) and \\(\\phi\\) are learnable functions (which we can approximate as multilayer perceptrons), \\(\\square\\) is a permutation-invariant function (e.g. mean, max, add), and \\(\\mathcal{N}(i)\\) is the neighborhood of node \\(i\\). In PyG, you'd write your own MPNN by using the <code>MessagePassing</code> base class, implementing each of the above mathematical objects as an explicit function. </p> <ul> <li><code>MessagePassing.message()</code> : define an explicit NN for \\(\\phi\\), use it to calculate \"messages\" between a node \\(x_i^{(k-1)}\\) and its neighbors \\(x_j^{(k-1)}\\), \\(j\\in\\mathcal{N}(i)\\), leveraging edge features \\(e_{ij}\\) if applicable</li> <li><code>MessagePassing.propagate()</code> : in this step, messages are calculated via the <code>message</code> function and aggregated across each receiving node; the keyword <code>aggr</code> (which can be <code>'add'</code>, <code>'max'</code>, or <code>'mean'</code>) is used to specify the specific permutation invariant function \\(\\square_{j\\in\\mathcal{N}(i)}\\) used for message aggregation. </li> <li><code>MessagePassing.update()</code> : the results of message passing are used to update the node features \\(x_i^{(k)}\\) through the \\(\\gamma\\) MLP </li> </ul> <p>The specific implementations of <code>message()</code>, <code>propagate()</code>, and <code>update()</code> are up to the user. A specific example is available in the PyG Creating Message Passing Networks tutorial</p>"},{"location":"inference/pyg.html#message-passing-with-zinc-data","title":"Message-Passing with ZINC Data","text":"<p>Returning to the ZINC molecular compound dataset, we can design a message-passing layer to aggregate messages across molecular graphs. Here, we'll define a multi-layer perceptron (MLP) class and use it to build a message passing layer (MPL) the following equation:</p> \\[x_i' = \\gamma \\left(x_i, \\frac{1}{|\\mathcal{N}(i)|}\\sum_{j \\in \\mathcal{N}(i)} \\, \\phi\\left([x_i, x_j, e_{j,i}\\right]) \\right)\\] <p>Here, the MLP dimensions are constrained. Since \\(x_i, e_{i,j}\\in\\mathbb{R}\\), the \\(\\phi\\) MLP must map \\(\\mathbb{R}^3\\) to \\(\\mathbb{R}^\\mathrm{message\\_size}\\). Similarly, \\(\\gamma\\) must map \\(\\mathbb{R}^{1+\\mathrm{\\mathrm{message\\_size}}}\\) to \\(\\mathbb{R}^\\mathrm{out}\\).  <pre><code>from torch_geometric.nn import MessagePassing\nimport torch.nn as nn\nfrom torch.nn import Sequential as Seq, Linear, ReLU\n\nclass MLP(nn.Module):\n    def __init__(self, input_size, output_size):\n        super(MLP, self).__init__()\n\n        self.layers = nn.Sequential(\n            nn.Linear(input_size, 16),\n            nn.ReLU(),\n            nn.Linear(16, 16),\n            nn.ReLU(),\n            nn.Linear(16, output_size),\n        )\n\n    def forward(self, x):\n        return self.layers(x)\n\nclass MPLayer(MessagePassing):\n    def __init__(self, n_node_feats, n_edge_feats, message_size, output_size):\n        super(MPLayer, self).__init__(aggr='mean', \n                                      flow='source_to_target')\n        self.phi = MLP(2*n_node_feats + n_edge_feats, message_size)\n        self.gamma = MLP(message_size + n_node_feats, output_size)\n\n    def forward(self, x, edge_index, edge_attr):\n        return self.propagate(edge_index, x=x, edge_attr=edge_attr)\n\n    def message(self, x_i, x_j, edge_attr):       \n        return self.phi(torch.cat([x_i, x_j, edge_attr], dim=1))\n\n    def update(self, aggr_out, x):\n        return self.gamma(torch.cat([x, aggr_out], dim=1))\n</code></pre></p> <p>Let's apply this layer to one of the ZINC molecules: <pre><code>molecule = train_dataset[0]\ntorch.Size([29, 1]) # 29 atoms and 1 feature (atom label)\nmpl = MPLayer(1, 1, 16, 8).to(device) # message_size = 16, output_size = 8\nxprime = mpl(graph.x.float(), graph.edge_index, graph.edge_attr.unsqueeze(1))\nxprime.shape\n&gt;&gt;&gt; torch.Size([29, 8]) # 29 atoms and 8 features\n</code></pre> There we have it - the message passing layer has produced 8 new features for each atom. </p>"},{"location":"inference/pytorch.html","title":"PyTorch Inference","text":"<p>PyTorch is an open source ML library developed by Facebook's AI Research lab. Initially released in late-2016, PyTorch is a relatively new tool, but has become increasingly popular among ML researchers (in fact, some analyses suggest it's becoming more popular than TensorFlow in academic communities!). PyTorch is written in idiomatic Python, so its syntax is easy to parse for experienced Python programmers. Additionally, it is highly compatible with graphics processing units (GPUs), which can substantially accelerate many deep learning workflows. To date PyTorch has not been integrated into CMSSW. Trained PyTorch models may be evaluated in CMSSW via ONNX Runtime, but model construction and training workflows must currently exist outside of CMSSW. Given the considerable interest in PyTorch within the HEP/ML community, we have reason to believe it will soon be available, so stay tuned! </p>"},{"location":"inference/pytorch.html#introductory-references","title":"Introductory References","text":"<ul> <li>PyTorch Install Guide</li> <li>PyTorch Tutorials</li> <li>LPC HATs: PyTorch</li> <li>Deep Learning w/ PyTorch Course Repo</li> <li>CODAS-HEP</li> </ul>"},{"location":"inference/pytorch.html#the-basics","title":"The Basics","text":"<p>The following documentation surrounds a set of code snippets designed to highlight some important ML features made available in PyTorch. In the following sections, we'll break down snippets from this script, highlighting specifically the PyTorch objects in it. </p>"},{"location":"inference/pytorch.html#tensors","title":"Tensors","text":"<p>The fundamental PyTorch object is the tensor. At a glance, tensors behave similarly to NumPy arrays. For example, they are broadcasted, concatenated, and sliced in exactly the same way. The following examples highlight some common numpy-like tensor transformations: <pre><code>a = torch.randn(size=(2,2))\n&gt;&gt;&gt; tensor([[ 1.3552, -0.0204],\n            [ 1.2677, -0.8926]])\na.view(-1, 1)\n&gt;&gt;&gt; tensor([[ 1.3552],\n            [-0.0204],\n            [ 1.2677],\n            [-0.8926]])\na.transpose(0, 1)\n&gt;&gt;&gt; tensor([[ 1.3552,  1.2677],\n            [-0.0204, -0.8926]])\na.unsqueeze(dim=0)\n&gt;&gt;&gt; tensor([[[ 1.3552, -0.0204],\n             [ 1.2677, -0.8926]]])\na.squeeze(dim=0)\n&gt;&gt;&gt; tensor([[ 1.3552, -0.0204],\n            [ 1.2677, -0.8926]])\n</code></pre> Additionally, torch supports familiar matrix operations with various syntax options:  <pre><code>m1 = torch.randn(size=(2,3))\nm2 = torch.randn(size=(3,2))\nx = torch.randn(3)\n\nm1 @ m2 == m1.mm(m2) # matrix multiplication\n&gt;&gt;&gt; tensor([[True, True],\n            [True, True]])\n\nm1 @ x == m1.mv(x) # matrix-vector multiplication\n&gt;&gt;&gt; tensor([True, True])\n\nm1.t() == m1.transpose(0, 1) # matrix transpose\n&gt;&gt;&gt; tensor([[True, True],\n            [True, True],\n            [True, True]])\n</code></pre> Note that <code>tensor.transpose(dim0, dim1)</code> is a more general operation than <code>tensor.t()</code>.  It is important to note that tensors have been ''upgraded'' from Numpy arrays in two key ways: 1) Tensors have native GPU support. If a GPU is available at runtime, tensors can be transferred from CPU to GPU, where computations such as matrix operations are substantially faster. Note that tensor operations must be performed on objects on the same device. PyTorch supports CUDA tensor types for GPU computation (see the PyTorch Cuda Semantics guide).  2) Tensors support automatic gradient (audograd) calculations, such that operations on tensors flagged with <code>requires_grad=True</code> are automatically tracked. The flow of tracked tensor operations defines a computation graph in which nodes are tensors and edges are functions mapping input tensors to output tensors. Gradients are calculated numerically via autograd by walking through this computation graph. </p>"},{"location":"inference/pytorch.html#gpu-support","title":"GPU Support","text":"<p>Tensors are created on the host CPU by default: <pre><code>b = torch.zeros([2,3], dtype=torch.int32)\nb.device\n&gt;&gt;&gt; cpu\n</code></pre></p> <p>You can also create tensors on any available GPUs: <pre><code>torch.cuda.is_available() # check that a GPU is available\n&gt;&gt;&gt; True \ncuda0 = torch.device('cuda:0')\nc = torch.ones([2,3], dtype=torch.int32, device=cuda0)\nc.device\n&gt;&gt;&gt; cuda:0\n</code></pre></p> <p>You can also move tensors between devices: <pre><code>b = b.to(cuda0)\nb.device\n&gt;&gt;&gt; cuda:0\n</code></pre></p> <p>There are trade-offs between computations on the CPU and GPU. GPUs have limited memory and there is a cost associated with transfering data from CPUs to GPUs. However, GPUs perform heavy matrix operations much faster than CPUs, and are therefore often used to speed up training routines.  </p> <pre><code>N = 1000 # \nfor i, N in enumerate([10, 100, 500, 1000, 5000]):\n    print(\"({},{}) Matrices:\".format(N,N))\n    M1_cpu = torch.randn(size=(N,N), device='cpu')\n    M2_cpu = torch.randn(size=(N,N), device='cpu')\n    M1_gpu = torch.randn(size=(N,N), device=cuda0)\n    M2_gpu = torch.randn(size=(N,N), device=cuda0)\n    if (i==0):\n        print('Check devices for each tensor:')\n        print('M1_cpu, M2_cpu devices:', M1_cpu.device, M2_cpu.device)\n        print('M1_gpu, M2_gpu devices:', M1_gpu.device, M2_gpu.device)\n\n    def large_matrix_multiply(M1, M2):\n        return M1 * M2.transpose(0,1)\n\n    n_iter = 1000\n    t_cpu = Timer(lambda: large_matrix_multiply(M1_cpu, M2_cpu))\n    cpu_time = t_cpu.timeit(number=n_iter)/n_iter\n    print('cpu time per call: {:.6f} s'.format(cpu_time))\n\n    t_gpu = Timer(lambda: large_matrix_multiply(M1_gpu, M2_gpu))\n    gpu_time = t_gpu.timeit(number=n_iter)/n_iter\n    print('gpu time per call: {:.6f} s'.format(gpu_time))\n    print('gpu_time/cpu_time: {:.6f}\\n'.format(gpu_time/cpu_time))\n\n&gt;&gt;&gt; (10,10) Matrices:\nCheck devices for each tensor:\nM1_cpu, M2_cpu devices: cpu cpu\nM1_gpu, M2_gpu devices: cuda:0 cuda:0\ncpu time per call: 0.000008 s\ngpu time per call: 0.000015 s\ngpu_time/cpu_time: 1.904711\n\n(100,100) Matrices:\ncpu time per call: 0.000015 s\ngpu time per call: 0.000015 s\ngpu_time/cpu_time: 0.993163\n\n(500,500) Matrices:\ncpu time per call: 0.000058 s\ngpu time per call: 0.000016 s\ngpu_time/cpu_time: 0.267371\n\n(1000,1000) Matrices:\ncpu time per call: 0.000170 s\ngpu time per call: 0.000015 s\ngpu_time/cpu_time: 0.089784\n\n(5000,5000) Matrices:\ncpu time per call: 0.025083 s\ngpu time per call: 0.000011 s\ngpu_time/cpu_time: 0.000419\n</code></pre> <p>The complete list of Torch Tensor operations is available in the docs. </p>"},{"location":"inference/pytorch.html#autograd","title":"Autograd","text":"<p>Backpropagation occurs automatically through autograd. For example, consider the following function and its derivatives:</p> \\[\\begin{aligned}  f(\\textbf{a}, \\textbf{b}) &amp;= \\textbf{a}^T \\textbf{X} \\textbf{b} \\\\  \\frac{\\partial f}{\\partial \\textbf{a}} &amp;= \\textbf{b}^T \\textbf{X}^T\\\\ \\frac{\\partial f}{\\partial \\textbf{b}} &amp;= \\textbf{a}^T \\textbf{X} \\end{aligned}\\] <p>Given specific choices of \\(\\textbf{X}\\), \\(\\textbf{a}\\), and \\(\\textbf{b}\\), we can calculate the corresponding derivatives via autograd by requiring a gradient to be stored in each relevant tensor: <pre><code>X = torch.ones((2,2), requires_grad=True)\na = torch.tensor([0.5, 1], requires_grad=True)\nb = torch.tensor([0.5, -2], requires_grad=True)\nf = a.T @ X @ b\nf\n&gt;&gt;&gt; tensor(-2.2500, grad_fn=&lt;DotBackward&gt;) \nf.backward() # backprop \na.grad\n&gt;&gt;&gt; tensor([-1.5000, -1.5000])\nb.T @ X.T \n&gt;&gt;&gt; tensor([-1.5000, -1.5000], grad_fn=&lt;SqueezeBackward3&gt;)\nb.grad\n&gt;&gt;&gt; tensor([1.5000, 1.5000])\na.T @ X\n&gt;&gt;&gt; tensor([1.5000, 1.5000], grad_fn=&lt;SqueezeBackward3&gt;)\n</code></pre> The <code>tensor.backward()</code> call initiates backpropagation, accumulating the gradient backward through a series of <code>grad_fn</code> labels tied to each tensor (e.g. <code>&lt;DotBackward&gt;</code>, indicating the dot product \\((\\textbf{a}^T\\textbf{X})\\textbf{b}\\)). </p>"},{"location":"inference/pytorch.html#data-utils","title":"Data Utils","text":"<p>PyTorch is equipped with many useful data-handling utilities. For example, the <code>torch.utils.data</code> package implements datasets (<code>torch.utils.data.Dataset</code>) and iterable data loaders (<code>torch.utils.data.DataLoader</code>). Additionally, various batching and sampling schemes are available. </p> <p>You can create custom iterable datasets via <code>torch.utils.data.Dataset</code>, for example a dataset collecting the results of XOR on two binary inputs: <pre><code>from torch.utils.data import Dataset\n\nclass Data(Dataset):\n    def __init__(self, device):\n        self.samples = torch.tensor([[0,0], [0,1], [1,0], [1,1]]).float().to(device)\n        self.targets = np.logical_xor(self.samples[:,0], \n                                      self.samples[:,1]).float().to(device)\n\n    def __len__(self):\n        return len(self.targets)\n\n    def __getitem__(self,idx):\n        return({'x': self.samples[idx],\n                'y': self.targets[idx]})\n</code></pre> Dataloaders, from <code>torch.utils.data.DataLoader</code>, can generate shuffled batches of data via multiple workers. Here, we load our datasets onto the GPU:  <pre><code>from torch.utils.data import DataLoader\n\ndevice = 'cpu'\ntrain_data = Data(device)\ntest_data = Data(device)\ntrain_loader = DataLoader(train_data, batch_size=1, shuffle=True, num_workers=2)\ntest_loader = DataLoader(test_data, batch_size=1, shuffle=False, num_workers=2)\nfor i, batch in enumerate(train_loader):\n    print(i, batch)\n\n&gt;&gt;&gt; 0 {'x': tensor([[0., 0.]]), 'y': tensor([0.])}\n    1 {'x': tensor([[1., 0.]]), 'y': tensor([1.])}\n    2 {'x': tensor([[1., 1.]]), 'y': tensor([0.])}\n    3 {'x': tensor([[0., 1.]]), 'y': tensor([1.])}\n</code></pre> The full set of data utils is available in the docs. </p>"},{"location":"inference/pytorch.html#neural-networks","title":"Neural Networks","text":"<p>The PyTorch nn package specifies a set of modules that correspond to different neural network (NN) components and operations. For example, the <code>torch.nn.Linear</code> module defines a linear transform with learnable parameters and the <code>torch.nn.Flatten</code> module flattens two contiguous tensor dimensions. The <code>torch.nn.Sequential</code> module contains a set of modules such as <code>torch.nn.Linear</code> and <code>torch.nn.Sequential</code>, chaining them together to form the forward pass of a forward network. Furthermore, one may specify various pre-implemented loss functions, for example <code>torch.nn.BCELoss</code> and <code>torch.nn.KLDivLoss</code>. The full set of PyTorch NN building blocks is available in the docs. </p> <p>As an example, we can design a simple neural network designed to reproduce the output of the XOR operation on binary inputs. To do so, we can compute a simple NN of the form:</p> \\[\\begin{aligned} x_{in}&amp;\\in\\{0,1\\}^{2}\\\\ l_1 &amp;= \\sigma(W_1^Tx_{in} + b_1); \\ W_1\\in\\mathbb{R}^{2\\times2},\\ b_1\\in\\mathbb{R}^{2}\\\\ l_2 &amp;= \\sigma(W_2^Tx + b_2); \\ W_2\\in\\mathbb{R}^{2},\\ b_1\\in\\mathbb{R}\\\\ \\end{aligned}\\] <pre><code>import torch.nn as nn\n\nclass Network(nn.Module):\n\n    def __init__(self):\n        super().__init__()\n\n        self.l1 = nn.Linear(2, 2)\n        self.l2 = nn.Linear(2, 1)\n\n    def forward(self, x):\n        x = torch.sigmoid(self.l1(x))\n        x = torch.sigmoid(self.l2(x))\n        return x\n\nmodel = Network().to(device)\nmodel(train_data['x'])\n\n&gt;&gt;&gt; tensor([[0.5000],\n            [0.4814],\n            [0.5148],\n            [0.4957]], grad_fn=&lt;SigmoidBackward&gt;)\n</code></pre>"},{"location":"inference/pytorch.html#optimizers","title":"Optimizers","text":"<p>Training a neural network involves minimizing a loss function; classes in the <code>torch.optim</code> package implement various optimization strategies for example stochastic gradient descent and Adam through <code>torch.optim.SGD</code> and <code>torch.optim.Adam</code> respectively. Optimizers are configurable through parameters such as the learning rate (configuring the optimizer's step size). The full set of optimizers and accompanying tutorials are available in the docs.</p> <p>To demonstrate the use of an optimizer, let's train the NN above to produce the results of the XOR operation on binary inputs. Here we'll use the Adam optimizer:</p> <p><pre><code>from torch import optim\nfrom torch.optim.lr_scheduler import StepLR\nfrom matplotlib import pyplot as plt\n\n# helpful references:\n# Learning XOR: exploring the space of a classic problem\n# https://towardsdatascience.com/how-neural-networks-solve-the-xor-problem-59763136bdd7\n# https://courses.cs.washington.edu/courses/cse446/18wi/sections/section8/XOR-Pytorch.html\n\n# the training function initiates backprop and \n# steps the optimizer towards the weights that \n# optimize the loss function \ndef train(model, train_loader, optimizer, epoch):\n    model.train()\n    losses = []\n    for i, batch in enumerate(train_loader):\n        optimizer.zero_grad()\n        output = model(batch['x'])\n        y, output = batch['y'], output.squeeze(1)\n\n        # optimize binary cross entropy:\n        # https://pytorch.org/docs/stable/generated/torch.nn.BCELoss.html\n        loss = F.binary_cross_entropy(output, y, reduction='mean')\n        loss.backward()\n        optimizer.step()\n        losses.append(loss.item())\n\n    return np.mean(losses)\n\n# the test function does not adjust the model's weights\ndef test(model, test_loader):\n    model.eval()\n    losses, n_correct, n_incorrect = [], 0, 0\n    with torch.no_grad():\n        for i, batch in enumerate(test_loader):\n            output = model(batch['x'])\n            y, output = batch['y'], output.squeeze(1)\n            loss = F.binary_cross_entropy(output, y, \n                                          reduction='mean').item()\n            losses.append(loss)\n\n            # determine accuracy by thresholding model output at 0.5\n            batch_correct = torch.sum(((output&gt;0.5) &amp; (y==1)) |\n                                      ((output&lt;0.5) &amp; (y==0)))\n            batch_incorrect = len(y) - batch_correct\n            n_correct += batch_correct\n            n_incorrect += batch_incorrect\n\n    return np.mean(losses), n_correct/(n_correct+n_incorrect)\n\n\n# randomly initialize the model's weights\nfor module in model.modules():\n    if isinstance(module, nn.Linear):\n        module.weight.data.normal_(0, 1)\n\n# send weights to optimizer \nlr = 2.5e-2\noptimizer = optim.Adam(model.parameters(), lr=lr)\n\nepochs = 500\nfor epoch in range(1, epochs + 1):\n    train_loss = train(model, train_loader, optimizer, epoch)\n    test_loss, test_acc = test(model, test_loader)\n    if epoch%25==0:\n        print('epoch={}: train_loss={:.3f}, test_loss={:.3f}, test_acc={:.3f}'\n              .format(epoch, train_loss, test_loss, test_acc))\n\n&gt;&gt;&gt; epoch=25: train_loss=0.683, test_loss=0.681, test_acc=0.500\n    epoch=50: train_loss=0.665, test_loss=0.664, test_acc=0.750\n    epoch=75: train_loss=0.640, test_loss=0.635, test_acc=0.750\n    epoch=100: train_loss=0.598, test_loss=0.595, test_acc=0.750\n    epoch=125: train_loss=0.554, test_loss=0.550, test_acc=0.750\n    epoch=150: train_loss=0.502, test_loss=0.498, test_acc=0.750\n    epoch=175: train_loss=0.435, test_loss=0.432, test_acc=0.750\n    epoch=200: train_loss=0.360, test_loss=0.358, test_acc=0.750\n    epoch=225: train_loss=0.290, test_loss=0.287, test_acc=1.000\n    epoch=250: train_loss=0.230, test_loss=0.228, test_acc=1.000\n    epoch=275: train_loss=0.184, test_loss=0.183, test_acc=1.000\n    epoch=300: train_loss=0.149, test_loss=0.148, test_acc=1.000\n    epoch=325: train_loss=0.122, test_loss=0.122, test_acc=1.000\n    epoch=350: train_loss=0.102, test_loss=0.101, test_acc=1.000\n    epoch=375: train_loss=0.086, test_loss=0.086, test_acc=1.000\n    epoch=400: train_loss=0.074, test_loss=0.073, test_acc=1.000\n    epoch=425: train_loss=0.064, test_loss=0.063, test_acc=1.000\n    epoch=450: train_loss=0.056, test_loss=0.055, test_acc=1.000\n    epoch=475: train_loss=0.049, test_loss=0.049, test_acc=1.000\n    epoch=500: train_loss=0.043, test_loss=0.043, test_acc=1.000\n</code></pre> Here, the model has converged to 100% test accuracy, indicating that it has learned to reproduce the XOR outputs perfectly. Note that even though the test accuracy is 100%, the test loss (BCE) decreases steadily; this is because the BCE loss is nonzero when \\(y_{output}\\) is not exactly 0 or 1, while accuracy is determined by thresholding the model outputs such that each prediction is the boolean \\((y_{output} &gt; 0.5)\\). This highlights that it is important to choose the correct performance metric for an ML problem. In the case of XOR, perfect test accuracy is sufficient. Let's check that we've recovered the XOR output by extracting the model's weights and using them to build a custom XOR function:</p> <pre><code>for name, param in model.named_parameters():\n    if param.requires_grad:\n        print(name, param.data)\n\n&gt;&gt;&gt; l1.weight tensor([[ 7.2888, -6.4168],\n                      [ 7.2824, -8.1637]])\n    l1.bias tensor([ 2.6895, -3.9633])\n    l2.weight tensor([[-6.3500,  8.0990]])\n    l2.bias tensor([2.5058])\n</code></pre> <p>Because our model was built with <code>nn.Linear</code> modules, we have weight matrices and bias terms. Next, we'll hard-code the matrix operations into a custom XOR function based on the architecture of the NN: </p> <pre><code>def XOR(x):\n    w1 = torch.tensor([[ 7.2888, -6.4168],\n                       [ 7.2824, -8.1637]]).t()\n    b1 = torch.tensor([ 2.6895, -3.9633])\n    layer1_out = torch.tensor([x[0]*w1[0,0] + x[1]*w1[1,0] + b1[0],\n                               x[0]*w1[0,1] + x[1]*w1[1,1] + b1[1]])\n    layer1_out = torch.sigmoid(layer1_out)\n\n    w2 = torch.tensor([-6.3500,  8.0990])\n    b2 = 2.5058\n    layer2_out = layer1_out[0]*w2[0] + layer1_out[1]*w2[1] + b2\n    layer2_out = torch.sigmoid(layer2_out)\n    return layer2_out, (layer2_out &gt; 0.5)\n\nXOR([0.,0.])\n&gt;&gt;&gt; (tensor(0.0359), tensor(False))\nXOR([0.,1.])\n&gt;&gt;&gt; (tensor(0.9135), tensor(True))\nXOR([1.,0.])\n&gt;&gt;&gt; (tensor(0.9815), tensor(True))\nXOR([1.,1.])\n&gt;&gt;&gt; (tensor(0.0265), tensor(False))\n</code></pre> <p>There we have it - the NN learned XOR! </p>"},{"location":"inference/pytorch.html#pytorch-in-cmssw","title":"PyTorch in CMSSW","text":""},{"location":"inference/pytorch.html#via-onnx","title":"Via ONNX","text":"<p>One way to incorporate your PyTorch models into CMSSW is through the Open Neural Network Exchange (ONNX) Runtime tool. In brief, ONNX supports training and inference for a variety of ML frameworks, and is currently integrated into CMSSW (see the CMS ML tutorial).  PyTorch hosts an excellent tutorial on exporting a model from PyTorch to ONNX. ONNX is available in CMSSW (see a relevant discussion in the CMSSW git repo). </p>"},{"location":"inference/pytorch.html#example-use-cases","title":"Example Use Cases","text":"<p>The \\(ZZ\\rightarrow 4b\\) analysis utilizes trained PyTorch models via ONNX in CMSSW (see the corresponding repo). Briefly, they run ONNX in CMSSW_11_X via the CMSSW package <code>PhysicsTools/ONNXRuntime</code>, using it to define a multiClassifierONNX class. This multiclassifier is capable of loading pre-trained PyTorch models specified by a <code>modelFile</code> string as follows:</p> <pre><code>#include \"PhysicsTools/ONNXRuntime/interface/ONNXRuntime.h\"\n\nstd::unique_ptr&lt;cms::Ort::ONNXRuntime&gt; model;\nOrt::SessionOptions* session_options = new Ort::SessionOptions();\nsession_options-&gt;SetIntraOpNumThreads(1);\nmodel = std::make_unique&lt;cms::Ort::ONNXRuntime&gt;(modelFile, session_options);\n</code></pre>"},{"location":"inference/pytorch.html#via-triton","title":"Via Triton","text":"<p>Coprocessors (GPUs, FPGAs, etc.) are frequently used to accelerate ML operations such as inference and training. In the 'as-a-service' paradigm, users can access cloud-based applications through lightweight client inferfaces. The Services for Optimized Network Inference on Coprocessors (SONIC) framework implements this paradigm in CMSSW, allowing the optimal integration of GPUs into event processing workflows. One powerful implementation of SONIC is the the NVIDIA Triton Inference Server, which is flexible with respect to ML framework, storage source, and hardware infrastructure. For more details, see the corresponding NVIDIA developer blog entry. </p> <p>A Graph Attention Network (GAN) is available via Triton in CMSSW, and can be accessed here: https://github.com/cms-sw/cmssw/tree/master/HeterogeneousCore/SonicTriton/test</p>"},{"location":"inference/pytorch.html#training-tips","title":"Training Tips","text":"<ul> <li>When instantiating a <code>DataLoader</code>, <code>shuffle=True</code> should be enabled for training data but not for validation and testing data. At each training epoch, this will vary the order of data objects in each batch; accordingly, it is not efficient to load the full dataset (in its original ordering) into GPU  memory before training. Instead, enable <code>num_workers&gt;1</code>; this allows the <code>DataLoader</code> to load batches to the GPU as they're prepared. Note that this launches muliple threads on the CPU. For more information, see a corresponding discussion in the PyTorch forum. </li> </ul>"},{"location":"inference/sonic_triton.html","title":"Service-based inference with Triton/Sonic","text":"<p>This page is still under construction. For the moment, please see the Sonic+Triton tutorial given as part of the Machine Learning HATS@LPC 2021.</p> <ul> <li>Link to Indico agenda</li> <li>Slides</li> <li>Exercise twiki</li> </ul>"},{"location":"inference/standalone.html","title":"Standalone framework","text":"<p>Todo.</p> <p>Idea: Working w/ TF+ROOT standalone (outside of CMSSW)</p>"},{"location":"inference/swan_aws.html","title":"SWAN + AWS","text":"<p>Todo.</p> <p>Ideas: best practices cost model instance priving need to log out monitoring madatory</p>"},{"location":"inference/tensorflow2.html","title":"Direct inference with TensorFlow 2","text":"<p>TensorFlow 2 is available since CMSSW_11_1_X (cmssw#28711, cmsdist#5525). The integration into the software stack can be found in cmsdist/tensorflow.spec and the interface is located in cmssw/PhysicsTools/TensorFlow.</p>"},{"location":"inference/tensorflow2.html#available-versions","title":"Available versions","text":"Python 3 on el8Python 3 on slc7Python 2 on slc7 TensorFlow el8_amd64_gcc10 el8_amd64_gcc11 v2.6.0 \u2265 CMSSW_12_3_4 - v2.6.4 \u2265 CMSSW_12_5_0 \u2265 CMSSW_12_5_0 TensorFlow slc7_amd64_gcc900 slc7_amd64_gcc10 slc7_amd64_gcc11 v2.1.0 \u2265 CMSSW_11_1_0 - - v2.3.1 \u2265 CMSSW_11_2_0 - - v2.4.1 \u2265 CMSSW_11_3_0 - - v2.5.0 \u2265 CMSSW_12_0_0 \u2265 CMSSW_12_0_0 - v2.6.0 \u2265 CMSSW_12_1_0 \u2265 CMSSW_12_1_0 \u2265 CMSSW_12_3_0 v2.6.4 - \u2265 CMSSW_12_5_0 \u2265 CMSSW_13_0_0 TensorFlow slc7_amd64_gcc900 v2.1.0 \u2265 CMSSW_11_1_0 v2.3.1 \u2265 CMSSW_11_2_0 <p>At this time, only CPU support is provided. While GPU support is generally possible, it is currently disabled due to some interference with production workflows but will be enabled once they are resolved.</p>"},{"location":"inference/tensorflow2.html#software-setup","title":"Software setup","text":"<p>To run the examples shown below, create a mininmal inference setup with the following snippet. Adapt the <code>SCRAM_ARCH</code> according to your operating system and desired compiler.</p> <pre><code>export SCRAM_ARCH=\"el8_amd64_gcc11\"\nexport CMSSW_VERSION=\"CMSSW_12_6_0\"\n\nsource \"/cvmfs/cms.cern.ch/cmsset_default.sh\" \"\"\n\ncmsrel \"${CMSSW_VERSION}\"\ncd \"${CMSSW_VERSION}/src\"\n\ncmsenv\nscram b\n</code></pre> <p>Below, the <code>cmsml</code> Python package is used to convert models from TensorFlow objects (<code>tf.function</code>'s or Keras models) to protobuf graph files (documentation). It should be available after executing the commands above. You can check its version via</p> <pre><code>python -c \"import cmsml; print(cmsml.__version__)\"\n</code></pre> <p>and compare to the released tags. If you want to install a newer version from either the master branch of the cmsml repository or the Python package index (PyPI), you can simply do that via pip.</p> masterPyPI <pre><code># into your user directory (usually ~/.local)\npip install --upgrade --user git+https://github.com/cms-ml/cmsml\n\n# _or_\n\n# into a custom directory\npip install --upgrade --prefix \"CUSTOM_DIRECTORY\" git+https://github.com/cms-ml/cmsml\n</code></pre> <pre><code># into your user directory (usually ~/.local)\npip install --upgrade --user cmsml\n\n# _or_\n\n# into a custom directory\npip install --upgrade --prefix \"CUSTOM_DIRECTORY\" cmsml\n</code></pre>"},{"location":"inference/tensorflow2.html#saving-your-model","title":"Saving your model","text":"<p>After successfully training, you should save your model in a protobuf graph file which can be read by the interface in CMSSW. Naturally, you only want to save that part of your model that is required to run the network prediction, i.e., it should not contain operations related to model training or loss functions (unless explicitely required). Also, to reduce the memory footprint and to accelerate the inference, variables should be converted to constant tensors. Both of these model transformations are provided by the <code>cmsml</code> package.</p> <p>Instructions on how to transform and save your model are shown below, depending on whether you use Keras or plain TensorFlow with <code>tf.function</code>'s.</p> Kerastf.function <p>The code below saves a Keras <code>Model</code> instance as a protobuf graph file using <code>cmsml.tensorflow.save_graph</code>. In order for Keras to built the internal graph representation before saving, make sure to either compile the model, or pass an <code>input_shape</code> to the first layer:</p> <pre><code># coding: utf-8\n\nimport tensorflow as tf\nimport tf.keras.layers as layers\nimport cmsml\n\n# define your model\nmodel = tf.keras.Sequential()\nmodel.add(layers.InputLayer(input_shape=(10,), name=\"input\"))\nmodel.add(layers.Dense(100, activation=\"tanh\"))\nmodel.add(layers.Dense(3, activation=\"softmax\", name=\"output\"))\n\n# train it\n...\n\n# convert to binary (.pb extension) protobuf\n# with variables converted to constants\ncmsml.tensorflow.save_graph(\"graph.pb\", model, variables_to_constants=True)\n\n# note: save_graph was renamed to save_frozen_graph in newer versions\n#       of cmsml and you might see a deprecation warning\n</code></pre> <p>Following the Keras naming conventions for certain layers, the input will be named <code>\"input\"</code> while the output is named <code>\"sequential/output/Softmax\"</code>. To cross check the names, you can save the graph in text format by using the extension <code>\".pb.txt\"</code>.</p> <p>Let's consider you write your network model in a single <code>tf.function</code>.</p> <pre><code># coding: utf-8\n\nimport tensorflow as tf\nimport cmsml\n\n# define the model\n@tf.function\ndef model(x):\n    # lift variable initialization to the lowest context so they are\n    # not re-initialized on every call (eager calls or signature tracing)\n    with tf.init_scope():\n        W = tf.Variable(tf.ones([10, 1]))\n        b = tf.Variable(tf.ones([1]))\n\n    # define your \"complex\" model here\n    h = tf.add(tf.matmul(x, W), b)\n    y = tf.tanh(h, name=\"y\")\n\n    return y\n</code></pre> <p>In TensorFlow terms, the <code>model</code> function is polymorphic - it accepts different types of the input tensor <code>x</code> (<code>tf.float32</code>, <code>tf.float64</code>, ...). For each type, TensorFlow will create a concrete function with an associated <code>tf.Graph</code> object. This mechanism is referred to as signature tracing. For deeper insights into <code>tf.function</code>, the concepts of signature tracing, polymorphic and concrete functions, see the guide on Better performance with <code>tf.function</code>.</p> <p>To save the model as a protobuf graph file, you explicitely need to create a concrete function. However, this is fairly easy once you know the exact type and shape of all input arguments.</p> <pre><code># create a concrete function\ncmodel = model.get_concrete_function(\n    tf.TensorSpec(shape=[2, 10], dtype=tf.float32),\n)\n\n# convert to binary (.pb extension) protobuf\n# with variables converted to constants\ncmsml.tensorflow.save_graph(\"graph.pb\", cmodel, variables_to_constants=True)\n\n# note: save_graph was renamed to save_frozen_graph in newer versions\n#       of cmsml and you might see a deprecation warning\n</code></pre> <p>The input will be named <code>\"x\"</code> while the output is named <code>\"y\"</code>. To cross check the names, you can save the graph in text format by using the extension <code>\".pb.txt\"</code>.</p> Different method: Frozen signatures <p>Instead of creating a polymorphic <code>tf.function</code> and extracting a concrete one in a second step, you can directly define an input signature upon definition.</p> <pre><code>@tf.function(input_signature=(tf.TensorSpec(shape=[2, 10], dtype=tf.float32),))\ndef model(x):\n    ...\n</code></pre> <p>This disables signature tracing since the input signature is frozen. However, you can directly pass it to <code>cmsml.tensorflow.save_graph</code>.</p>"},{"location":"inference/tensorflow2.html#inference-in-cmssw","title":"Inference in CMSSW","text":"<p>The inference can be implemented to run in a single thread. In general, this does not mean that the module cannot be executed with multiple threads (<code>cmsRun --numThreads &lt;N&gt; &lt;CFG_FILE&gt;</code>), but rather that its performance in terms of evaluation time and especially memory consumption is likely to be suboptimal. Therefore, for modules to be integrated into CMSSW, the multi-threaded implementation is strongly recommended.</p>"},{"location":"inference/tensorflow2.html#cmssw-module-setup","title":"CMSSW module setup","text":"<p>If you aim to use the TensorFlow interface in a CMSSW plugin, make sure to include</p> <pre><code>&lt;use name=\"PhysicsTools/TensorFlow\" /&gt;\n\n&lt;flags EDM_PLUGIN=\"1\" /&gt;\n</code></pre> <p>in your <code>plugins/BuildFile.xml</code> file. If you are using the interface inside the <code>src/</code> or <code>interface/</code> directory of your module, make sure to create a global <code>BuildFile.xml</code> file next to theses directories, containing (at least):</p> <pre><code>&lt;use name=\"PhysicsTools/TensorFlow\" /&gt;\n\n&lt;export&gt;\n    &lt;lib name=\"1\" /&gt;\n&lt;/export&gt;\n</code></pre>"},{"location":"inference/tensorflow2.html#single-threaded-inference","title":"Single-threaded inference","text":"<p>Despite <code>tf.Session</code> being removed in the Python interface as of TensorFlow 2, the concepts of</p> <ul> <li><code>Graph</code>'s, containing the constant computational structure and trained variables of your model,</li> <li><code>Session</code>'s, handling execution and data exchange, and</li> <li>the separation between them</li> </ul> <p>live on in the C++ interface. Thus, the overall inference approach is 1) include the interface, 2) initialize <code>Graph</code> and <code>session</code>, 3) per event create input tensors and run the inference, and 4) cleanup.</p>"},{"location":"inference/tensorflow2.html#1-includes","title":"1. Includes","text":"<pre><code>#include \"PhysicsTools/TensorFlow/interface/TensorFlow.h\"\n#include \"FWCore/Framework/interface/one/EDAnalyzer.h\"\n// further framework includes\n...\n</code></pre>"},{"location":"inference/tensorflow2.html#2-initialize-objects","title":"2. Initialize objects","text":"<pre><code>// configure logging to show warnings (see table below)\ntensorflow::setLogging(\"2\");\n\n// load the graph definition\ntensorflow::GraphDef* graphDef = tensorflow::loadGraphDef(\"/path/to/constantgraph.pb\");\n\n// create a session\ntensorflow::Session* session = tensorflow::createSession(graphDef);\n</code></pre>"},{"location":"inference/tensorflow2.html#3-inference","title":"3. Inference","text":"<pre><code>// create an input tensor\n// (example: single batch of 10 values)\ntensorflow::Tensor input(tensorflow::DT_FLOAT, { 1, 10 });\n\n\n// fill the tensor with your input data\n// (example: just fill consecutive values)\nfor (size_t i = 0; i &lt; 10; i++) {\n    input.matrix&lt;float&gt;()(0, i) = float(i);\n}\n\n// run the evaluation\nstd::vector&lt;tensorflow::Tensor&gt; outputs;\ntensorflow::run(session, { { \"input\", input } }, { \"output\" }, &amp;outputs);\n\n// process the output tensor\n// (example: print the 5th value of the 0th (the only) example)\nstd::cout &lt;&lt; outputs[0].matrix&lt;float&gt;()(0, 5) &lt;&lt; std::endl;\n// -&gt; float\n</code></pre>"},{"location":"inference/tensorflow2.html#4-cleanup","title":"4. Cleanup","text":"<pre><code>tensorflow::closeSession(session);\ndelete graphDef;\n</code></pre>"},{"location":"inference/tensorflow2.html#full-example","title":"Full example","text":"Click to expand <p>The example assumes the following directory structure:</p> <pre><code>MySubsystem/MyModule/\n\u2502\n\u251c\u2500\u2500 plugins/\n\u2502   \u251c\u2500\u2500 MyPlugin.cpp\n\u2502   \u2514\u2500\u2500 BuildFile.xml\n\u2502\n\u251c\u2500\u2500 test/\n\u2502   \u2514\u2500\u2500 my_plugin_cfg.py\n\u2502\n\u2514\u2500\u2500 data/\n    \u2514\u2500\u2500 graph.pb\n</code></pre> plugins/MyPlugin.cppplugins/BuildFile.xmltest/my_plugin_cfg.py <pre><code>/*\n * Example plugin to demonstrate the direct single-threaded inference with TensorFlow 2.\n */\n\n#include &lt;memory&gt;\n\n#include \"FWCore/Framework/interface/Event.h\"\n#include \"FWCore/Framework/interface/Frameworkfwd.h\"\n#include \"FWCore/Framework/interface/MakerMacros.h\"\n#include \"FWCore/Framework/interface/one/EDAnalyzer.h\"\n#include \"FWCore/ParameterSet/interface/ParameterSet.h\"\n#include \"PhysicsTools/TensorFlow/interface/TensorFlow.h\"\n\nclass MyPlugin : public edm::one::EDAnalyzer&lt;&gt; {\npublic:\n  explicit MyPlugin(const edm::ParameterSet&amp;);\n  ~MyPlugin(){};\n\n  static void fillDescriptions(edm::ConfigurationDescriptions&amp;);\n\nprivate:\n  void beginJob();\n  void analyze(const edm::Event&amp;, const edm::EventSetup&amp;);\n  void endJob();\n\n  std::string graphPath_;\n  std::string inputTensorName_;\n  std::string outputTensorName_;\n\n  tensorflow::GraphDef* graphDef_;\n  tensorflow::Session* session_;\n};\n\nvoid MyPlugin::fillDescriptions(edm::ConfigurationDescriptions&amp; descriptions) {\n  // defining this function will lead to a *_cfi file being generated when compiling\n  edm::ParameterSetDescription desc;\n  desc.add&lt;std::string&gt;(\"graphPath\");\n  desc.add&lt;std::string&gt;(\"inputTensorName\");\n  desc.add&lt;std::string&gt;(\"outputTensorName\");\n  descriptions.addWithDefaultLabel(desc);\n}\n\nMyPlugin::MyPlugin(const edm::ParameterSet&amp; config)\n    : graphPath_(config.getParameter&lt;std::string&gt;(\"graphPath\")),\n      inputTensorName_(config.getParameter&lt;std::string&gt;(\"inputTensorName\")),\n      outputTensorName_(config.getParameter&lt;std::string&gt;(\"outputTensorName\")),\n      graphDef_(nullptr),\n      session_(nullptr) {\n  // set tensorflow log level to warning\n  tensorflow::setLogging(\"2\");\n}\n\nvoid MyPlugin::beginJob() {\n  // load the graph\n  graphDef_ = tensorflow::loadGraphDef(graphPath_);\n\n  // create a new session and add the graphDef\n  session_ = tensorflow::createSession(graphDef_);\n}\n\nvoid MyPlugin::endJob() {\n  // close the session\n  tensorflow::closeSession(session_);\n\n  // delete the graph\n  delete graphDef_;\n  graphDef_ = nullptr;\n}\n\nvoid MyPlugin::analyze(const edm::Event&amp; event, const edm::EventSetup&amp; setup) {\n  // define a tensor and fill it with range(10)\n  tensorflow::Tensor input(tensorflow::DT_FLOAT, {1, 10});\n  for (size_t i = 0; i &lt; 10; i++) {\n    input.matrix&lt;float&gt;()(0, i) = float(i);\n  }\n\n  // define the output and run\n  std::vector&lt;tensorflow::Tensor&gt; outputs;\n  tensorflow::run(session_, {{inputTensorName_, input}}, {outputTensorName_}, &amp;outputs);\n\n  // print the output\n  std::cout &lt;&lt; \" -&gt; \" &lt;&lt; outputs[0].matrix&lt;float&gt;()(0, 0) &lt;&lt; std::endl &lt;&lt; std::endl;\n}\n\nDEFINE_FWK_MODULE(MyPlugin);\n</code></pre> <pre><code>&lt;use name=\"FWCore/Framework\" /&gt;\n&lt;use name=\"FWCore/PluginManager\" /&gt;\n&lt;use name=\"FWCore/ParameterSet\" /&gt;\n&lt;use name=\"PhysicsTools/TensorFlow\" /&gt;\n\n&lt;flags EDM_PLUGIN=\"1\" /&gt;\n</code></pre> <pre><code># coding: utf-8\n\nimport os\n\nimport FWCore.ParameterSet.Config as cms\nfrom FWCore.ParameterSet.VarParsing import VarParsing\n\n\n# get the data/ directory\nthisdir = os.path.dirname(os.path.abspath(__file__))\ndatadir = os.path.join(os.path.dirname(thisdir), \"data\")\n\n# setup minimal options\noptions = VarParsing(\"python\")\noptions.setDefault(\"inputFiles\", \"root://xrootd-cms.infn.it//store/mc/RunIISummer20UL17MiniAODv2/TTToSemiLeptonic_TuneCP5_13TeV-powheg-pythia8/MINIAODSIM/106X_mc2017_realistic_v9-v1/00000/005708B7-331C-904E-88B9-189011E6C9DD.root\")  # noqa\noptions.parseArguments()\n\n# define the process to run\nprocess = cms.Process(\"TEST\")\n\n# minimal configuration\nprocess.load(\"FWCore.MessageService.MessageLogger_cfi\")\nprocess.MessageLogger.cerr.FwkReport.reportEvery = 1\nprocess.maxEvents = cms.untracked.PSet(\n    input=cms.untracked.int32(10),\n)\nprocess.source = cms.Source(\n    \"PoolSource\",\n    fileNames=cms.untracked.vstring(options.inputFiles),\n)\n\n# process options\nprocess.options = cms.untracked.PSet(\n    allowUnscheduled=cms.untracked.bool(True),\n    wantSummary=cms.untracked.bool(True),\n)\n\n# setup MyPlugin by loading the auto-generated cfi (see MyPlugin.fillDescriptions)\nprocess.load(\"MySubsystem.MyModule.myPlugin_cfi\")\nprocess.myPlugin.graphPath = cms.string(os.path.join(datadir, \"graph.pb\"))\nprocess.myPlugin.inputTensorName = cms.string(\"input\")\nprocess.myPlugin.outputTensorName = cms.string(\"output\")\n\n# define what to run in the path\nprocess.p = cms.Path(process.myPlugin)\n</code></pre>"},{"location":"inference/tensorflow2.html#multi-threaded-inference","title":"Multi-threaded inference","text":"<p>Compared to the single-threaded implementation above, the multi-threaded version has one major difference: both the <code>Graph</code> and the <code>Session</code> are no longer members of a particular module instance, but rather shared between all instances in all threads. See the documentation on the C++ interface of <code>stream</code> modules for details.</p> <p>Recommendation updated</p> <p>The previous recommendation stated that the <code>Session</code> is not constant and thus, should not be placed in the global cache, but rather created once per stream module instance. However, it was discovered that, although not explicitely declared as constant in the <code>tensorflow::run()</code> / <code>Session::run()</code> interface, the session is actually not changed during evaluation and can be treated as being effectively constant.</p> <p>As a result, it is safe to move it to the global cache, next to the <code>Graph</code> object. The TensorFlow interface in CMSSW was adjusted in order to accept <code>const</code> objects in cmssw#40161.</p> <p>Thus, the overall inference approach is 1) include the interface, 2) let your plugin inherit from <code>edm::stream::EDAnalyzerasdasd</code> and declare the <code>GlobalCache</code>, 3) store in c<code>const Session*</code>, pointing to the cached session, and 4) per event create input tensors and run the inference.</p>"},{"location":"inference/tensorflow2.html#1-includes_1","title":"1. Includes","text":"<pre><code>#include \"PhysicsTools/TensorFlow/interface/TensorFlow.h\"\n#include \"FWCore/Framework/interface/stream/EDAnalyzer.h\"\n// further framework includes\n...\n</code></pre> <p>Note that <code>stream/EDAnalyzer.h</code> is included rather than <code>one/EDAnalyzer.h</code>.</p>"},{"location":"inference/tensorflow2.html#2-define-and-use-the-global-cache","title":"2. Define and use the global cache","text":"<p>The cache definition is done by declaring a simple struct. However, for the purpose of just storing a graph and a session object, a so-called <code>tensorflow::SessionCache</code> struct is already provided centrally. It was added in cmssw#40284 and its usage is shown in the following. In case the <code>tensorflow::SessionCache</code> is not (yet) available in your version of CMSSW, expand the \"Custom cache struct\" section below.</p> <p>Use it in the <code>edm::GlobalCache</code> template argument and adjust the plugin accordingly.</p> <pre><code>class MyPlugin : public edm::stream::EDAnalyzer&lt;edm::GlobalCache&lt;tensorflow::SessionCache&gt;&gt; {\npublic:\n    explicit GraphLoadingMT(const edm::ParameterSet&amp;, const tensorflow::SessionCache*);\n    ~GraphLoadingMT();\n\n    // additional static methods for initializing and closing the global cache\n    static std::unique_ptr&lt;tensorflow::SessionCache&gt; initializeGlobalCache(const edm::ParameterSet&amp;);\n    static void globalEndJob(const tensorflow::SessionCache*);\n...\n</code></pre> <p>Implement <code>initializeGlobalCache</code> to control the behavior of how the cache object is created. You also need to implement <code>globalEndJob</code>, however, it can remain empty as the destructor of <code>tensorflow::SessionCache</code> already handles the closing of the session itself and the deletion of all objects.</p> <pre><code>std::unique_ptr&lt;tensorflow::SessionCache&gt; MyPlugin::initializeGlobalCache(const edm::ParameterSet&amp; config) {\n  std::string graphPath = edm::FileInPath(params.getParameter&lt;std::string&gt;(\"graphPath\")).fullPath();\n  return std::make_unique&lt;tensorflow::SessionCache&gt;(graphPath);\n}\n\nvoid MyPlugin::globalEndJob(const tensorflow::SessionCache* cache) {}\n</code></pre> Custom cache struct <pre><code>struct MyCache {\n  MyCache() : {\n  }\n\n  std::atomic&lt;tensorflow::GraphDef*&gt; graph;\n  std::atomic&lt;tensorflow::Session*&gt; session;\n};\n</code></pre> <p>Use it in the <code>edm::GlobalCache</code> template argument and adjust the plugin accordingly.</p> <pre><code>class MyPlugin : public edm::stream::EDAnalyzer&lt;edm::GlobalCache&lt;CacheData&gt;&gt; {\npublic:\n    explicit GraphLoadingMT(const edm::ParameterSet&amp;, const CacheData*);\n    ~GraphLoadingMT();\n\n    // two additional static methods for handling the global cache\n    static std::unique_ptr&lt;CacheData&gt; initializeGlobalCache(const edm::ParameterSet&amp;);\n    static void globalEndJob(const CacheData*);\n...\n</code></pre> <p>Implement <code>initializeGlobalCache</code> and <code>globalEndJob</code> to control the behavior of how the cache object is created and destroyed.</p> <p>See the full example below for more details.</p>"},{"location":"inference/tensorflow2.html#3-initialize-objects","title":"3. Initialize objects","text":"<p>In your module constructor, you can get a pointer to the constant session to perform model evaluation during the event loop.</p> <pre><code>// declaration in header\nconst tensorflow::Session* _session;\n\n// get a pointer to the const session stored in the cache in the constructor init\nMyPlugin::MyPlugin(const edm::ParameterSet&amp; config,  const tensorflow::SessionCache* cache)\n    : session_(cache-&gt;getSession()) {\n  ...\n}\n</code></pre>"},{"location":"inference/tensorflow2.html#4-inference","title":"4. Inference","text":"<pre><code>// create an input tensor\n// (example: single batch of 10 values)\ntensorflow::Tensor input(tensorflow::DT_FLOAT, { 1, 10 });\n\n\n// fill the tensor with your input data\n// (example: just fill consecutive values)\nfor (size_t i = 0; i &lt; 10; i++) {\n    input.matrix&lt;float&gt;()(0, i) = float(i);\n}\n\n// define the output\nstd::vector&lt;tensorflow::Tensor&gt; outputs;\n\n// evaluate\n// note: in case this line causes the compiler to complain about the const'ness of the session_ in\n//       this call, your CMSSW version might not yet support passing a const session, so in this\n//       case, pass \"const_cast&lt;tensorflow::Session*&gt;(session_)\"\ntensorflow::run(session_, { { inputTensorName, input } }, { outputTensorName }, &amp;outputs);\n\n// process the output tensor\n// (example: print the 5th value of the 0th (the only) example)\nstd::cout &lt;&lt; outputs[0].matrix&lt;float&gt;()(0, 5) &lt;&lt; std::endl;\n// -&gt; float\n</code></pre> <p>Note</p> <p>If the TensorFlow interface in your CMSSW release does not yet accept <code>const</code> sessions, line 19 in the example above will cause an error during compilation. In this case, replace <code>session_</code> in that line to</p> <pre><code>const_cast&lt;tensorflow::Session*&gt;(session_)\n</code></pre>"},{"location":"inference/tensorflow2.html#full-example_1","title":"Full example","text":"Click to expand <p>The example assumes the following directory structure:</p> <pre><code>MySubsystem/MyModule/\n\u2502\n\u251c\u2500\u2500 plugins/\n\u2502   \u251c\u2500\u2500 MyPlugin.cpp\n\u2502   \u2514\u2500\u2500 BuildFile.xml\n\u2502\n\u251c\u2500\u2500 test/\n\u2502   \u2514\u2500\u2500 my_plugin_cfg.py\n\u2502\n\u2514\u2500\u2500 data/\n    \u2514\u2500\u2500 graph.pb\n</code></pre> plugins/MyPlugin.cppplugins/BuildFile.xmltest/my_plugin_cfg.py <pre><code>/*\n * Example plugin to demonstrate the direct multi-threaded inference with TensorFlow 2.\n */\n\n#include &lt;memory&gt;\n\n#include \"FWCore/Framework/interface/Event.h\"\n#include \"FWCore/Framework/interface/Frameworkfwd.h\"\n#include \"FWCore/Framework/interface/MakerMacros.h\"\n#include \"FWCore/Framework/interface/stream/EDAnalyzer.h\"\n#include \"FWCore/ParameterSet/interface/ParameterSet.h\"\n#include \"PhysicsTools/TensorFlow/interface/TensorFlow.h\"\n\n// put a tensorflow::SessionCache into the global cache structure\n// the session cache wraps both a tf graph and a tf session instance and also handles their deletion\nclass MyPlugin : public edm::stream::EDAnalyzer&lt;edm::GlobalCache&lt;tensorflow::SessionCache&gt;&gt; {\npublic:\n  explicit MyPlugin(const edm::ParameterSet&amp;, const tensorflow::SessionCache*);\n  ~MyPlugin(){};\n\n  static void fillDescriptions(edm::ConfigurationDescriptions&amp;);\n\n  // additional static methods for initializing and closing the global cache\n  static std::unique_ptr&lt;tensorflow::SessionCache&gt; initializeGlobalCache(const edm::ParameterSet&amp;);\n  static void globalEndJob(const tensorflow::SessionCache*);\n\nprivate:\n  void beginJob();\n  void analyze(const edm::Event&amp;, const edm::EventSetup&amp;);\n  void endJob();\n\n  std::string inputTensorName_;\n  std::string outputTensorName_;\n\n  // a pointer to the session created by the global session cache\n  const tensorflow::Session* session_;\n};\n\nstd::unique_ptr&lt;tensorflow::SessionCache&gt; MyPlugin::initializeGlobalCache(const edm::ParameterSet&amp; params) {\n  // this method is supposed to create, initialize and return a SessionCache instance\n  std::string graphPath = edm::FileInPath(params.getParameter&lt;std::string&gt;(\"graphPath\")).fullPath();\n  // Setup the TF backend by configuration\n  if (params.getParameter&lt;std::string&gt;(\"tf_backend\") == \"cuda\"){\n    tensorflow::Options options { tensorflow::Backend::cuda};\n  }else {\n    tensorflow::Options options { tensorflow::Backend::cpu};\n  }\n  return std::make_unique&lt;tensorflow::SessionCache&gt;(graphPath, options);\n}\n\nvoid MyPlugin::globalEndJob(const tensorflow::SessionCache* cache) {}\n\nvoid MyPlugin::fillDescriptions(edm::ConfigurationDescriptions&amp; descriptions) {\n  // defining this function will lead to a *_cfi file being generated when compiling\n  edm::ParameterSetDescription desc;\n  desc.add&lt;std::string&gt;(\"graphPath\");\n  desc.add&lt;std::string&gt;(\"inputTensorName\");\n  desc.add&lt;std::string&gt;(\"outputTensorName\");\n  descriptions.addWithDefaultLabel(desc);\n}\n\nMyPlugin::MyPlugin(const edm::ParameterSet&amp; config,  const tensorflow::SessionCache* cache)\n    : inputTensorName_(config.getParameter&lt;std::string&gt;(\"inputTensorName\")),\n      outputTensorName_(config.getParameter&lt;std::string&gt;(\"outputTensorName\")),\n      session_(cache-&gt;getSession()) {}\n\nvoid MyPlugin::beginJob() {}\n\nvoid MyPlugin::endJob() {\n  // close the session\n  tensorflow::closeSession(session_);\n}\n\nvoid MyPlugin::analyze(const edm::Event&amp; event, const edm::EventSetup&amp; setup) {\n  // define a tensor and fill it with range(10)\n  tensorflow::Tensor input(tensorflow::DT_FLOAT, {1, 10});\n  for (size_t i = 0; i &lt; 10; i++) {\n    input.matrix&lt;float&gt;()(0, i) = float(i);\n  }\n\n  // define the output\n  std::vector&lt;tensorflow::Tensor&gt; outputs;\n\n  // evaluate\n  // note: in case this line causes the compile to complain about the const'ness of the session_ in\n  //       this call, your CMSSW version might not yet support passing a const session, so in this\n  //       case, pass \"const_cast&lt;tensorflow::Session*&gt;(session_)\"\n  tensorflow::run(session_, {{inputTensorName_, input}}, {outputTensorName_}, &amp;outputs);\n\n  // print the output\n  std::cout &lt;&lt; \" -&gt; \" &lt;&lt; outputs[0].matrix&lt;float&gt;()(0, 0) &lt;&lt; std::endl &lt;&lt; std::endl;\n}\n\nDEFINE_FWK_MODULE(MyPlugin);\n</code></pre> <pre><code>&lt;use name=\"FWCore/Framework\" /&gt;\n&lt;use name=\"FWCore/PluginManager\" /&gt;\n&lt;use name=\"FWCore/ParameterSet\" /&gt;\n&lt;use name=\"PhysicsTools/TensorFlow\" /&gt;\n\n&lt;flags EDM_PLUGIN=\"1\" /&gt;\n</code></pre> <pre><code># coding: utf-8\n\nimport os\n\nimport FWCore.ParameterSet.Config as cms\nfrom FWCore.ParameterSet.VarParsing import VarParsing\n\n\n# get the data/ directory\nthisdir = os.path.dirname(os.path.abspath(__file__))\ndatadir = os.path.join(os.path.dirname(thisdir), \"data\")\n\n# setup minimal options\noptions = VarParsing(\"python\")\noptions.setDefault(\"inputFiles\", \"root://xrootd-cms.infn.it//store/mc/RunIISummer20UL17MiniAODv2/TTToSemiLeptonic_TuneCP5_13TeV-powheg-pythia8/MINIAODSIM/106X_mc2017_realistic_v9-v1/00000/005708B7-331C-904E-88B9-189011E6C9DD.root\")  # noqa\noptions.parseArguments()\n\n# define the process to run\nprocess = cms.Process(\"TEST\")\n\n# minimal configuration\nprocess.load(\"FWCore.MessageService.MessageLogger_cfi\")\nprocess.MessageLogger.cerr.FwkReport.reportEvery = 1\nprocess.maxEvents = cms.untracked.PSet(\n    input=cms.untracked.int32(10),\n)\nprocess.source = cms.Source(\n    \"PoolSource\",\n    fileNames=cms.untracked.vstring(options.inputFiles),\n)\n\n# process options\nprocess.options = cms.untracked.PSet(\n    allowUnscheduled=cms.untracked.bool(True),\n    wantSummary=cms.untracked.bool(True),\n)\n\n# setup MyPlugin by loading the auto-generated cfi (see MyPlugin.fillDescriptions)\nprocess.load(\"MySubsystem.MyModule.myPlugin_cfi\")\nprocess.myPlugin.graphPath = cms.string(os.path.join(datadir, \"graph.pb\"))\nprocess.myPlugin.inputTensorName = cms.string(\"input\")\nprocess.myPlugin.outputTensorName = cms.string(\"output\")\n\n# define what to run in the path\nprocess.p = cms.Path(process.myPlugin)\n</code></pre>"},{"location":"inference/tensorflow2.html#gpu-backend","title":"GPU backend","text":"<p>By default the TensorFlow sessions get created for CPU running. Since CMSSW_13_1_X the GPU backend for TensorFlow is available in the cmssw release. </p> <p>Minimal changes are needed in the inference code to move the model on the GPU.  A <code>tensorflow::Options</code> struct is available to setup the backend. </p> <pre><code>tensorflow::Options options { tensorflow::Backend::cuda};\n\n# Initialize the cache\ntensorflow::SessionCache cache(pbFile, options);\n# or a single session\nconst tensorflow::Session* session = tensorflow::createSession(graphDef, options);\n</code></pre> <p>CMSSW modules should add an options in the <code>PSets</code> of the producers and analyzers to configure on the fly the TensorFlow backend for the sessions created by the plugins. </p>"},{"location":"inference/tensorflow2.html#optimization","title":"Optimization","text":"<p>Depending on the use case, the following approaches can optimize the inference performance. It could be worth checking them out in your algorithm.</p> <p>Further optimization approaches can be found in the integration checklist.</p>"},{"location":"inference/tensorflow2.html#reusing-tensors","title":"Reusing tensors","text":"<p>In some cases, instead of creating new input tensors for each inference call, you might want to store input tensors as members of your plugin. This is of course possible if you know its exact shape a-prioro and comes with the cost of keeping the tensor in memory for the lifetime of your module instance.</p> <p>You can use</p> <pre><code>tensor.flat&lt;float&gt;().setZero();\n</code></pre> <p>to reset the values of your tensor prior to each call.</p>"},{"location":"inference/tensorflow2.html#tensor-data-access-via-pointers","title":"Tensor data access via pointers","text":"<p>As shown in the examples above, tensor data can be accessed through methods such as <code>flat&lt;type&gt;()</code> or <code>matrix&lt;type&gt;()</code> which return objects that represent the underlying data in the requested structure (<code>tensorflow::Tensor</code> C++ API). To read and manipulate particular elements, you can directly call this object with the coordinates of an element.</p> <pre><code>// matrix returns a 2D representation\n// set element (b,i) to f\ntensor.matrix&lt;float&gt;()(b, i) = float(f);\n</code></pre> <p>However, doing this for a large input tensor might entail some overhead. Since the data is actually contiguous in memory (C-style \"row-major\" memory ordering), a faster (though less explicit) way of interacting with tensor data is using a pointer.</p> <pre><code>// get the pointer to the first tensor element\nfloat* d = tensor.flat&lt;float&gt;().data();\n</code></pre> <p>Now, the tensor data can be filled using simple and fast pointer arithmetic.</p> <pre><code>// fill tensor data using pointer arithmethic\n// memory ordering is row-major, so the most outer loop corresponds dimension 0\nfor (size_t b = 0; b &lt; batchSize; b++) {\n    for (size_t i = 0; i &lt; nFeatures; i++, d++) {  // note the d++\n        *d = float(i);\n    }\n}\n</code></pre>"},{"location":"inference/tensorflow2.html#inter-and-intra-operation-parallelism","title":"Inter- and intra-operation parallelism","text":"<p>Debugging and local processing only</p> <p>Parallelism between (inter) and within (intra) operations can greatly improve the inference performance. However, this allows TensorFlow to manage and schedule threads on its own, possibly interfering with the thread model inherent to CMSSW. For inference code that is to be officially integrated, you should avoid inter- and intra-op parallelism and rather adhere to the examples shown above.</p> <p>You can configure the amount of inter- and infra-op threads via the second argument of the <code>tensorflow::createSession</code> method.</p> SimpleVerbose <pre><code>tensorflow::Session* session = tensorflow::createSession(graphDef, nThreads);\n</code></pre> <pre><code>tensorflow::SessionOptions sessionOptions;\nsessionOptions.config.set_intra_op_parallelism_threads(nThreads);\nsessionOptions.config.set_inter_op_parallelism_threads(nThreads);\n\ntensorflow::Session* session = tensorflow::createSession(graphDef, sessionOptions);\n</code></pre> <p>Then, when calling <code>tensorflow::run</code>, pass the internal name of the TensorFlow threadpool, i.e. <code>\"tensorflow\"</code>, as the last argument.</p> <pre><code>std::vector&lt;tensorflow::Tensor&gt; outputs;\ntensorflow::run(\n    session,\n    { { inputTensorName, input } },\n    { outputTensorName },\n    &amp;outputs,\n    \"tensorflow\"\n);\n</code></pre>"},{"location":"inference/tensorflow2.html#miscellaneous","title":"Miscellaneous","text":""},{"location":"inference/tensorflow2.html#logging","title":"Logging","text":"<p>By default, TensorFlow logging is quite verbose. This can be changed by either setting the <code>TF_CPP_MIN_LOG_LEVEL</code> environment varibale before calling <code>cmsRun</code>, or within your code through <code>tensorflow::setLogging(level)</code>.</p> Verbosity level <code>TF_CPP_MIN_LOG_LEVEL</code> debug \"0\" info \"1\" (default) warning \"2\" error \"3\" none \"4\" <p>Forwarding logs to the <code>MessageLogger</code> service is not possible yet.</p>"},{"location":"inference/tensorflow2.html#links-and-further-reading","title":"Links and further reading","text":"<ul> <li><code>cmsml</code> package</li> <li>CMSSW<ul> <li>TensorFlow interface documentation</li> <li>TensorFlow interface header</li> <li>CMSSW process options</li> <li>C++ interface of <code>stream</code> modules</li> </ul> </li> <li>TensorFlow<ul> <li>TensorFlow 2 tutorial</li> <li><code>tf.function</code></li> <li>C++ API</li> <li><code>tensorflow::Tensor</code></li> <li><code>tensorflow::Operation</code></li> <li><code>tensorflow::ClientSession</code></li> </ul> </li> <li>Keras<ul> <li>API</li> </ul> </li> </ul> <p>Authors: Marcel Rieger</p>"},{"location":"inference/tensorflow_aot.html","title":"AOT compilation of TensorFlow models","text":""},{"location":"inference/tensorflow_aot.html#introduction","title":"Introduction","text":"<p>The usual way of evaluating TensorFlow models in CMSSW is through the TF C++ interface provided in <code>PhysicsTools/TensorFlow</code> as described in the TensorFlow inference documentation. This way of model inference requires saving a trained model in the so-called frozen graph format, and then loading it through the TF C++ API within CMSSW which builds an internal representation of the computational graph. While being straight forward and flexible, this approach entails two potential sources of overhead:</p> <ul> <li>The TF C++ library and runtime requires a sizeable amount of memory at runtime.</li> <li>The internal graph representation is mostly identical that defined during model training, meaning that it is not necessarily optimal for fast inference.</li> </ul> <p>Ahead-of-time (AOT) compilation of TensorFlow models is a way to avoid this overhead while potentially also reducing compute runtimes and memory footprint. It consists of three steps (note that you do not have to run these steps manually as there are tools provided to automate them):</p> <ol> <li>First, computational graph is converted to a series of operations whose kernel implementations are based on the Accelerated Linear Algebra (XLA) framework.</li> <li>In this process, low-level optimization methods can be applied (kernel fusion, memory optimization, ...) that exploit the graph-structure of the model. More info can be found here and here.</li> <li>Using XLA, the sequence of operations can be compiled and converted to machine code which can then be invoked through a simple function call.</li> </ol> <pre><code>flowchart LR\n    SavedModel -- optimizations --&gt; xla{XLA}\n    xla -- compilation --&gt; aot{AOT}\n    aot --&gt; model.h\n    aot --&gt; model.o</code></pre> <p>One should note that the model integration and deployment workflow is signficantly different. Since self-contained executable code is generated, any custom code (e.g. a CMSSW plugin) that depends on the generated code needs to be compiled everytime a model changes - after each training, change of input / output signatures, or updated batching options. However, the tools that are described below greatly simplify this process.</p> <p>This approach works for most models and supports multiple inputs and outputs of different types. In general, various compute backends are supported (GPU, TPU) but for now, the implementation in CMSSW focuses on CPU only.</p> <p>Further info:</p> <ul> <li>TensorFlow documentation</li> <li>Summary gist (summarizes the central steps of the compilation process and model usage)</li> <li>Talk at Core Software Meeting</li> </ul> <p>The AOT mechanism was introduced in CMSSW_14_1_0_pre3 (cmssw#43941, cmssw#44519, cmsdist#9005). The interface is located at cmssw/PhysicsTools/TensorFlowAOT.</p> <p>Note on dynamic batching</p> <p>The compiled machine code is created with a fixed layout for buffers storing input values, intermediate layer values, and final outputs. Due to this, models have to be compiled with one or more static batch sizes. However, a mechanism is provided in the CMSSW interface that emulates dynamic batching by stitching the results of multiple smaller batch sizes for which the model was compiled. More info is given below.</p>"},{"location":"inference/tensorflow_aot.html#software-setup","title":"Software setup","text":"<p>To run the examples shown below, create a mininmal setup with the following snippet. Adapt the <code>SCRAM_ARCH</code> according to your operating system and desired compiler.</p> <pre><code>export SCRAM_ARCH=\"el8_amd64_gcc12\"\nexport CMSSW_VERSION=\"CMSSW_14_1_0_pre3\"\n\nsource \"/cvmfs/cms.cern.ch/cmsset_default.sh\" \"\"\n\ncmsrel \"${CMSSW_VERSION}\"\ncd \"${CMSSW_VERSION}/src\"\n\ncmsenv\nscram b\n</code></pre>"},{"location":"inference/tensorflow_aot.html#saving-your-model","title":"Saving your model","text":"<p>The AOT compilation process requires a TensorFlow model saved in the so-called <code>SavedModel</code> format. Its output is a directory that usually contains the graph structure, weights and meta data.</p> <p>Instructions on how to save your model are shown below, depending on whether you use Keras or plain TensorFlow with <code>tf.function</code>'s. Also note that, in both examples, models are saved with a dynamic (that is, unspecified) batch size which is taken advantage of in the compilation process in the subsequent step.</p> Kerastf.function <p>In order for Keras to built the internal graph representation before saving, make sure to either compile the model, or pass an <code>input_shape</code> to the first layer:</p> <pre><code># coding: utf-8\n\nimport tensorflow as tf\nimport tf.keras.layers as layers\n\n# define your model\nmodel = tf.keras.Sequential()\nmodel.add(layers.InputLayer(input_shape=(10,), name=\"input\"))\nmodel.add(layers.Dense(100, activation=\"tanh\"))\nmodel.add(layers.Dense(3, activation=\"softmax\", name=\"output\"))\n\n# train it\n...\n\n# save as SavedModel\ntf.saved_model.save(model, \"/path/to/saved_model\")\n</code></pre> <p>Let's consider you write your network model in a standalone function (usually a <code>tf.function</code>). In this case, you need to wrap it's invocation inside a <code>tf.Module</code> instance as shown below.</p> <pre><code># coding: utf-8\n\nimport tensorflow as tf\n\n# define the model\n@tf.function\ndef model_func(x):\n    # lift variable initialization to the lowest context so they are\n    # not re-initialized on every call (eager calls or signature tracing)\n    with tf.init_scope():\n        W = tf.Variable(tf.ones([10, 1]))\n        b = tf.Variable(tf.ones([1]))\n\n    # define your \"complex\" model here\n    h = tf.add(tf.matmul(x, W), b)\n    y = tf.tanh(h, name=\"y\")\n\n    return y\n\n# wrap in tf.Module\nclass MyModel(tf.Module):\n    def __call__(self, x):\n        return model_func(x)\n\n# create an instance\nmodel = MyModel()\n\n# save as SavedModel\ntf.saved_model.save(model, \"/path/to/saved_model\")\n</code></pre> <p>The following files should have been created upon success.</p> SavedModel files <pre><code>/path/to/saved_model\n\u2502\n\u251c\u2500\u2500 variables/\n\u2502   \u251c\u2500\u2500 variables.data-00000-of-00001\n\u2502   \u2514\u2500\u2500 variables.index\n\u2502\n\u251c\u2500\u2500 assets/  # likely empty\n\u2502\n\u251c\u2500\u2500 fingerprint.pb\n\u2502\n\u2514\u2500\u2500 saved_model.pb\n</code></pre>"},{"location":"inference/tensorflow_aot.html#model-compatibility","title":"Model compatibility","text":"<p>Before the actual compilation, you can check whether your model contains any operation that is not XLA/AOT compatible. For this, simply run</p> cmsml_check_aot_compatibility /path/to/saved_model --devices cpu...cpu: all ops compatible <p>and check its output. If you are interested in the full list of operations that are available (independent of your model), append <code>--table</code> to the command.</p> Full output <pre><code>&gt; cmsml_check_aot_compatibility /path/to/saved_model --devices cpu\n\n+----------------+-------+\n| Operation      | cpu   |\n+================+=======+\n| AddV2          | yes   |\n+----------------+-------+\n| BiasAdd        | yes   |\n+----------------+-------+\n| Const          | yes   |\n+----------------+-------+\n| Identity       | yes   |\n+----------------+-------+\n| MatMul         | yes   |\n+----------------+-------+\n| Mul            | yes   |\n+----------------+-------+\n| ReadVariableOp | yes   |\n+----------------+-------+\n| Rsqrt          | yes   |\n+----------------+-------+\n| Softmax        | yes   |\n+----------------+-------+\n| Sub            | yes   |\n+----------------+-------+\n| Tanh           | yes   |\n+----------------+-------+\n\ncpu: all ops compatible\n</code></pre>"},{"location":"inference/tensorflow_aot.html#aot-compilation","title":"AOT compilation","text":"<p>The compilation of the model requires quite a few configuration options as the process that generates code is quite flexible. Therefore, this step requires a configuration file in either yaml of json format. An example is given below.</p> aot_config.yaml <pre><code>model:\n    # name of the model, required\n    name: test\n\n    # version of the model, required\n    version: \"1.0.0\"\n\n    # location of the saved_model directory, resolved relative to this file,\n    # defaults to \"./saved_model\", optional\n    saved_model: ./saved_model\n\n    # serving key, defaults to \"serving_default\", optional\n    serving_key: serving_default\n\n    # author information, optional\n    author: Your Name\n\n    # additional description, optional\n    description: Some test model\n\ncompilation:\n    # list of batch sizes to compile, required\n    batch_sizes: [1, 2, 4]\n\n    # list of TF_XLA_FLAGS (for the TF -&gt; XLA conversion), optional\n    tf_xla_flags: []\n\n    # list of XLA_FLAGS (for the XLA optimization itself), optional\n    xla_flags: []\n</code></pre> <p>An additional example can be found here.</p> <p>With that, we can initiate the compilation process.</p> cms_tfaot_compile \\   --aot-config aot_config.yaml \\   --output-directory \"${CMSSW_BASE}/tfaot/test\" \\   --devsaved model at '/tmp/tmpb2qnby72'compiling for batch size 1compiling for batch size 2compiling for batch size 4successfully AOT compiled model 'test' for batch sizes: 1,2,4 <p>Upon success, all generated files can be found in <code>$CMSSW_BASE/tfaot/test</code> and should look like indicated below.</p> Generated files <pre><code>${CMSSW_BASE}/tfaot/test\n\u2502\n\u251c\u2500\u2500 lib/\n\u2502   \u251c\u2500\u2500 test_bs1.o        # object file compiled for batch size 1\n\u2502   \u251c\u2500\u2500 test_bs2.o        # for batch size 2\n\u2502   \u2514\u2500\u2500 test_bs4.o        # for batch size 4\n\u2502\n\u251c\u2500\u2500 include/\n\u2502   \u2514\u2500\u2500 tfaot-model-test\n\u2502       \u251c\u2500\u2500 test_bs1.h    # header file generated for batch size 1\n\u2502       \u251c\u2500\u2500 test_bs2.h    # for batch size 2\n\u2502       \u251c\u2500\u2500 test_bs4.h    # for batch size 4\n\u2502       \u2514\u2500\u2500 model.h       # entry point that should be included by CMSSW plugins\n\u2502\n\u2514\u2500\u2500 tfaot-model-test.xml  # tool file that sets up your scram environment\n</code></pre> <p>Note that the name of the model is injected into <code>tfaot-model-NAME</code>, defining the names of the include directory as well as the tool file (xml).</p> <p>At the end, the <code>cms_tfaot_compile</code> command prints instructions on how to proceed. They are described in more detail below.</p>"},{"location":"inference/tensorflow_aot.html#inference-in-cmssw","title":"Inference in CMSSW","text":"<p>The model integration and inference can be achieved in five steps. Please find the full code example below. Also, take a look at the AOT interface unit tests to get a better idea of the API.</p>"},{"location":"inference/tensorflow_aot.html#1-tool-setup","title":"1. Tool setup","text":"<p>As printed in the instructions at the end of <code>cms_tfaot_compile</code>, you should register the compiled model as a software dependency via scram. For this reason, a custom tool file was created that you need to <code>setup</code>.</p> scram setup ${CMSSW_BASE}/tfaot/test/tfaot-model-test.xml"},{"location":"inference/tensorflow_aot.html#2-cmssw-module-setup","title":"2. CMSSW module setup","text":"<p>In the next step, you should instruct your <code>BuildFile.xml</code> (in <code>SUBSYSTEM/MODULE/plugins/BuildFile.xml</code> if you are writing a CMSSW plugin, or in <code>SUBSYSTEM/MODULE/BuildFile.xml</code> if you intend to use the model inside <code>src/</code> or <code>interface/</code> directory of your module) to depend on the new tool. This could like like the following.</p> <pre><code>&lt;use name=\"tfaot-model-test\" /&gt;\n\n&lt;export&gt;\n    &lt;lib name=\"1\" /&gt;\n&lt;/export&gt;\n</code></pre>"},{"location":"inference/tensorflow_aot.html#3-includes","title":"3. Includes","text":"<p>In your source file, include the generated header file as well as the AOT interface.</p> <pre><code>#include \"PhysicsTools/TensorFlowAOT/interface/Model.h\"\n#include \"tfaot-model-test/model.h\"\n// further framework includes ...\n</code></pre>"},{"location":"inference/tensorflow_aot.html#4-initialize-objects","title":"4. Initialize objects","text":"<p>Your model is accessible through a type named <code>tfaot_model::NAME</code>. You can access it by initializing a <code>tfaot::Model&lt;T&gt;</code> instance, providing your type as a template parameter.</p> <pre><code>auto model = tfaot::Model&lt;tfaot_model::test&gt;();\n</code></pre> <p>When used in a plugin such as an <code>EDProducer</code>, you should create one model instance per plugin instance, that is, not as part of a <code>GlobalCache</code> but as a normal instance member. As shown below, the <code>model.run()</code> call is not <code>const</code> and thus, not thread-safe. The memory overhead is minimal though, as the model is a just thin wrapper around the compiled machine code.</p> <p>At this point, one would like to configure the dynamic batching strategies on the model. However, this is optional and a performance optimization measure, and therefore shown later.</p>"},{"location":"inference/tensorflow_aot.html#5-inference","title":"5. Inference","text":"<pre><code>// define input for a batch size of 1\n// (just a single float input, with shape 1x4)\ntfaot::FloatArrays input = { {0, 1, 2, 3} };\n\n// define output\n// (just a single float output, which will shape 1x2)\ntfaot::FloatArrays output;\n\n// evaluate the model\n// the template arguments of run() correspond to the types of the outputs\n// that are \"tied\" the \"1\" denote the batch size of 1\nstd::tie(output) = model.run&lt;tfaot::FloatArrays&gt;(1, input);\n\n// print output\nstd::cout &lt;&lt; \"output[0]: \" &lt;&lt; output[0][0] &lt;&lt; \", \" &lt;&lt; output[0][1] &lt;&lt; std::endl;\n// -&gt; \"output[0]: 0.648093, 0.351907\"\n</code></pre> <p>Since we, by intention, do not have access to TensorFlow's <code>tf::Tensor</code> objects, the types <code>tfaot::*Arrays</code> with <code>*</code> being <code>Bool</code>, <code>Int32</code>, <code>Int64</code>, <code>Float</code>, or <code>Double</code> are nested <code>std::vector&lt;std::vector&lt;T&gt;&gt;</code> objects. This means that access is simple, but please be aware of cache locality when filling input values.</p> <p>The <code>model.run()</code> method is variadic in its inputs and outputs, both for the numbers and types of arguments. This means that a model with two inputs, <code>float</code> and <code>bool</code>, and two outputs, <code>double</code> and <code>int32_t</code>, would be called like this.</p> <pre><code>tfaot::FloatArrays in1 = ...;\ntfaot::BoolArrays in2 = ...;\ntfaot::DoubleArrays out1;\ntfaot::Int32Arrays out2;\n\nstd::tie(out1, out2) = model.run&lt;tfaot::DoubleArrays, tfaot::Int32Arrays&gt;(\n    1, in1, in2);\n</code></pre>"},{"location":"inference/tensorflow_aot.html#full-example","title":"Full example","text":"Click to expand <p>The example assumes the following directory structure:</p> <pre><code>MySubsystem/MyModule/\n\u2502\n\u251c\u2500\u2500 plugins/\n\u2502   \u251c\u2500\u2500 MyPlugin.cpp\n\u2502   \u2514\u2500\u2500 BuildFile.xml\n\u2502\n\u2514\u2500\u2500 test/\n    \u2514\u2500\u2500 my_plugin_cfg.py\n</code></pre> plugins/MyPlugin.cppplugins/BuildFile.xmltest/my_plugin_cfg.py <pre><code>/*\n * Example plugin to demonstrate the inference with TensorFlow AOT.\n */\n\n#include &lt;memory&gt;\n\n#include \"FWCore/Framework/interface/Event.h\"\n#include \"FWCore/Framework/interface/Frameworkfwd.h\"\n#include \"FWCore/Framework/interface/MakerMacros.h\"\n#include \"FWCore/Framework/interface/stream/EDAnalyzer.h\"\n#include \"FWCore/ParameterSet/interface/ParameterSet.h\"\n#include \"PhysicsTools/TensorFlowAOT/interface/Model.h\"\n\n// include the header of the compiled model\n#include \"tfaot-model-test/model.h\"\n\nclass MyPlugin : public edm::stream::EDAnalyzer&lt;&gt; {\npublic:\n  explicit MyPlugin(const edm::ParameterSet&amp;);\n  ~MyPlugin(){};\n\n  static void fillDescriptions(edm::ConfigurationDescriptions&amp;);\n\nprivate:\n  void beginJob(){};\n  void analyze(const edm::Event&amp;, const edm::EventSetup&amp;);\n  void endJob(){};\n\n  std::vector&lt;std::string&gt; batchRuleStrings_;\n\n  // aot model\n  tfaot::Model&lt;tfaot_model::test&gt; model_;\n};\n\nvoid MyPlugin::fillDescriptions(edm::ConfigurationDescriptions&amp; descriptions) {\n  // defining this function will lead to a *_cfi file being generated when compiling\n  edm::ParameterSetDescription desc;\n  desc.add&lt;std::vector&lt;std::string&gt;&gt;(\"batchRules\");\n  descriptions.addWithDefaultLabel(desc);\n}\n\nMyPlugin::MyPlugin(const edm::ParameterSet&amp; config)\n    : batchRuleStrings_(config.getParameter&lt;std::vector&lt;std::string&gt;&gt;(\"batchRules\")) {\n  // register batch rules\n  for (const auto&amp; rule : batchRuleStrings_) {\n    model_.setBatchRule(rule);\n  }\n}\n\nvoid MyPlugin::analyze(const edm::Event&amp; event, const edm::EventSetup&amp; setup) {\n  // define input for a batch size of 1\n  // (just a single float input, with shape 1x4)\n  tfaot::FloatArrays input = { {0, 1, 2, 3} };\n\n  // define output\n  // (just a single float output, which will shape 1x2)\n  tfaot::FloatArrays output;\n\n  // evaluate the model\n  // the template arguments of run() correspond to the types of the outputs\n  // that are \"tied\" the \"1\" denote the batch size of 1\n  std::tie(output) = model_.run&lt;tfaot::FloatArrays&gt;(1, input);\n\n  // print output\n  std::cout &lt;&lt; \"output[0]: \" &lt;&lt; output[0][0] &lt;&lt; \", \" &lt;&lt; output[0][1] &lt;&lt; std::endl;\n  // -&gt; \"output[0]: 0.648093, 0.351907\"\n}\n\nDEFINE_FWK_MODULE(MyPlugin);\n</code></pre> <pre><code>&lt;use name=\"FWCore/Framework\" /&gt;\n&lt;use name=\"FWCore/PluginManager\" /&gt;\n&lt;use name=\"FWCore/ParameterSet\" /&gt;\n\n&lt;use name=\"PhysicsTools/TensorFlowAOT\" /&gt;\n&lt;use name=\"tfaot-model-test\"/&gt;\n\n&lt;flags EDM_PLUGIN=\"1\" /&gt;\n</code></pre> <pre><code># coding: utf-8\n\nimport os\n\nimport FWCore.ParameterSet.Config as cms\nfrom FWCore.ParameterSet.VarParsing import VarParsing\n\n\n# get the data/ directory\nthisdir = os.path.dirname(os.path.abspath(__file__))\ndatadir = os.path.join(os.path.dirname(thisdir), \"data\")\n\n# setup minimal options\noptions = VarParsing(\"python\")\noptions.setDefault(\"inputFiles\", \"root://xrootd-cms.infn.it//store/mc/RunIISummer20UL18MiniAODv2/GluGluToHHTo2G2Tau_node_cHHH1_TuneCP5_13TeV-powheg-pythia8/MINIAODSIM/106X_upgrade2018_realistic_v16_L1v1-v2/40000/871B714B-0AA3-3342-B56C-6DC0E634593A.root\")  # noqa\noptions.parseArguments()\n\n# define the process to run\nprocess = cms.Process(\"TEST\")\n\n# minimal configuration\nprocess.load(\"FWCore.MessageService.MessageLogger_cfi\")\nprocess.MessageLogger.cerr.FwkReport.reportEvery = 1\nprocess.maxEvents = cms.untracked.PSet(\n    input=cms.untracked.int32(10),\n)\nprocess.source = cms.Source(\n    \"PoolSource\",\n    fileNames=cms.untracked.vstring(options.inputFiles),\n)\n\n# process options\nprocess.options = cms.untracked.PSet(\n    allowUnscheduled=cms.untracked.bool(True),\n    wantSummary=cms.untracked.bool(True),\n)\n\n# setup MyPlugin by loading the auto-generated cfi (see MyPlugin.fillDescriptions)\nprocess.load(\"MySubsystem.MyModule.myPlugin_cfi\")\n# register three batch rules\n# - add 1+1+1 for batch size 3\n# - add 4+1 for batch size 5\n# - add 4+4 for batch size 6, using a padding of 2 for the second call\nprocess.myPlugin.batchRules = cms.vstring([\"3:1,1,1\", \"5:4,1\", \"6:4,4\"])\n\n# define what to run in the path\nprocess.p = cms.Path(process.myPlugin)\n</code></pre>"},{"location":"inference/tensorflow_aot.html#dynamic-batching-strategies","title":"Dynamic batching strategies","text":"<p>Compiled models are specialized for a single batch size with buffers for inputs, intermediate layer values, and outputs being statically allocated. As explained earlier, the <code>tfoat::Model&lt;T&gt;</code> class (with <code>T</code> being the wrapper over all batch-size-specialized, compiled models) provides a mechanism that emulates dynamic batching. More details were presented at a recent Core Software meeting contribution.</p>"},{"location":"inference/tensorflow_aot.html#batch-rules-and-strategies","title":"Batch rules and strategies","text":"<p>Internally, <code>tfoat::Model&lt;T&gt;</code> distinguishes between the target batch size, and composite batch sizes. The former is the batch size that the model should emulate, and the latter are the batch sizes for which the model was compiled.</p> <p><code>BatchRule</code>'s define how a target batch size should be emulated.</p> <ul> <li>A batch rule of <code>5:1,4</code> (in its string representation) would state that the target batch size of 5 should be emulated by stitching together the results of batch sizes 1 and 4.</li> <li>A batch rule of <code>5:2,4</code> would mean that the models compiled for batch sizes 2 and 4 are evaluated, with the latter being zero-padded by 1.</li> </ul> <p>The <code>BatchStrategy</code> of a model defines the set of <code>BatchRule</code>'s that are currently active.</p>"},{"location":"inference/tensorflow_aot.html#default-rules-and-optimization","title":"Default rules and optimization","text":"<p>There is no general, a-priory choice of batch sizes that works best for all models. Instead, the optimal selection of batch sizes and batch rules depends on the model and the input data, and should be determined through profiling (e.g. using the MLProf project). However, the following guidelines can be used as a starting point.</p> <ul> <li>Unlike for other batch sizes, models compiled for a batch size of 1 (<code>model1</code>) are subject to an additional, internal optimization step due to reductions to one-dimensional arrays and operations. It is therefore recommended to always include a batch size of 1.</li> <li>For higher batch sizes, (single core) vectorization can be exploited, which can lead to a significant speed-up.</li> <li>The exact break-even points are model dependent. This means that for a target batch size of, say, 8 it could be more performant to evaluate <code>model1</code> 8 times than to evaluate <code>model8</code> once, <code>model4</code> twice or <code>model2</code> four times. If this is the case, the optimization available for <code>model1</code> (taking into account the stitching overhead!) outweighs the vectorization gains entailed by e.g. <code>model8</code>.</li> </ul> <p>Also, it should be noted that not every possible target batch size must be configured through a batch rule. In fact, the <code>tfoat::Model&lt;T&gt;</code> does not require any batch rule to be pre-defined as an algorithm is in place that, for yet unseen batch sizes, constructs default batch rules.</p> <ul> <li>If the target batch size matches one of the available, composite batch sizes, this size is used as is.</li> <li>Otherwise, the smallest available, composite batch size is repeated until the target batch size, or a larger value is reached. If the value is larger, zero-padding is applied to the last evaluation.</li> </ul> <p>For central, performance-critical models, an optimization study should be conducted to determine the optimal batch sizes and rules.</p>"},{"location":"inference/tensorflow_aot.html#xla-optimization","title":"XLA optimization","text":"<p>As described above, the conversion from a TensorFlow graph to compiled machine code happens in two stages which can be separately optimized through various flags. Both sets of flags can be controlled through the <code>aot_config.yaml</code>.</p> <ul> <li>The TF-XLA boundary is configured through so-called <code>tf_xla_flags</code> in the <code>compilation</code> settings. Example: <code>tf_xla_flags: [\"--tf_xla_min_cluster_size=4\"]</code>, The full list of possible flags can be found here.</li> <li>The XLA optimizer and code generator can be controlled through <code>xla_flags</code> in the <code>compilation</code> settings. Example: <code>xla_flags: [\"--xla_cpu_enable_fast_math=true\"]</code>. The full list of possible flags can be found here.</li> </ul>"},{"location":"inference/tensorflow_aot.html#production-workflow","title":"Production workflow","text":"<p>If you intend to integrate an AOT compiled model into CMSSW production code, you need to account for the differences with respect to deployment using other direct inference methods (e.g. TF C++ or ONNX). Since the model itself is represented as compiled code rather than an external model file that can be read and interpreted at runtime, production models must be registered as a package in CMSDIST. The components are shown below.</p> <pre><code>graph LR\n    CMSDATA --&amp;nbsp;provides SavedModel to&amp;nbsp;--&gt; CMSDIST\n    CMSDIST --&amp;nbsp;compiles model for&amp;nbsp;--&gt; CMSSW</code></pre> <p>The integration process takes place in four steps.</p> <ol> <li>Push your model (in <code>SavedModel</code> format) to a central CMSDATA repository.</li> <li>Create a new spec in CMSDIST (example), named <code>tfaot-model-NAME.spec</code>. This spec file should define two variables.<ul> <li><code>%{aot_config}</code>: The path to an AOT configuration file (required).</li> <li><code>%{aot_source}</code>: A source to fetch, containing the model to compile (optional). When provided through a CMSDATA repository, you would typically delcare it as a build requirement via <code>BuildRequires: data-NAME</code> and just define <code>%{aot_config}</code>. See <code>tfaot-compile.file</code> for more info.</li> </ul> </li> <li>Add your spec to the list of <code>tfaot</code> models.</li> <li>After integration into CMSDIST, a tool named <code>tfaot-model-NAME</code> will be provided centrally and the instructions for setting it up and using the compiled model in your plugin are identical to the ones described above.</li> </ol>"},{"location":"inference/tensorflow_aot.html#links-and-further-reading","title":"Links and further reading","text":"<ul> <li><code>cmsml</code> package</li> <li><code>cms-tfaot</code> package</li> <li>MLProf project</li> <li>CMSSW<ul> <li>TensorFlowAOT interface</li> <li>CMSSW process options</li> <li>Talk at Core Software Meeting</li> </ul> </li> <li>TensorFlow<ul> <li>TensorFlow 2 tutorial</li> <li>TensorFlow XLA documentation</li> <li><code>TF_XLA</code> optimization options</li> <li><code>XLA</code> optimization options</li> <li>XLA overview (by NVIDIA)</li> </ul> </li> <li>Keras<ul> <li>API</li> </ul> </li> </ul> <p>Authors: Marcel Rieger, Bogdan Wiederspan</p>"},{"location":"inference/tfaas.html","title":"TFaaS","text":""},{"location":"inference/tfaas.html#tensorflow-as-a-service","title":"TensorFlow as a Service","text":"<p>TensorFlow as a Service (TFaas) was developed as a general purpose service which can be deployed on any infrastruction from personal laptop, VM, to cloud infrastructure, inculding kubernetes/docker based ones. The main repository contains all details about the service, including install, end-to-end example, and demo.</p> <p>For CERN users we already deploy TFaaS on the following URL: https://cms-tfaas.cern.ch</p> <p>It can be used by CMS members using any HTTP based client. For example, here is a basic access from curl client: <pre><code>curl -k https://cms-tfaas.cern.ch/models\n[\n  {\n    \"name\": \"luca\",\n    \"model\": \"prova.pb\",\n    \"labels\": \"labels.csv\",\n    \"options\": null,\n    \"inputNode\": \"dense_1_input\",\n    \"outputNode\": \"output_node0\",\n    \"description\": \"\",\n    \"timestamp\": \"2021-10-22 14:04:52.890554036 +0000 UTC m=+600537.976386186\"\n  },\n  {\n    \"name\": \"test_luca_1024\",\n    \"model\": \"saved_model.pb\",\n    \"labels\": \"labels.txt\",\n    \"options\": null,\n    \"inputNode\": \"dense_input_1:0\",\n    \"outputNode\": \"dense_3/Sigmoid:0\",\n    \"description\": \"\",\n    \"timestamp\": \"2021-10-22 14:04:52.890776518 +0000 UTC m=+600537.976608672\"\n  },\n  {\n    \"name\": \"vk\",\n    \"model\": \"model.pb\",\n    \"labels\": \"labels.txt\",\n    \"options\": null,\n    \"inputNode\": \"dense_1_input\",\n    \"outputNode\": \"output_node0\",\n    \"description\": \"\",\n    \"timestamp\": \"2021-10-22 14:04:52.890903234 +0000 UTC m=+600537.976735378\"\n  }\n]\n</code></pre></p> <p>The following APIs are available: - <code>/upload</code> to push your favorite TF model to TFaaS server either for Form or   as tar-ball bundle, see examples below - <code>/delete</code> to delete your TF model from TFaaS server - <code>/models</code> to view existing TF models on TFaaS server - <code>/predict/json</code> to serve TF model predictions in JSON data-format - <code>/predict/proto</code> to serve TF model predictions in ProtoBuffer data-format - <code>/predict/image</code> to serve TF model predictions forimages in JPG/PNG formats</p>"},{"location":"inference/tfaas.html#look-up-your-favorite-model","title":"\u2780 look-up your favorite model","text":"<p>You may easily look-up your ML model from TFaaS server, e.g. <pre><code>curl https://cms-tfaas.cern.ch/models\n# possible output may looks like this\n[\n  {\n    \"name\": \"luca\",\n    \"model\": \"prova.pb\",\n    \"labels\": \"labels.csv\",\n    \"options\": null,\n    \"inputNode\": \"dense_1_input\",\n    \"outputNode\": \"output_node0\",\n    \"description\": \"\",\n    \"timestamp\": \"2021-11-08 20:07:18.397487027 +0000 UTC m=+2091094.457327022\"\n  }\n  ...\n]\n</code></pre> The provided <code>/models</code> API will list the name of the model, its file name, labels file, possible options, input and output nodes, description and proper timestamp when it was added to TFaaS repository</p>"},{"location":"inference/tfaas.html#upload-your-tf-model-to-tfaas-server","title":"\u2781 upload your TF model to TFaaS server","text":"<p>If your model is not in TFaaS server you may easily add it as following: <pre><code># example of image based model upload\ncurl -X POST https://cms-tfaas.cern.ch/upload\n-F 'name=ImageModel' -F 'params=@/path/params.json'\n-F 'model=@/path/tf_model.pb' -F 'labels=@/path/labels.txt'\n\n# example of TF pb file upload\ncurl -s -X POST https://cms-tfaas.cern.ch/upload \\\n    -F 'name=vk' -F 'params=@/path/params.json' \\\n    -F 'model=@/path/model.pb' -F 'labels=@/path/labels.txt'\n\n# example of bundle upload produce with Keras TF\n# here is our saved model area\nls model\nassets         saved_model.pb variables\n# we can create tarball and upload it to TFaaS via bundle end-point\ntar cfz model.tar.gz model\ncurl -X POST -H \"Content-Encoding: gzip\" \\\n             -H \"content-type: application/octet-stream\" \\\n             --data-binary @/path/models.tar.gz https://cms-tfaas.cern.ch/upload\n</code></pre></p>"},{"location":"inference/tfaas.html#get-your-predictions","title":"\u2782 get your predictions","text":"<p>Finally, you may obtain predictions from your favorite model by using proper API, e.g. <pre><code># obtain predictions from your ImageModel\ncurl https://cms-tfaas.cern.ch/image -F 'image=@/path/file.png' -F 'model=ImageModel'\n\n# obtain predictions from your TF based model\ncat input.json\n{\"keys\": [...], \"values\": [...], \"model\":\"model\"}\n\n# call to get predictions from /json end-point using input.json\ncurl -s -X POST -H \"Content-type: application/json\" \\\n    -d@/path/input.json https://cms-tfaas.cern.ch/json\n</code></pre></p> <p>Fore more information please visit curl client page.</p>"},{"location":"inference/tfaas.html#tfaas-interface","title":"TFaaS interface","text":"<p>Clients communicate with TFaaS via HTTP protocol. See examples for Curl, Python and C++ clients.</p>"},{"location":"inference/tfaas.html#tfaas-benchmarks","title":"TFaaS benchmarks","text":"<p>Benchmark results on CentOS, 24 cores, 32GB of RAM serving DL NN with 42x128x128x128x64x64x1x1 architecture (JSON and ProtoBuffer formats show similar performance): - 400 req/sec for 100 concurrent clients, 1000 requests in total - 480 req/sec for 200 concurrent clients, 5000 requests in total</p> <p>For more information please visit bencmarks page.</p>"},{"location":"inference/xgboost.html","title":"Direct inference with XGBoost","text":""},{"location":"inference/xgboost.html#general","title":"General","text":"<p>XGBoost is avaliable (at least) since CMSSW_9_2_4 cmssw#19377.</p> <p>In CMSSW environment, XGBoost can be used via its Python API.</p> <p>For UL era, there are different verisons available for different <code>SCRAM_ARCH</code>:</p> <ol> <li> <p>For <code>slc7_amd64_gcc700</code> and above, ver.0.80 is available.</p> </li> <li> <p>For <code>slc7_amd64_gcc900</code> and above, ver.1.3.3 is available.</p> </li> <li> <p>Please note that different major versions have different behavior( See Caveat Session).</p> </li> </ol>"},{"location":"inference/xgboost.html#existing-examples","title":"Existing Examples","text":"<p>There are some existing good examples of using XGBoost under CMSSW, as listed below:</p> <ol> <li> <p>Offical sample for testing the integration of XGBoost library with CMSSW.</p> </li> <li> <p>Useful codes created by Dr. Huilin Qu for inference with existing trained model.</p> </li> <li> <p>C/C++ Interface for inference with existing trained model.</p> </li> </ol> <p>We will provide examples for both C/C++ interface and python interface of XGBoost under CMSSW environment.</p>"},{"location":"inference/xgboost.html#example-classification-of-points-from-joint-gaussian-distribution","title":"Example: Classification of points from joint-Gaussian distribution.","text":"<p>In this specific example, you will use XGBoost to classify data points generated from two 8-dimension joint-Gaussian distribution. </p> Feature Index 0 1 2 3 4 5 6 7 \u03bc<sub>1</sub> 1 2 3 4 5 6 7 8 \u03bc<sub>2</sub> 0 1.9 3.2 4.5 4.8 6.1 8.1 11 \u03c3<sub>\u00bd</sub> =  \u03c3 1 1 1 1 1 1 1 1 |\u03bc<sub>1</sub> - \u03bc<sub>2</sub>| / \u03c3 1 0.1 0.2 0.5 0.2 0.1 1.1 3 <p>All generated data points for train(1:10000,2:10000) and test(1:1000,2:1000) are stored as <code>Train_data.csv</code>/<code>Test_data.csv</code>.</p>"},{"location":"inference/xgboost.html#preparing-model","title":"Preparing Model","text":"<p>The training process of a XGBoost model can be done outside of CMSSW. We provide a python script for illustration.  <pre><code># importing necessary models\nimport numpy as np\nimport pandas as pd \nfrom xgboost import XGBClassifier # Or XGBRegressor for Logistic Regression\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n# specify parameters via map\nparam = {'n_estimators':50}\nxgb = XGBClassifier(param)\n\n# using Pandas.DataFrame data-format, other available format are XGBoost's DMatrix and numpy.ndarray\n\ntrain_data = pd.read_csv(\"path/to/the/data\") # The training dataset is code/XGBoost/Train_data.csv\n\ntrain_Variable = train_data['0', '1', '2', '3', '4', '5', '6', '7']\ntrain_Score = train_data['Type'] # Score should be integer, 0, 1, (2 and larger for multiclass)\n\ntest_data = pd.read_csv(\"path/to/the/data\") # The testing dataset is code/XGBoost/Test_data.csv\n\ntest_Variable = test_data['0', '1', '2', '3', '4', '5', '6', '7']\ntest_Score = test_data['Type']\n\n# Now the data are well prepared and named as train_Variable, train_Score and test_Variable, test_Score.\n\nxgb.fit(train_Variable, train_Score) # Training\n\nxgb.predict(test_Variable) # Outputs are integers\n\nxgb.predict_proba(test_Variable) # Output scores , output structre: [prob for 0, prob for 1,...]\n\nxgb.save_model(\"\\Path\\To\\Where\\You\\Want\\ModelName.model\") # Saving model\n</code></pre> The saved model <code>ModelName.model</code> is thus available for python and C/C++ api to load. Please use the XGBoost major version consistently (see Caveat).</p> <p>While training with data from different datasets, proper treatment of weights are necessary for better model performance. Please refer to Official Recommendation for more details.</p>"},{"location":"inference/xgboost.html#cc-usage-with-cmssw","title":"C/C++ Usage with CMSSW","text":"<p>To use a saved XGBoost model with C/C++ code, it is convenient to use the <code>XGBoost's offical C api</code>. Here we provide a simple example as following.</p>"},{"location":"inference/xgboost.html#module-setup","title":"Module setup","text":"<p>There is no official CMSSW interface for XGBoost while its library are placed in <code>cvmfs</code> of CMSSW. Thus we have to use the raw <code>c_api</code> as well as setting up the library manually.</p> <ol> <li>To run XGBoost's <code>c_api</code> within CMSSW framework, in addition to the following standard setup. <pre><code>export SCRAM_ARCH=\"slc7_amd64_gcc700\" # To use higher version, please switch to slc7_amd64_900\nexport CMSSW_VERSION=\"CMSSW_X_Y_Z\"\n\nsource /cvmfs/cms.cern.ch/cmsset_default.sh\n\ncmsrel \"$CMSSW_VERSION\"\ncd \"$CMSSW_VERSION/src\"\n\ncmsenv\nscram b\n</code></pre> The addtional effort is to add corresponding xml file(s) to <code>$CMSSW_BASE/toolbox$CMSSW_BASE/config/toolbox/$SCRAM_ARCH/tools/selected/</code> for setting up XGBoost.</li> </ol> <ol> <li> <p>For lower version (&lt;1), add two xml files as below.</p> <p><code>xgboost.xml</code> <pre><code> &lt;tool name=\"xgboost\" version=\"0.80\"&gt;\n &lt;lib name=\"xgboost\"/&gt;\n &lt;client&gt;\n    &lt;environment name=\"LIBDIR\" default=\"/cvmfs/cms.cern.ch/$SCRAM_ARCH/external/py2-xgboost/0.80-ikaegh/lib/python2.7/site-packages/xgboost/lib\"/&gt;\n    &lt;environment name=\"INCLUDE\" default=\"/cvmfs/cms.cern.ch/$SCRAM_ARCH/external/py2-xgboost/0.80-ikaegh/lib/python2.7/site-packages/xgboost/include/\"/&gt;\n  &lt;/client&gt;\n  &lt;runtime name=\"ROOT_INCLUDE_PATH\" value=\"$INCLUDE\" type=\"path\"/&gt;\n  &lt;runtime name=\"PATH\" value=\"$INCLUDE\" type=\"path\"/&gt;\n  &lt;use name=\"rabit\"/&gt;\n&lt;/tool&gt;\n</code></pre> <code>rabit.xml</code> <pre><code> &lt;tool name=\"rabit\" version=\"0.80\"&gt;\n   &lt;client&gt;\n     &lt;environment name=\"INCLUDE\" default=\"/cvmfs/cms.cern.ch/$SCRAM_ARCH/external/py2-xgboost/0.80-ikaegh/lib/python2.7/site-packages/xgboost/rabit/include/\"/&gt;\n   &lt;/client&gt;\n   &lt;runtime name=\"ROOT_INCLUDE_PATH\" value=\"$INCLUDE\" type=\"path\"/&gt;\n   &lt;runtime name=\"PATH\" value=\"$INCLUDE\" type=\"path\"/&gt;  \n &lt;/tool&gt;\n</code></pre> Please note that the path in <code>cvmfs</code> is not fixed, one can list all available versions in the <code>py2-xgboost</code> directory and choose one to use.</p> </li> <li> <p>For higher version (&gt;=1), and one xml file</p> <p><code>xgboost.xml</code> <pre><code>&lt;tool name=\"xgboost\" version=\"0.80\"&gt;\n  &lt;lib name=\"xgboost\"/&gt;\n  &lt;client&gt;\n    &lt;environment name=\"LIBDIR\" default=\"/cvmfs/cms.cern.ch/$SCRAM_ARCH/external/xgboost/1.3.3/lib64\"/&gt;\n    &lt;environment name=\"INCLUDE\" default=\"/cvmfs/cms.cern.ch/$SCRAM_ARCH/external/xgboost/1.3.3/include/\"/&gt;\n  &lt;/client&gt;\n  &lt;runtime name=\"ROOT_INCLUDE_PATH\" value=\"$INCLUDE\" type=\"path\"/&gt;\n  &lt;runtime name=\"PATH\" value=\"$INCLUDE\" type=\"path\"/&gt;  \n&lt;/tool&gt;\n</code></pre> Also one has the freedom to choose the available xgboost version inside <code>xgboost</code> directory.</p> </li> </ol> <ol> <li> <p>After adding xml file(s), the following commands should be executed for setting up.</p> <ol> <li>For lower version (&lt;1), use  <pre><code>scram setup rabit\nscram setup xgboost\n</code></pre></li> <li>For higher version (&gt;=1), use <pre><code>scram setup xgboost\n</code></pre></li> </ol> </li> <li> <p>For using XGBoost as a plugin of CMSSW, it is necessary to add <pre><code>&lt;use name=\"xgboost\"/&gt;\n&lt;flags EDM_PLUGIN=\"1\"/&gt;\n</code></pre> in your <code>plugins/BuildFile.xml</code>. If you are using the interface inside the <code>src/</code> or <code>interface/</code> directory of your module, make sure to create a global <code>BuildFile.xml</code> file next to theses directories, containing (at least): <pre><code>&lt;use name=\"xgboost\"/&gt;\n&lt;export&gt;\n  &lt;lib   name=\"1\"/&gt;\n&lt;/export&gt;\n</code></pre></p> </li> <li> <p>The <code>libxgboost.so</code> would be too large to load for <code>cmsRun</code> job, please using the following commands for pre-loading: <pre><code>export LD_PRELOAD=$CMSSW_BASE/external/$SCRAM_ARCH/lib/libxgboost.so\n</code></pre></p> </li> </ol>"},{"location":"inference/xgboost.html#basic-usage-of-c-api","title":"Basic Usage of C API","text":"<p>In order to use <code>c_api</code> of XGBoost to load model and operate inference, one should construct necessaries objects:</p> <ol> <li> <p>Files to include <pre><code>#include &lt;xgboost/c_api.h&gt; \n</code></pre></p> </li> <li> <p><code>BoosterHandle</code>: worker of XGBoost <pre><code>// Declare Object\nBoosterHandle booster_;\n// Allocate memory in C style\nXGBoosterCreate(NULL,0,&amp;booster_);\n// Load Model\nXGBoosterLoadModel(booster_,model_path.c_str()); // second argument should be a const char *.\n</code></pre></p> </li> <li> <p><code>DMatrixHandle</code>: handle to dmatrix, the data format of XGBoost <pre><code>float TestData[2000][8] // Suppose 2000 data points, each data point has 8 dimension\n// Assign data to the \"TestData\" 2d array ... \n// Declare object\nDMatrixHandle data_;\n// Allocate memory and use external float array to initialize\nXGDMatrixCreateFromMat((float *)TestData,2000,8,-1,&amp;data_); // The first argument takes in float * namely 1d float array only, 2nd &amp; 3rd: shape of input, 4th: value to replace missing ones\n</code></pre></p> </li> <li> <p><code>XGBoosterPredict</code>: function for inference <pre><code>bst_ulong outlen; // bst_ulong is a typedef of unsigned long\nconst float *f; // array to store predictions\nXGBoosterPredict(booster_,data_,0,0,&amp;out_len,&amp;f);// lower version API\n// XGBoosterPredict(booster_,data_,0,0,0,&amp;out_len,&amp;f);// higher version API\n/*\nlower version (ver.&lt;1) API\nXGB_DLL int XGBoosterPredict(   \nBoosterHandle   handle,\nDMatrixHandle   dmat,\nint     option_mask, // 0 for normal output, namely reporting scores\nint     training, // 0 for prediction\nbst_ulong *     out_len,\nconst float **  out_result \n)\n\nhigher version (ver.&gt;=1) API\nXGB_DLL int XGBoosterPredict(   \nBoosterHandle   handle,\nDMatrixHandle   dmat,\nint     option_mask, // 0 for normal output, namely reporting scores\nint ntree_limit, // how many trees for prediction, set to 0 means no limit\nint     training, // 0 for prediction\nbst_ulong *     out_len,\nconst float **  out_result \n)\n*/\n</code></pre></p> </li> </ol>"},{"location":"inference/xgboost.html#full-example","title":"Full Example","text":"Click to expand full example <p>The example assumes the following directory structure:</p> <p><pre><code>MySubsystem/MyModule/\n\u2502\n\u251c\u2500\u2500 plugins/\n\u2502   \u251c\u2500\u2500 XGBoostExample.cc\n\u2502   \u2514\u2500\u2500 BuildFile.xml\n\u2502\n\u251c\u2500\u2500 python/\n\u2502   \u2514\u2500\u2500 xgboost_cfg.py\n\u2502\n\u251c\u2500\u2500 toolbox/ (storing necessary xml(s) to be copied to toolbox/ of $CMSSW_BASE)\n\u2502   \u2514\u2500\u2500 xgboost.xml\n\u2502   \u2514\u2500\u2500 rabit.xml (lower version only)\n\u2502\n\u2514\u2500\u2500 data/\n    \u2514\u2500\u2500 Test_data.csv\n    \u2514\u2500\u2500 lowVer.model / highVer.model \n</code></pre> Please also note that in order to operate inference in an event-by-event way, please put <code>XGBoosterPredict</code> in <code>analyze</code> rather than <code>beginJob</code>.</p> plugins/XGBoostExample.cc for lower version XGBoostplugins/BuildFile.xml for lower version XGBoostpython/xgboost_cfg.py for lower version XGBoostplugins/XGBoostExample.cc for higher version XGBoostplugins/BuildFile.xml for higher version XGBoostpython/xgboost_cfg.py for higher version XGBoost <pre><code>// -*- C++ -*-\n//\n// Package:    XGB_Example/XGBoostExample\n// Class:      XGBoostExample\n//\n/**\\class XGBoostExample XGBoostExample.cc XGB_Example/XGBoostExample/plugins/XGBoostExample.cc\n\n Description: [one line class summary]\n\n Implementation:\n     [Notes on implementation]\n*/\n//\n// Original Author:  Qian Sitian\n//         Created:  Sat, 19 Jun 2021 08:38:51 GMT\n//\n//\n\n\n// system include files\n#include &lt;memory&gt;\n\n// user include files\n#include \"FWCore/Framework/interface/Frameworkfwd.h\"\n#include \"FWCore/Framework/interface/one/EDAnalyzer.h\"\n\n#include \"FWCore/Framework/interface/Event.h\"\n#include \"FWCore/Framework/interface/MakerMacros.h\"\n\n#include \"FWCore/ParameterSet/interface/ParameterSet.h\"\n #include \"FWCore/Utilities/interface/InputTag.h\"\n #include \"DataFormats/TrackReco/interface/Track.h\"\n #include \"DataFormats/TrackReco/interface/TrackFwd.h\"\n\n#include &lt;xgboost/c_api.h&gt;\n#include &lt;vector&gt;\n#include &lt;tuple&gt;\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;sstream&gt;\n\nusing namespace std;\n\nvector&lt;vector&lt;double&gt;&gt; readinCSV(const char* name){\n    auto fin = ifstream(name);\n    vector&lt;vector&lt;double&gt;&gt; floatVec;\n    string strFloat;\n    float fNum;\n    int counter = 0;\n    getline(fin,strFloat);\n    while(getline(fin,strFloat))\n    {\n        std::stringstream  linestream(strFloat);\n        floatVec.push_back(std::vector&lt;double&gt;());\n        while(linestream&gt;&gt;fNum)\n        {\n            floatVec[counter].push_back(fNum);\n            if (linestream.peek() == ',')\n            linestream.ignore();\n        }\n        ++counter;\n    }\n    return floatVec;\n}\n\n//\n// class declaration\n//\n\n// If the analyzer does not use TFileService, please remove\n// the template argument to the base class so the class inherits\n// from  edm::one::EDAnalyzer&lt;&gt;\n// This will improve performance in multithreaded jobs.\n\n\n\nclass XGBoostExample : public edm::one::EDAnalyzer&lt;&gt;  {\n   public:\n      explicit XGBoostExample(const edm::ParameterSet&amp;);\n      ~XGBoostExample();\n\n      static void fillDescriptions(edm::ConfigurationDescriptions&amp; descriptions);\n\n\n   private:\n      virtual void beginJob() ;\n      virtual void analyze(const edm::Event&amp;, const edm::EventSetup&amp;) ;\n      virtual void endJob() ;\n\n      // ----------member data ---------------------------\n\n    std::string test_data_path;\n    std::string model_path;\n\n\n\n\n};\n\n//\n// constants, enums and typedefs\n//\n\n//\n// static data member definitions\n//\n\n//\n// constructors and destructor\n//\nXGBoostExample::XGBoostExample(const edm::ParameterSet&amp; config):\ntest_data_path(config.getParameter&lt;std::string&gt;(\"test_data_path\")),\nmodel_path(config.getParameter&lt;std::string&gt;(\"model_path\"))\n{\n\n}\n\n\nXGBoostExample::~XGBoostExample()\n{\n\n   // do anything here that needs to be done at desctruction time\n   // (e.g. close files, deallocate resources etc.)\n\n}\n\n\n//\n// member functions\n//\n\nvoid\nXGBoostExample::analyze(const edm::Event&amp; iEvent, const edm::EventSetup&amp; iSetup)\n{\n}\n\n\nvoid\nXGBoostExample::beginJob()\n{\n    BoosterHandle booster_;\n    XGBoosterCreate(NULL,0,&amp;booster_);\n    cout&lt;&lt;\"Hello World No.2\"&lt;&lt;endl;\n    XGBoosterLoadModel(booster_,model_path.c_str());\n    unsigned long numFeature = 0;\n    cout&lt;&lt;\"Hello World No.3\"&lt;&lt;endl;\n    vector&lt;vector&lt;double&gt;&gt; TestDataVector = readinCSV(test_data_path.c_str());\n    cout&lt;&lt;\"Hello World No.4\"&lt;&lt;endl;\n    float TestData[2000][8];\n    cout&lt;&lt;\"Hello World No.5\"&lt;&lt;endl;\n    for(unsigned i=0; (i &lt; 2000); i++)\n    { \n        for(unsigned j=0; (j &lt; 8); j++)\n        {\n            TestData[i][j] = TestDataVector[i][j];\n        //  cout&lt;&lt;TestData[i][j]&lt;&lt;\"\\t\";\n        } \n        //cout&lt;&lt;endl;\n    }\n    cout&lt;&lt;\"Hello World No.6\"&lt;&lt;endl;\n    DMatrixHandle data_;\n    XGDMatrixCreateFromMat((float *)TestData,2000,8,-1,&amp;data_);\n    cout&lt;&lt;\"Hello World No.7\"&lt;&lt;endl;\n    bst_ulong out_len=0;\n      const float *f;\n    cout&lt;&lt;out_len&lt;&lt;endl;\n    auto ret=XGBoosterPredict(booster_, data_, 0,0,&amp;out_len,&amp;f);\n    cout&lt;&lt;ret&lt;&lt;endl;\n          for (unsigned int i=0;i&lt;2;i++)\n                    std::cout &lt;&lt;  i &lt;&lt; \"\\t\"&lt;&lt; f[i] &lt;&lt; std::endl;\n    cout&lt;&lt;\"Hello World No.8\"&lt;&lt;endl;\n}\n\nvoid\nXGBoostExample::endJob()\n{\n}\n\nvoid\nXGBoostExample::fillDescriptions(edm::ConfigurationDescriptions&amp; descriptions) {\n  //The following says we do not know what parameters are allowed so do no validation\n  // Please change this to state exactly what you do use, even if it is no parameters\n  edm::ParameterSetDescription desc;\n  desc.add&lt;std::string&gt;(\"test_data_path\");\n  desc.add&lt;std::string&gt;(\"model_path\");\n  descriptions.addWithDefaultLabel(desc);\n\n  //Specify that only 'tracks' is allowed\n  //To use, remove the default given above and uncomment below\n  //ParameterSetDescription desc;\n  //desc.addUntracked&lt;edm::InputTag&gt;(\"tracks\",\"ctfWithMaterialTracks\");\n  //descriptions.addDefault(desc);\n}\n\n//define this as a plug-in\nDEFINE_FWK_MODULE(XGBoostExample);\n</code></pre> <pre><code>&lt;use name=\"FWCore/Framework\"/&gt;\n&lt;use name=\"FWCore/PluginManager\"/&gt;\n&lt;use name=\"FWCore/ParameterSet\"/&gt;\n&lt;use name=\"DataFormats/TrackReco\"/&gt;\n&lt;use name=\"xgboost\"/&gt;\n&lt;flags EDM_PLUGIN=\"1\"/&gt;\n</code></pre> <pre><code># coding: utf-8\n\nimport os\n\nimport FWCore.ParameterSet.Config as cms\nfrom FWCore.ParameterSet.VarParsing import VarParsing\n\n# setup minimal options\n#options = VarParsing(\"python\")\n#options.setDefault(\"inputFiles\", \"root://xrootd-cms.infn.it//store/mc/RunIIFall17MiniAOD/DYJetsToLL_M-10to50_TuneCP5_13TeV-madgraphMLM-pythia8/MINIAODSIM/94X_mc2017_realistic_v10-v2/00000/9A439935-1FFF-E711-AE07-D4AE5269F5FF.root\")  # noqa\n#options.parseArguments()\n\n# define the process to run\nprocess = cms.Process(\"TEST\")\n\n# minimal configuration\nprocess.load(\"FWCore.MessageService.MessageLogger_cfi\")\nprocess.MessageLogger.cerr.FwkReport.reportEvery = 1\nprocess.maxEvents = cms.untracked.PSet(input=cms.untracked.int32(1))\n#process.source = cms.Source(\"PoolSource\",\n#    fileNames=cms.untracked.vstring('file:/afs/cern.ch/cms/Tutorials/TWIKI_DATA/TTJets_8TeV_53X.root'))\nprocess.source = cms.Source(\"EmptySource\")\n# process options\nprocess.options = cms.untracked.PSet(\n    allowUnscheduled=cms.untracked.bool(True),\n    wantSummary=cms.untracked.bool(True),\n)\n\nprocess.XGBoostExample = cms.EDAnalyzer(\"XGBoostExample\")\n\n# setup MyPlugin by loading the auto-generated cfi (see MyPlugin.fillDescriptions)\n#process.load(\"XGB_Example.XGBoostExample.XGBoostExample_cfi\")\nprocess.XGBoostExample.model_path = cms.string(\"/Your/Path/data/lowVer.model\")\nprocess.XGBoostExample.test_data_path = cms.string(\"/Your/Path/data/Test_data.csv\")\n\n# define what to run in the path\nprocess.p = cms.Path(process.XGBoostExample)\n</code></pre> <pre><code>// -*- C++ -*-\n//\n// Package:    XGB_Example/XGBoostExample\n// Class:      XGBoostExample\n//\n/**\\class XGBoostExample XGBoostExample.cc XGB_Example/XGBoostExample/plugins/XGBoostExample.cc\n\n Description: [one line class summary]\n\n Implementation:\n     [Notes on implementation]\n*/\n//\n// Original Author:  Qian Sitian\n//         Created:  Sat, 19 Jun 2021 08:38:51 GMT\n//\n//\n\n\n// system include files\n#include &lt;memory&gt;\n\n// user include files\n#include \"FWCore/Framework/interface/Frameworkfwd.h\"\n#include \"FWCore/Framework/interface/one/EDAnalyzer.h\"\n\n#include \"FWCore/Framework/interface/Event.h\"\n#include \"FWCore/Framework/interface/MakerMacros.h\"\n\n#include \"FWCore/ParameterSet/interface/ParameterSet.h\"\n #include \"FWCore/Utilities/interface/InputTag.h\"\n #include \"DataFormats/TrackReco/interface/Track.h\"\n #include \"DataFormats/TrackReco/interface/TrackFwd.h\"\n\n#include &lt;xgboost/c_api.h&gt;\n#include &lt;vector&gt;\n#include &lt;tuple&gt;\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;sstream&gt;\n\nusing namespace std;\n\nvector&lt;vector&lt;double&gt;&gt; readinCSV(const char* name){\n    auto fin = ifstream(name);\n    vector&lt;vector&lt;double&gt;&gt; floatVec;\n    string strFloat;\n    float fNum;\n    int counter = 0;\n    getline(fin,strFloat);\n    while(getline(fin,strFloat))\n    {\n        std::stringstream  linestream(strFloat);\n        floatVec.push_back(std::vector&lt;double&gt;());\n        while(linestream&gt;&gt;fNum)\n        {\n            floatVec[counter].push_back(fNum);\n            if (linestream.peek() == ',')\n            linestream.ignore();\n        }\n        ++counter;\n    }\n    return floatVec;\n}\n\n//\n// class declaration\n//\n\n// If the analyzer does not use TFileService, please remove\n// the template argument to the base class so the class inherits\n// from  edm::one::EDAnalyzer&lt;&gt;\n// This will improve performance in multithreaded jobs.\n\n\n\nclass XGBoostExample : public edm::one::EDAnalyzer&lt;&gt;  {\n   public:\n      explicit XGBoostExample(const edm::ParameterSet&amp;);\n      ~XGBoostExample();\n\n      static void fillDescriptions(edm::ConfigurationDescriptions&amp; descriptions);\n\n\n   private:\n      virtual void beginJob() ;\n      virtual void analyze(const edm::Event&amp;, const edm::EventSetup&amp;) ;\n      virtual void endJob() ;\n\n      // ----------member data ---------------------------\n\n    std::string test_data_path;\n    std::string model_path;\n\n\n\n\n};\n\n//\n// constants, enums and typedefs\n//\n\n//\n// static data member definitions\n//\n\n//\n// constructors and destructor\n//\nXGBoostExample::XGBoostExample(const edm::ParameterSet&amp; config):\ntest_data_path(config.getParameter&lt;std::string&gt;(\"test_data_path\")),\nmodel_path(config.getParameter&lt;std::string&gt;(\"model_path\"))\n{\n\n}\n\n\nXGBoostExample::~XGBoostExample()\n{\n\n   // do anything here that needs to be done at desctruction time\n   // (e.g. close files, deallocate resources etc.)\n\n}\n\n\n//\n// member functions\n//\n\nvoid\nXGBoostExample::analyze(const edm::Event&amp; iEvent, const edm::EventSetup&amp; iSetup)\n{\n}\n\n\nvoid\nXGBoostExample::beginJob()\n{\n    BoosterHandle booster_;\n    XGBoosterCreate(NULL,0,&amp;booster_);\n    XGBoosterLoadModel(booster_,model_path.c_str());\n    unsigned long numFeature = 0;\n    vector&lt;vector&lt;double&gt;&gt; TestDataVector = readinCSV(test_data_path.c_str());\n    float TestData[2000][8];\n    for(unsigned i=0; (i &lt; 2000); i++)\n    { \n        for(unsigned j=0; (j &lt; 8); j++)\n        {\n            TestData[i][j] = TestDataVector[i][j];\n        //  cout&lt;&lt;TestData[i][j]&lt;&lt;\"\\t\";\n        } \n        //cout&lt;&lt;endl;\n    }\n    DMatrixHandle data_;\n    XGDMatrixCreateFromMat((float *)TestData,2000,8,-1,&amp;data_);\n    bst_ulong out_len=0;\n      const float *f;\n    auto ret=XGBoosterPredict(booster_, data_,0, 0,0,&amp;out_len,&amp;f);\n          for (unsigned int i=0;i&lt;out_len;i++)\n                    std::cout &lt;&lt;  i &lt;&lt; \"\\t\"&lt;&lt; f[i] &lt;&lt; std::endl;\n}\n\nvoid\nXGBoostExample::endJob()\n{\n}\n\nvoid\nXGBoostExample::fillDescriptions(edm::ConfigurationDescriptions&amp; descriptions) {\n  //The following says we do not know what parameters are allowed so do no validation\n  // Please change this to state exactly what you do use, even if it is no parameters\n  edm::ParameterSetDescription desc;\n  desc.add&lt;std::string&gt;(\"test_data_path\");\n  desc.add&lt;std::string&gt;(\"model_path\");\n  descriptions.addWithDefaultLabel(desc);\n\n  //Specify that only 'tracks' is allowed\n  //To use, remove the default given above and uncomment below\n  //ParameterSetDescription desc;\n  //desc.addUntracked&lt;edm::InputTag&gt;(\"tracks\",\"ctfWithMaterialTracks\");\n  //descriptions.addDefault(desc);\n}\n\n//define this as a plug-in\nDEFINE_FWK_MODULE(XGBoostExample);\n</code></pre> <pre><code>&lt;use name=\"FWCore/Framework\"/&gt;\n&lt;use name=\"FWCore/PluginManager\"/&gt;\n&lt;use name=\"FWCore/ParameterSet\"/&gt;\n&lt;use name=\"DataFormats/TrackReco\"/&gt;\n&lt;use name=\"xgboost\"/&gt;\n&lt;flags EDM_PLUGIN=\"1\"/&gt;\n</code></pre> <pre><code># coding: utf-8\n\nimport os\n\nimport FWCore.ParameterSet.Config as cms\nfrom FWCore.ParameterSet.VarParsing import VarParsing\n\n# setup minimal options\n#options = VarParsing(\"python\")\n#options.setDefault(\"inputFiles\", \"root://xrootd-cms.infn.it//store/mc/RunIIFall17MiniAOD/DYJetsToLL_M-10to50_TuneCP5_13TeV-madgraphMLM-pythia8/MINIAODSIM/94X_mc2017_realistic_v10-v2/00000/9A439935-1FFF-E711-AE07-D4AE5269F5FF.root\")  # noqa\n#options.parseArguments()\n\n# define the process to run\nprocess = cms.Process(\"TEST\")\n\n# minimal configuration\nprocess.load(\"FWCore.MessageService.MessageLogger_cfi\")\nprocess.MessageLogger.cerr.FwkReport.reportEvery = 1\nprocess.maxEvents = cms.untracked.PSet(input=cms.untracked.int32(10))\n#process.source = cms.Source(\"PoolSource\",\n#    fileNames=cms.untracked.vstring('file:/afs/cern.ch/cms/Tutorials/TWIKI_DATA/TTJets_8TeV_53X.root'))\nprocess.source = cms.Source(\"EmptySource\")\n#process.source = cms.Source(\"PoolSource\",\n#    fileNames=cms.untracked.vstring(options.inputFiles))\n# process options\nprocess.options = cms.untracked.PSet(\n    allowUnscheduled=cms.untracked.bool(True),\n    wantSummary=cms.untracked.bool(True),\n)\n\nprocess.XGBoostExample = cms.EDAnalyzer(\"XGBoostExample\")\n\n# setup MyPlugin by loading the auto-generated cfi (see MyPlugin.fillDescriptions)\n#process.load(\"XGB_Example.XGBoostExample.XGBoostExample_cfi\")\nprocess.XGBoostExample.model_path = cms.string(\"/Your/Path/data/highVer.model\")  \nprocess.XGBoostExample.test_data_path = cms.string(\"/Your/Path/data/Test_data.csv\")\n\n# define what to run in the path\nprocess.p = cms.Path(process.XGBoostExample)\n</code></pre>"},{"location":"inference/xgboost.html#python-usage","title":"Python Usage","text":"<p>To use XGBoost's python interface, using the snippet below under CMSSW environment <pre><code># importing necessary models\nimport numpy as np\nimport pandas as pd \nfrom xgboost import XGBClassifier\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n\nxgb = XGBClassifier()\nxgb.load_model('ModelName.model')\n\n# After loading model, usage is the same as discussed in the model preparation section.\n</code></pre></p>"},{"location":"inference/xgboost.html#caveat","title":"Caveat","text":"<p>It is worth mentioning that both behavior and APIs of different XGBoost version can have difference. </p> <ol> <li> <p>When using <code>c_api</code> for C/C++ inference, for ver.&lt;1, the API is <code>XGB_DLL int XGBoosterPredict(BoosterHandle   handle, DMatrixHandle   dmat,int    option_mask, int    training, bst_ulong * out_len,const float **    out_result)</code>, while for ver.&gt;=1 the API changes to  <code>XGB_DLL int XGBoosterPredict(BoosterHandle     handle, DMatrixHandle   dmat,int    option_mask, unsigned int ntree_limit, int  training, bst_ulong * out_len,const float **    out_result)</code>.</p> </li> <li> <p>Model from ver.&gt;=1 cannot be used for ver.&lt;1.</p> </li> </ol> <p>Other important issue for C/C++ user is that DMatrix only takes in single precision floats (<code>float</code>), not double precision floats (<code>double</code>).</p>"},{"location":"inference/xgboost.html#appendix-tips-for-xgboost-users","title":"Appendix: Tips for XGBoost users","text":""},{"location":"inference/xgboost.html#importance-plot","title":"Importance Plot","text":"<p>XGBoost uses F-score to describe feature importance quantatitively. XGBoost's python API provides a nice tool,<code>plot_importance</code>, to plot the feature importance conveniently after finishing train. </p> <p><pre><code># Once the training is done, the plot_importance function can thus be used to plot the feature importance.\nfrom xgboost import plot_importance # Import the function\n\nplot_importance(xgb) # suppose the xgboost object is named \"xgb\"\nplt.savefig(\"importance_plot.pdf\") # plot_importance is based on matplotlib, so the plot can be saved use plt.savefig()\n</code></pre>  The importance plot is consistent with our expectation, as in our toy-model, the data points differ by most on the feature \"7\". (see toy model setup).</p>"},{"location":"inference/xgboost.html#roc-curve-and-auc","title":"ROC Curve and AUC","text":"<p>The receiver operating characteristic (ROC) and auccrency (AUC) are key quantities to describe the model performance. For XGBoost, ROC curve and auc score can be easily obtained with the help of sci-kit learn (sklearn) functionals, which is also in CMSSW software. <pre><code>from sklearn.metrics import roc_auc_score,roc_curve,auc\n# ROC and AUC should be obtained on test set\n# Suppose the ground truth is 'y_test', and the output score is named as 'y_score'\n\nfpr, tpr, _ = roc_curve(y_test, y_score)\nroc_auc = auc(fpr, tpr)\n\nplt.figure()\nlw = 2\nplt.plot(fpr, tpr, color='darkorange',\n         lw=lw, label='ROC curve (area = %0.2f)' % roc_auc)\nplt.plot([0, 1], [0, 1], color='navy', lw=lw, linestyle='--')\nplt.xlim([0.0, 1.0])\nplt.ylim([0.0, 1.05])\nplt.xlabel('False Positive Rate')\nplt.ylabel('True Positive Rate')\nplt.title('Receiver operating characteristic example')\nplt.legend(loc=\"lower right\")\n# plt.show() # display the figure when not using jupyter display\nplt.savefig(\"roc.png\") # resulting plot is shown below\n</code></pre> </p>"},{"location":"inference/xgboost.html#reference-of-xgboost","title":"Reference of XGBoost","text":"<ol> <li>XGBoost Wiki: https://en.wikipedia.org/wiki/XGBoost</li> <li>XGBoost Github Repo.: https://github.com/dmlc/xgboost</li> <li>XGBoost offical api tutorial</li> <li>Latest, Python: https://xgboost.readthedocs.io/en/latest/python/index.html</li> <li>Latest, C/C++: https://xgboost.readthedocs.io/en/latest/tutorials/c_api_tutorial.html</li> <li>Older (0.80), Python: https://xgboost.readthedocs.io/en/release_0.80/python/index.html</li> <li>No Tutorial for older version C/C++ api, source code: https://github.com/dmlc/xgboost/blob/release_0.80/src/c_api/c_api.cc</li> </ol>"},{"location":"innovation/hackathons.html","title":"CMS Machine Learning Hackathons","text":"<p>Welcome to the CMS ML Hackathons! Here we encourage the exploration of cutting edge ML methods to particle physics problems through multi-day focused work. Form hackathon teams and work together with the ML Innovation group to get support with organization and announcements, hardware/software infrastructure, follow-up meetings and ML-related technical advise.</p> <p>If you are interested in proposing a hackathon, please send an e-mail to the CMS ML Innovation conveners with a potential topic and we will get in touch!</p> <p>Below follows a list of previous successful hackathons.</p>"},{"location":"innovation/hackathons.html#hgcal-ticl-reconstruction","title":"HGCAL TICL reconstruction","text":"<p>20 Jun 2022 - 24 Jun 2022  https://indico.cern.ch/e/ticlhack</p> <p>Abstract: The HGCAL reconstruction relies on \u201cThe Iterative CLustering\u201d (TICL) framework. It follows an iterative approach, first clusters energy deposits in the same layer (layer clusters) and then connect these layer clusters to reconstruct the particle shower by forming 3-D objects, the \u201ctracksters\u201d. There are multiple areas that could benefit from advanced ML techniques to further improve the reconstruction performance.</p> <p>In this project we plan to tackle the following topics using ML:</p> <ul> <li>trackster identification (ie, identification of the type of particle initiating the shower) and energy regression linking of tracksters stemming from the same particle to reconstruct the full shower and/or use a high-purity trackster as a seed and collect 2D (ie. layer clusters) and/or 3D (ie, tracksters) energy deposits in the vicinity of the seed trackster to fully reconstruct the particle shower</li> <li>tuning of the existing pattern recognition algorithms</li> <li>reconstruction under HL-LHC pile-up scenarios (eg., PU=150-200)</li> <li>trackster characterization, ie. predict if a trackster is a sound object in itself or determine if it is more likely to be a composite one.</li> </ul>"},{"location":"innovation/hackathons.html#material","title":"Material:","text":"<p>A CodiMD document has been created with an overview of the topics and to keep track of the activities during the hackathon:</p> <p>https://codimd.web.cern.ch/s/hMd74Yi7J</p>"},{"location":"innovation/hackathons.html#jet-tagging","title":"Jet tagging","text":"<p>8 Nov 2021 - 11 Nov 2021  https://indico.cern.ch/e/jethack</p> <p>Abstract: The identification of the initial particle (quark, gluon, W/Z boson, etc..) responsible for the formation of the jet, also known as jet tagging, provides a powerful handle in both standard model (SM) measurements and searches for physics beyond the SM (BSM). In this project we propose the development of jet tagging algorithms both for small-radius (i.e. AK4) and large-radius (i.e., AK8) jets using as inputs the PF candidates.</p> <p>Two main projects are covered:</p> <ul> <li>Jet tagging for scouting</li> <li>Jet tagging for Level-1</li> </ul>"},{"location":"innovation/hackathons.html#jet-tagging-for-scouting","title":"Jet tagging for scouting","text":"<p>Using as inputs the PF candidates and local pixel tracks reconstructed in the scouting streams, the main goals of this project are the following:</p> <p>Develop a jet-tagging baseline for scouting and compare the performance with the offline reconstruction Understand the importance of the different input variables and the impact of -various configurations (e.g., on pixel track reconstruction) in the performance Compare different jet tagging approaches with mind performance as well as inference time. Proof of concept: ggF H-&gt;bb, ggF HH-&gt;4b, VBF HH-&gt;4b</p>"},{"location":"innovation/hackathons.html#jet-tagging-for-level-1","title":"Jet tagging for Level-1","text":"<p>Using as input the newly developed particle flow candidates of Seeded Cone jets in the Level1 Correlator trigger, the following tasks will be worked on:</p> <ul> <li>Developing a quark, gluon, b, pileup jet classifier for Seeded Cone R=0.4 jets using a combination of tt,VBF(H) and Drell-Yan Level1 samples</li> <li>Develop tools to demonstrate the gain of such a jet tagging algorithm on a signal sample (like q vs g on VBF jets)</li> <li>Study tagging performance as a function of the number of jet constituents</li> <li>Study tagging performance for a \"real\" input vector (zero-paddes, perhaps unsorted)</li> <li>Optimise jet constituent list of SeededCone Jets (N constituents, zero-removal, sorting etc)</li> <li>Develop q/g/W/Z/t/H classifier for Seeded Cone R=0.8 jets</li> </ul>"},{"location":"innovation/hackathons.html#gnn-4-tracking","title":"GNN-4-tracking","text":"<p>27 Sept 2021 - 1 Oct 2021</p> <p>https://indico.cern.ch/e/gnn4tracks</p> <p>Abstract: The aim of this hackathon is to integrate graph neural nets (GNNs) for particle tracking into CMSSW.</p> <p>The hackathon will make use of a GNN model reported by the paper Charged particle tracking via edge-classifying interaction networks by Gage DeZoort, Savannah Thais, et.al. They used a GNN to predict connections between detector pixel hits, and achieved accurate track building. They did this with the TrackML dataset, which uses a generic detector designed to be similar to CMS or ATLAS. Work is ongoing to apply this GNN approach to CMS data.</p> <p>Tasks: The hackathon aims to create a workflow that allows graph building and GNN inference within the framework of CMSSW. This would enable accurate testing of future GNN models and comparison to existing CMSSW track building methods. The hackathon will be divided into the following subtasks:</p> <ul> <li>Task 1: Create a package for extracting graph features and building graphs in CMSSW.</li> <li>Task 2. GNN inference on Sonic servers </li> <li>Task 3: Track fitting after GNN track building </li> <li>Task 4. Performance evaluation for the new track collection </li> </ul>"},{"location":"innovation/hackathons.html#material_1","title":"Material:","text":"<p>Code is provided at this GitHub organisation. Project are listed here.</p>"},{"location":"innovation/hackathons.html#anomaly-detection","title":"Anomaly detection","text":"<p>In this four day Machine Learning Hackathon, we will develop new anomaly detection algorithms for New Physics detection, intended for deployment in the two main stages of the CMS data aquisition system: The Level-1 trigger and the High Level Trigger.</p> <p>There are two main projects:</p>"},{"location":"innovation/hackathons.html#event-based-anomaly-detection-algorithms-for-the-level-1-trigger","title":"Event-based anomaly detection algorithms for the Level-1 Trigger","text":""},{"location":"innovation/hackathons.html#jet-based-anomaly-detection-algorithms-for-the-high-level-trigger-specifically-targeting-run-3-scouting","title":"Jet-based anomaly detection algorithms for the High Level Trigger, specifically targeting Run 3 scouting","text":""},{"location":"innovation/hackathons.html#material_2","title":"Material:","text":"<p>A list of  projects can be found in this document.  Instructions for fetching the data and example code for the two projects can be found at Level-1 Anomaly Detection.</p>"},{"location":"innovation/journal_club.html","title":"CMS Machine Learning Journal Club","text":"<p>Welcome to the CMS Machine Learning Journal Club (JC)! Here we read an discuss new cutting edge ML papers, with an emphasis on how these can be used within the collaboration. Below you can find a summary of each JC as well as some code examples demonstrating how to use the tools or methods introduced.</p> <p>To vote for or to propose new papers for discussion, go to https://cms-ml-journalclub.web.cern.ch/.</p> <p>Below follows a complete list of all the previous CMS ML JHournal clubs, together with relevant documentation and code examples.</p>"},{"location":"innovation/journal_club.html#dealing-with-nuisance-parameters-using-machine-learning-in-high-energy-physics-a-review","title":"Dealing with Nuisance Parameters using Machine Learning in High Energy Physics: a Review","text":"<p>Tommaso Dorigo, Pablo de Castro</p> <p>Abstract: In this work we discuss the impact of nuisance parameters on the effectiveness of machine learning in high-energy physics problems, and provide a review of techniques that allow to include their effect and reduce their impact in the search for optimal selection criteria and variable transformations. The introduction of nuisance parameters complicates the supervised learning task and its correspondence with the data analysis goal, due to their contribution degrading the model performances in real data, and the necessary addition of uncertainties in the resulting statistical inference. The approaches discussed include nuisance-parameterized models, modified or adversary losses, semi-supervised learning approaches, and inference-aware techniques.</p> <ul> <li>Indico</li> <li>Paper</li> </ul>"},{"location":"innovation/journal_club.html#mapping-machine-learned-physics-into-a-human-readable-space","title":"Mapping Machine-Learned Physics into a Human-Readable Space","text":"<p>Taylor Faucett, Jesse Thaler, Daniel Whiteson</p> <p>Abstract: We present a technique for translating a black-box machine-learned classifier operating on a high-dimensional input space into a small set of human-interpretable observables that can be combined to make the same classification decisions. We iteratively select these observables from a large space of high-level discriminants by finding those with the highest decision similarity relative to the black box, quantified via a metric we introduce that evaluates the relative ordering of pairs of inputs. Successive iterations focus only on the subset of input pairs that are misordered by the current set of observables. This method enables simplification of the machine-learning strategy, interpretation of the results in terms of well-understood physical concepts, validation of the physical model, and the potential for new insights into the nature of the problem itself. As a demonstration, we apply our approach to the benchmark task of jet classification in collider physics, where a convolutional neural network acting on calorimeter jet images outperforms a set of six well-known jet substructure observables. Our method maps the convolutional neural network into a set of observables called energy flow polynomials, and it closes the performance gap by identifying a class of observables with an interesting physical interpretation that has been previously overlooked in the jet substructure literature. - Indico - Paper</p>"},{"location":"innovation/journal_club.html#model-interpretability-2-papers","title":"Model Interpretability (2 papers):","text":"<ul> <li>Indico</li> </ul>"},{"location":"innovation/journal_club.html#identifying-the-relevant-dependencies-of-the-neural-network-response-on-characteristics-of-the-input-space","title":"Identifying the relevant dependencies of the neural network response on characteristics of the input space","text":"<p>Stefan Wunsch, Raphael Friese, Roger Wolf, G\u00fcnter Quast</p> <p>Abstract: The relation between the input and output spaces of neural networks (NNs) is investigated to identify those characteristics of the input space that have a large influence on the output for a given task. For this purpose, the NN function is decomposed into a Taylor expansion in each element of the input space. The Taylor coefficients contain information about the sensitivity of the NN response to the inputs. A metric is introduced that allows for the identification of the characteristics that mostly determine the performance of the NN in solving a given task. Finally, the capability of this metric to analyze the performance of the NN is evaluated based on a task common to data analyses in high-energy particle physics experiments.</p> <ul> <li>Paper</li> </ul>"},{"location":"innovation/journal_club.html#innvestigate-neural-networks","title":"iNNvestigate neural networks!","text":"<p>Maximilian Alber, Sebastian Lapuschkin, Philipp Seegerer, Miriam H\u00e4gele, Kristof T. Sch\u00fctt, Gr\u00e9goire Montavon, Wojciech Samek, Klaus-Robert M\u00fcller, Sven D\u00e4hne, Pieter-Jan Kindermans</p> <p>In recent years, deep neural networks have revolutionized many application domains of machine learning and are key components of many critical decision or predictive processes. Therefore, it is crucial that domain specialists can understand and analyze actions and pre- dictions, even of the most complex neural network architectures. Despite these arguments neural networks are often treated as black boxes. In the attempt to alleviate this short- coming many analysis methods were proposed, yet the lack of reference implementations often makes a systematic comparison between the methods a major effort. The presented library iNNvestigate addresses this by providing a common interface and out-of-the- box implementation for many analysis methods, including the reference implementation for PatternNet and PatternAttribution as well as for LRP-methods. To demonstrate the versatility of iNNvestigate, we provide an analysis of image classifications for variety of state-of-the-art neural network architectures.</p> <ul> <li>Paper</li> <li>Code</li> </ul>"},{"location":"innovation/journal_club.html#simulation-based-inference-in-particle-physics-and-beyond-and-beyond","title":"Simulation-based inference in particle physics and beyond (and beyond)","text":"<p>Johann Brehmer, Kyle Cranmer</p> <p>Abstract: Our predictions for particle physics processes are realized in a chain of complex simulators. They allow us to generate high-fidelity simulated data, but they are not well-suited for inference on the theory parameters with observed data. We explain why the likelihood function of high-dimensional LHC data cannot be explicitly evaluated, why this matters for data analysis, and reframe what the field has traditionally done to circumvent this problem. We then review new simulation-based inference methods that let us directly analyze high-dimensional data by combining machine learning techniques and information from the simulator. Initial studies indicate that these techniques have the potential to substantially improve the precision of LHC measurements. Finally, we discuss probabilistic programming, an emerging paradigm that lets us extend inference to the latent process of the simulator.</p> <ul> <li>Indico</li> <li>Paper</li> <li>Code</li> </ul>"},{"location":"innovation/journal_club.html#efficiency-parameterization-with-neural-networks","title":"Efficiency Parameterization with Neural Networks","text":"<p>C. Badiali, F.A. Di Bello, G. Frattari, E. Gross, V. Ippolito, M. Kado, J. Shlomi</p> <p>Abstract: Multidimensional efficiency maps are commonly used in high energy physics experiments to mitigate the limitations in the generation of large samples of simulated events. Binned multidimensional efficiency maps are however strongly limited by statistics. We propose a neural network approach to learn ratios of local densities to estimate in an optimal fashion efficiencies as a function of a set of parameters. Graph neural network techniques are used to account for the high dimensional correlations between different physics objects in the event. We show in a specific toy model how this method is applicable to produce accurate multidimensional efficiency maps for heavy flavor tagging classifiers in HEP experiments, including for processes on which it was not trained. - Indico - Paper - Code</p>"},{"location":"innovation/journal_club.html#a-general-framework-for-uncertainty-estimation-in-deep-learning","title":"A General Framework for Uncertainty Estimation in Deep Learning","text":"<p>Antonio Loquercio, Mattia Seg\u00f9, Davide Scaramuzza</p> <p>Neural networks predictions are unreliable when the input sample is out of the training distribution or corrupted by noise. Being able to detect such failures automatically is fundamental to integrate deep learning algorithms into robotics. Current approaches for uncertainty estimation of neural networks require changes to the network and optimization process, typically ignore prior knowledge about the data, and tend to make over-simplifying assumptions which underestimate uncertainty. To address these limitations, we propose a novel framework for uncertainty estimation. Based on Bayesian belief networks and Monte-Carlo sampling, our framework not only fully models the different sources of prediction uncertainty, but also incorporates prior data information, e.g. sensor noise. We show theoretically that this gives us the ability to capture uncertainty better than existing methods. In addition, our framework has several desirable properties: (i) it is agnostic to the network architecture and task; (ii) it does not require changes in the optimization process; (iii) it can be applied to already trained architectures. We thoroughly validate the proposed framework through extensive experiments on both computer vision and control tasks, where we outperform previous methods by up to 23% in accuracy.</p> <ul> <li>Indico</li> <li>Paper</li> <li>Code</li> </ul>"},{"location":"optimization/data_augmentation.html","title":"Data augmentation","text":""},{"location":"optimization/data_augmentation.html#introduction","title":"Introduction","text":"<p>This introduction is based on papers by Shorten &amp; Khoshgoftaar, 2019 and Rebuffi et al., 2021 among others</p> <p>With the increasing complexity and sizes of neural networks one needs huge amounts of data in order to train a state-of-the-art model. However, generating this data is often very resource and time intensive. Thus, one might either augment the existing data with more descriptive variables or combat the data scarcity problem by artificially increasing the size of the dataset by adding new instances without the resource-heavy generation process. Both processes are known in machine learning (ML) applications as data augmentation (DA) methods. </p> <p>The first type of these methods is more widely known as feature generation or feature engineering and is done on instance level. Feature engineering focuses on crafting informative input features for the algorithm, often inspired or derived from first principles specific to the algorithm's application domain.</p> <p>The second type of method is done on the dataset level. These types of techniques can generally be divided into two main categories: real data augmentation (RDA) and synthetic data augmentation (SDA). As the name suggests, RDA makes minor changes to the already existing data in order to generate new samples, whereas SDA generates new data from scratch. Examples of RDA include rotating (especially useful if we expect the event to be rotationally symmetric) and zooming, among a plethora of other methods detailed in this overview article. Examples of SDA include traditional sampling methods and more complex generative models like Generative Adversaial Netoworks (GANs) and Variational Autoencoders (VAE). Going further, the generative methods used for synthetic data augmentation could also be used in fast simulation, which is a notable bottleneck in the overall physics analysis workflow.</p> <p>Dataset augmentation may lead to more successful algorithm outcomes. For example, introducing noise into data to form additional data points improves the learning ability of several models which otherwise performed relatively poorly, as shown by Freer &amp; Yang, 2020. This finding implies that this form of DA creates variations that the model may see in the real world. If done right, preprocessing the data with DA will result in superior training outcomes. This improvement in performance is due to the fact that DA methods act as a regularizer, reducing overfitting during training. In addition to simulating real-world variations, DA methods can also even out categorical data with imbalanced classes.</p> Fig. 1: Generic pipeline of a heuristic DA (figure taken from Li, 2020) <p>Before diving more in depth into the various DA methods and applications in HEP, here is a list of the most notable benefits of using DA methods in your ML workflow:</p> <ul> <li>Improvement of model prediction precision</li> <li>More training data for the model</li> <li>Preventing data scarcity for state-of-the-art models</li> <li>Reduction of over overfitting and creation of data variability</li> <li>Increased model generalization properties</li> <li>Help in resolving class imbalance problems in datasets</li> <li>Reduced cost of data collection and labeling</li> <li>Enabling rare event prediction</li> </ul> <p>And some words of caution:</p> <ul> <li>There is no 'one size fits all' in DA. Each dataset and usecase should be considered separately.</li> <li>Don't trust the augmented data blindly</li> <li>Make sure that the augmented data is representative of the problem at hand, otherwise it will negatively affect the model performance.</li> <li>There must be no unnecessary duplication of existing data, only by adding unique information we gain more insights.</li> <li>Ensure the validity of the augmented data before using it in ML models.</li> <li>If a real dataset contains biases, data augmented from it will contain biases, too. So, identification of optimal data augmentation strategy is important. So, double check your DA strategy.</li> </ul>"},{"location":"optimization/data_augmentation.html#feature-engineering","title":"Feature Engineering","text":"<p>This part is based mostly on Erdmann et al., 2018</p> <p>Feature engineering (FE) is one of the key components of a machine learning workflow. This process transforms and augments training data with additional features in order to make the training more effective.</p> <p>With multi-variate analyeses (MVAs), such boosted decision trees (BDTs) and neural networks, one could start with raw, \"low-level\" features, like four-momenta, and the algorithm can learn higher level patterns, correlations, metrics, etc. However, using \"high-level\" variables, in many cases, leads to outcomes superior to the use of low-level variables. As such, features used in MVAs are handcrafted from physics first principles. </p> <p>Still, it is shown that a deep neural network (DNN) can perform better if it is trained with both specifically constructed variables and low-level variables. This observation suggests that the network extracts additional information from the training data.</p>"},{"location":"optimization/data_augmentation.html#hep-application-lorentz-boosted-network","title":"HEP Application - Lorentz Boosted Network","text":"<p>For the purposeses of FE in HEP, a novel ML architecture called a Lorentz Boost Network (LBN) (see Fig. 2) was proposed and implemented by Erdmann et al., 2018. It is a multipurpose method that uses Lorentz transformations to exploit and uncover structures in particle collision events. LBN is the first stage of a two-stage neural network (NN) model, that enables a fully autonomous and comprehensive characterization of collision events by exploiting exclusively the four-momenta of the final-state particles. </p> <p>Within LBN, particles are combined to create rest frames representions, which enables the formation of further composite particles. These combinations are realized via linear combinations of N input four-vectors to a number of M particles and rest frames. Subsequently these composite particles are then transformed into said rest frames by Lorentz transformations in an efficient and fully vectorized implementation.</p> <p>The properties of the composite, transformed particles are compiled in the form of characteristic variables like masses, angles, etc. that serve as input for a subsequent network - the second stage, which has to be configured for a specific analysis task, like classification.</p> <p>The authors observed leading performance with the LBN and demonstrated that LBN forms physically meaningful particle combinations and generates suitable characteristic variables.</p> <p>The usual ML workflow, employing LBN, is as follows:</p> <pre><code>Step-1: LBN(M, F)\n\n    1.0: Input hyperparameters: number of combinations M; number of features F\n    1.0: Choose: number of incoming particles, N, according to the research\n         question\n\n    1.1: Combination of input four-vectors to particles and rest frames\n\n    1.2: Lorentz transformations\n\n    1.3 Extraction of suitable high-level objects\n\n\nStep-2: NN\n\n    2.X: Train some form of a NN using an objective function that depends on\n         the analysis / research question.\n</code></pre> Fig. 2: The Lorentz Boost Network architecture (figure taken from Erdmann et al., 2018) <p>The LBN package is also pip-installable:</p> <pre><code>pip install lbn\n</code></pre>"},{"location":"optimization/data_augmentation.html#rda-techniques","title":"RDA Techniques","text":"<p>This section and the following subsection are based on the papers by Freer &amp; Yang, 2020, Dolan &amp; Ore, 2021, Barnard et al., 2016, and Bradshaw et al., 2019</p> <p>RDA methods augment the existing dataset by performance some transformation on the existing data points. These transformations could include rotation, flipping, color shift (for an image), Fourier transforming (for signal processing) or some other transformation that preserves the validity of the data point and its corresponding label. As mentioned in Freer &amp; Yang, 2020, these types of transformations augment the dataset to capture potential variations that the population of data may exhibit, allowing the network to capture a more generalized view of the sampled data.</p>"},{"location":"optimization/data_augmentation.html#hep-application-zooming","title":"HEP Application - Zooming","text":"<p>In Barnard et al., 2016, the authors investigate the effect of parton shower modelling in DNN jet taggers using images of hadronically decaying W bosons. They introduce a method known as zooming to study the scale invariance of these networks. This is the RDA strategy used by Dolan &amp; Ore, 2021. Zooming is similar to a normalization procedure such that it standardizes features in signal data, but it aims to not create similar features in background. </p> <p>After some standard data processing steps, including jet trimming and clustering via the \\(k_t\\) algorithm, and some further processing to remove spatial symmetries, the resulting jet image depicts the leading subjet and subleading subjet directly below. Barnard et al., 2016 notes that the separation between the leading and subleading subjets varies linearly as \\(2m/p_T\\) where \\(m\\) and \\(p_T\\) are the mass and transverse momentum of the jet. Standardizing this separation, or removing the linear dependence, would allow the DNN tagger to generalize to a wide range of jet \\(p_T\\). To this end, the authors construct a factor, \\(R/\\DeltaR_{act}\\), where \\(R\\) is some fixed value and \\(\\DeltaR_{act}\\) is the separation between the leading and subleading subjets. To discriminate between signal and background images with this factor, the authors enlarge the jet images by a scaling factor of \\(\\text{max}(R/s,1)\\) where \\(s = 2m_W/p_T\\) and \\(R\\) is the original jet clustering size. This process of jet image enlargement by a linear mass and \\(p_T\\) dependent factor to account for the distane between the leading and subleading jet is known as zooming. This process can be thought of as an RDA technique to augment the data in a domain-specific way.</p> <p>Advantage of using the zooming technique is that it makes the construction of scale invariant taggers easier. Scale invariant searches which are able to interpolate between the boosted and resolved parts of phase space have the advantage of being applicable over a broad range of masses and kinematics, allowing a single search or analysis to be effective where previously more than one may have been necessary.</p> <p>As predicted the zoomed network outperforms the unzoomed one, particularly at low signal efficiency, where the background rejection rises by around 20%. Zooming has the greatest effect at high pT.</p>"},{"location":"optimization/data_augmentation.html#traditional-sda-techniques","title":"Traditional SDA Techniques","text":"<p>Text in part based on He et al., 2010</p> <p>Generally speaking, imbalanced learning occurs whenever some type of data distribution dominates the instance space compared to other data distributions. Methods for handling imbalanced learning problems can be divided into the following five major categories:</p> <ul> <li>Sampling strategies</li> <li>Synthetic data generation (SMOTE &amp; ADASYN &amp; DataBoost-IM)  - aims to overcome the imbalance by artificially generating data samples.</li> <li>Cost-sensitive learning - uses cost-matrix for different types of errors or instance to facilitate learning from imbalanced data sets. This means that cost-sensitive learning does not modify the imbalanced data distribution directly, but targets this problem by using different cost-matrices that describe the cost for misclassifying any particular data sample.</li> <li>Active learning - conventionally used to solve problems related to unlabeled data, though recently it has been used in learning imbalanced data sets. Instead of searching the entire training space, this method effectively selects informative instances from a random set of training populations, therefore significantly reducing the computational cost when dealing with large imbalanced data sets.</li> <li>Kernel-based methods - by integrating the regularized orthogonal weighed least squares (ROWLS) estimator, a kernel classifier construction algorithm is based on orthogonal forward selection (OFS) to optimize the model generalization for learning from two-class imbalanced data sets.</li> </ul>"},{"location":"optimization/data_augmentation.html#sampling","title":"Sampling","text":"<p>When the percentage of the minority class is less than 5%, it can be considered a rare event. When a dataset is imbalanced or when a rare event occurs, it will be difficult to get a meaningful and good predictive model due to lack of information about the rare event Au et al., 2010. In these cases, re-sampling techniques can be helpful. The re-sampling techniques are implemented in four different categories: undersampling the majority class, oversampling the minority class, combining over- and undersampling, and ensembling sampling. Oversampling and undersampling are found to work well in improving the classification for the imbalanced dataset. Yap et al., 2013</p> <p>Stratified sampling (STS)  This technique is used in cases where the data can be partitioned into strata (subpopulations), where each strata should be collectively exhaustive and mutually exclusive. The process of dividing the data into homogeneus subgroups before sampling is referred to as stratification. The two common strategies of STS are proportionate allocation (PA) and optimum (disproportionate) allocation (OA). The former uses a fraction in each of the stata that is proportional to that of the total population. The latter uses the standard deviation of the distribution of the variable as well, so that the larger samples are taken from the strata that has the greatest variability to generate the least possible sampling variance. The advantages of using STS include smaller error in estimation (if measurements within strata have lower standard deviation) and similarity in uncertainties across all strata in case there is high variability in a given strata.</p> <p>NOTE: STS is only useful if the population can be exhaustively partitioned into subgroups. Also in case of unknown class priors (the ratio of strata to the whole population) might have deleterious effects on the classification performance.</p> <p>Over- and undersampling Oversampling randomly duplicates minority class samples, while undersampling discards majority class samples in order to modify the class distribution. While oversampling might lead to overfitting, since it makes exact copies of the minority samples, undersampling may discard potentially useful majority samples.</p> <p>Oversampling and undersampling are essentially opposite and roughly equivalent techniques. There are also more complex oversampling techniques, including the creation of artificial data points with algorithms like Synthetic Minority Over-sampling TEchnique (SMOTE). </p> <p>It has been shown that the combination of SMOTE and undersampling performs better than only undersampling the majority class. However, over- and undersampling remain popular as it each is much easier to implement alone than in some complex hybrid approach.</p> <p>Synthetic Minority Over-sampling Technique (SMOTE) Text mostly based on Chawla et al., 2002 and in part on He et al., 2010</p> <p>In case of Synthetic Minority Over-sampling Technique (SMOTE), the minority class is oversampled by creating synthetic examples along the line segments joining any or all of the \\(k\\)-nearest neighbours in the minority class. The synthetic examples cause the classifier to create larger and less specific decision regions, rather than smaller and more specific regions. More general regions are now learned for the minority class samples rather than those being subsumed by the majority class samples around them. In this way SMOTE shifts the classifier learning bias toward the minority class and thus has the effect of allowing the model to generalize better.</p> <p>There also exist extensions of this work like SMOTE-Boost in which the syntetic procedure was integrated with adaptive boosting techniques to change the method of updating weights to better compensate for skewed distributions.</p> <p>So in general SMOTE proceeds as follows <pre><code>SMOTE(N, X, k)\nInput: N - Number of synthetic samples to be generated\n       X - Underrepresented data\n       k - Hyperparameter of number of nearest neighbours to be chosen\n\nCreate an empty list SYNTHETIC_SAMPLES\nWhile N_SYNTHETIC_SAMPLES &lt; N\n    1. Randomly choose an entry xRand from X\n    2. Find k nearest neighbours from X\n    3. Randomly choose an entry xNeighbour from the k nearest neighbours\n    4. Take difference dx between the xRand and xNeighbour\n    5. Multiply dx by a random number between 0 and 1\n    6. Append the result to SYNTHETIC_SAMPLES\nExtend X by SYNTHETIC_SAMPLES\n</code></pre></p> <p>Adaptive synthetic sampling approach (ADASYN) Text mostly based on He et al., 2010</p> <p>Adaptive synthetic sampling approach (ADASYN) is a sampling approach for learning from imbalanced datasets. The main idea is to use a weighted distribution for different minority class examples according to their level of difficulty in learning, where more synthetic data is generated for minority class examples that are harder to learn compared to those minority examples that are easier to learn. Thus, ADASYN improves learning with respect to the data distributions by reducing the bias introduced by the class imbalance and by adaptively shifting the classification boundary toward the difficult examples.</p> <p>The objectives of ADASYN are reducing bias and learning adaptively. The key idea of this algorithm is to use a density distribution as a criterion to decide the number of synthetic samples that need to be generated for each minority data example. Physically, this density distribution is a distribution of weights for different minority class examples according to their level of difficulty in learning. The resulting dataset after using ADASYN will not only provide a balanced representation of the data distribution (according to the desired balance level defined in the configuration), but it also forces the learning algorithm to focus on those difficult to learn examples. It has been shown He et al., 2010, that this algorithm improves accuracy for both minority and majority classes and does not sacrifice one class in preference for another.</p> <p>ADASYN is not limited to only two-class learning, but can also be generalized to multiple-class imbalanced learning problems as well as incremental learning applications.</p> <p>For more details and comparisons of ADASYN to other algorithms, please see He et al., 2010.</p>"},{"location":"optimization/data_augmentation.html#existing-implementations","title":"Existing implementations","text":"<p>Imbalanced-learn is an open-source Python library which provides a suite of algorithms for treating the class imbalance problem.</p> <p>For augmentig image data, one can use of of the following:</p> <ul> <li>Albumentations</li> <li>ImgAug</li> <li>Autoaugment</li> <li>Augmentor</li> <li>DeepAugmnent</li> </ul> <p>But it is also possible to use tools directly implemented by tensorflow, keras etc. For example:</p> <pre><code>flipped_image = tf.image.flip_left_right(image)\n</code></pre>"},{"location":"optimization/data_augmentation.html#deep-learning-based-sda-techniques","title":"Deep Learning-based SDA Techniques","text":"<p>In data science, data augmentation techniques are used to increase the amount of data by either synthetically creating data from already existing samples via a GAN or modifying the data at hand with small noise or rotation. (Rebuffi et al., 2021)</p> <p>More recently, data augmentation studies have begun to focus on the field of deep learning (DL), more specifically on the ability of generative models, like Generative Adversarial Networks (GANs) and Variational Autoencoders (VAEs), to create artificial data. This synthetic data is then introduced during the classification model training process to improve performance and results.</p> <p>Generative Adversarial Networks (GANs) The following text is written based on the works by Musella &amp; Pandolfi, 2018 and Hashemi et al., 2019 and Kansal et al., 2022 and Rehm et al., 2021 and Choi &amp; Lim, 2021 and Kansal et al., 2020</p> <p>GANs have been proposed as a fast and accurate way of modeling high energy jet formation (Paganini et al., 2017a) and modeling showers throughcalorimeters of high-energy physics experiments (Paganini et al., 2017 ; Paganini et al., 2012;  Erdman et al., 2020; Musella &amp; Pandolfi, 2018) GANs have also been trained to accurately approximate bottlenecks in computationally expensive simulations of particle physics experiments. Applications in the context of present and proposed CERN experiments have demonstrated the potential of these methods for accelerating simulation and/or improving simulation fidelity (ATLAS Collaboration, 2018;  SHiP Collaboration, 2019).</p> <p>The generative model approximates the combined response of aparticle detecor simulation and reconstruction algorithms to hadronic jets given the latent space of uniformly distributed noise, auxiliary features and jet image at particle level (jets clustered from the list of stable particles produced by PYTHIA).</p> <p>In the paper by Musella &amp; Pandolfi, 2018, the authors apply generative models parametrized by neural networks (GANs in particular) to the simulation of particles-detector response to hadronic jets. They show that this parametrization achieves high-fidelity while increasing the processing speed by several orders of magnitude.</p> <p>Their model is trained to be capable of predicting the combined effect of particle-detector simulation models and reconstruction algorithms to hadronic jets.</p> <p>Generative adversarial networks (GANs) are pairs of neural networks, a generative and a discriminative one, that are trained concurrently as players of a minimax game (Musella &amp; Pandolfi, 2018). The task of the generative network is to produce, starting from a latent space with a fixed distribution, samples that the discriminative model tries to distinguish from samples drawn from a target dataset. This kind of setup allows the distribution of the target dataset to be learned, provided that both of the networks have high enough capacity.</p> <p>The input to these networks are hadronic jets, represented as \"gray-scale\" images of fixed size centered around the jet axis, with the pixel intensity corresponding to the energy fraction in a given cell. The architectures of the networks are based on the image-to-image translation. There few differences between this approach and image-to-image translation. Firstly, non-empty pixels are explicitly modelled in the generated images since these are much sparser than the natural ones. Secondly, feature matching and a dedicated adversarial classifier enforce good modelling of the total pixel intensity (energy). Lastly, the generator is conditioned on some auxiliary inputs.</p> <p>By predicting directly the objects used at analysis level and thus reproducing the output of both detector simulation and reconstruction algorithms, computation time is reduced. This kind of philosophy is very similar to parametrized detector simulations, which are used in HEP for phenomenological studies. The attained accuracies are comparable to the full simulation and reconstruction chain.</p>"},{"location":"optimization/data_augmentation.html#variational-autoencoders-vaes","title":"Variational autoencoders (VAEs)","text":"<p>The following section is partly based on Otten et al., 2021</p> <p>In contrast to the traditional autoencoder (AE) that outputs a single value for each encoding dimension, variational autoencoders (VAEs) provide a probabilistic interpretation for describing an observation in latent space.</p> <p>In case of VAEs, the encoder model is sometimes referred to as the recognition model and the decoder model as generative model.</p> <p>By constructing the encoder model to output a distribution of the values from which we randomly sample to feed into our decoder model, we are enforcing a continuous, smooth latent space representation. Thus we expect our decoder model to be able to accurately reconstruct the input for any sampling of the latent distributions, which then means that values residing close to each other in latent space should have very similar reconstructions.</p>"},{"location":"optimization/data_augmentation.html#ml-powered-data-generation-for-fast-simulation","title":"ML-powered Data Generation for Fast Simulation","text":"<p>The following text is based on this Chen et al., 2020</p> <p>We rely on accurate simulation of physics processes, however currently it is very common for LHC physics to be affected by large systematic uncertanties due to the limited amount of simulated data, especially for precise measurements of SM processes for which large datasets are already available. So far the most widely used simulator is GEANT4 that provides state-of-the-art accuracy. But running this is demanding, both in terms of time and resources. Consequently, delivering synthetic data at the pace at which LHC delivers real data is one of the most challenging tasks for computing infrastructures of the LHC experiments. The typical time it takes to simulate one single event is in the ballpark of 100 seconds.</p> <p>Recently, generative algorithms based on deep learning have been proposed as a possible solution to speed up GEANT4. However, one needs to work beyond the collision-as-image paradigm so that the DL-based simulation accounts for the irregular geometry of a typical detector while delivering a dataset in a format compatible with downstream reconstruction software.</p> <p>One method to solve this bottleneck was proposed by Chen et al., 2020. They adopt a generative DL model to convert an analysis specific representation of collision events at generator level to the corresponding representation at reconstruction level. Thus, this novel, fast-simulation workflow starts from a large amount of generator-level events to deliver large analysis-specific samples.</p> <p>They trained a neural network to model detector resolution effects as a transfer function acting on an analysis-specific set of relevant features, computed at generator level. However, their model does not sample events from a latent space (like a GAN or a plain VAE). Instead, it works as a fast simulator of a given generator-level event, preserving the correspondence between the reconstructed and the generated event, which allows us to compare event-by-event residual distributions. Furthermore, this model is much simpler than a generative model.</p> <p>Step one in this workflow is generating events in their full format, which is the most resource heavy task, where, as noted before, generating one event takes roughly 100 seconds. However, with this new proposed method O(1000) events are generated per second. This would save on storage: for the full format O(1) MB/event is needed, where for the DL model only 8 MB was used to store 100000 events. To train the model, they used NVIDIA RTX2080 and it trained for 30 minutes, which in terms of overall production time is negligible. For generating N=1M events and n=10%N, one would save 90% of the CPU resources and 79% of the disk storage. Thus augmenting the centrally produced data is a viable method and could help the HEP community to face the computing challenges of the High-Luminosity LHC.</p> <p>Another more extreme approach investigated the use of GANs and VAEs for generating physics quantities which are relevant to a specific analysis. In this case, one learns the N-dimensional density function of the event, in a space defined by the quantities of interest for a given analysis. So sampling from this function, one can generate new data. Trade-off between statistical precision (decreases with the increasing amount of generated events) and the systematic uncertainty that could be induced by a non accurate description of the n-dim pdf.</p> <p>Qualitatively, no accuracy deterioration was observed due to scaling the dataset size for DL. This fact proves the robustness of the proposed methodology and its effectiveness for data augmentation.</p>"},{"location":"optimization/data_augmentation.html#open-challenges-in-data-augmentation","title":"Open challenges in Data Augmentation","text":"<p>Excerpts are taken from Li, 2020</p> <p>The limitations of conventional data augmentation approaches reveal huge opportunities for research advances. Below we summarize a few challenges that motivate some of the works in the area of data augmentation.</p> <ul> <li>From manual to automated search algorithms: As opposed to performing suboptimal manual search, how can we design learnable algorithms to find augmentation strategies that can outperform human-designed heuristics?</li> <li>From practical to theoretical understanding: Despite the rapid progress of creating various augmentation approaches pragmatically, understanding their benefits remains a mystery because of a lack of analytic tools. How can we theoretically understand various data augmentations used in practice?</li> <li>From coarse-grained to fine-grained model quality assurance: While most existing data augmentation approaches focus on improving the overall performance of a model, it is often imperative to have a finer-grained perspective on critical subpopulations of data. When a model exhibits inconsistent predictions on important subgroups of data, how can we exploit data augmentations to mitigate the performance gap in a prescribed way?</li> </ul>"},{"location":"optimization/data_augmentation.html#references","title":"References","text":"<ul> <li>Shorten &amp; Khoshgoftaar, 2019, \"A survey on Image Data Augmentationfor Deep Learning\"</li> <li>Freer &amp; Yang, 2020, \"Data augmentation for self-paced motor imagery classification with C-LSTM\"</li> <li>Li, 2020, \"Automating Data Augmentation: Practice, Theory and New Direction\"</li> <li>Rebuffi et al., 2021, \"Data Augmentation Can Improve Robustness\"</li> </ul> <ul> <li>Erdmann et al., 2018, \"Lorentz Boost Networks: Autonomous Physics-Inspired Feature Engineering\"</li> <li>Dolan &amp; Ore, 2021, \"Meta-learning and data augmentation for mass-generalised jet taggers\"</li> <li>Bradshaw et al., 2019, \"Mass agnostic jet taggers\"</li> <li>Chang et al., 2018, \"What is the Machine Learning?\"</li> <li>Oliveira et al. 2017, \"Jet-Images \u2013 Deep Learning Edition\"</li> <li>Barnard et al., 2016, \"Parton Shower Uncertainties in Jet Substructure Analyses with Deep Neural Networks\"</li> <li>Chen et al., 2020, \"Data augmentation at the LHC through analysis-specific fast simulation with deep learning\"</li> </ul> <ul> <li>Musella &amp; Pandolfi, 2018, \"Fast and accurate simulation of particle detectors using generative adversarial networks\"</li> <li>Hashemi et al., 2019, \"LHC analysis-specific datasets with Generative Adversarial Networks\"</li> <li>Kansal et al., 2022, \"Particle Cloud Generation with Message Passing Generative Adversarial Networks\"</li> <li>Rehm et al., 2021, \"Reduced Precision Strategies for Deep Learning: A High Energy Physics Generative Adversarial Network Use Case\"</li> <li>Choi &amp; Lim, 2021, \"A Data-driven Event Generator for Hadron Colliders using Wasserstein Generative Adversarial Network\"</li> <li>Kansal et al., 2020, \"Graph Generative Adversarial Networks for Sparse Data Generation in High Energy Physics\"</li> <li>Otten et al., 2021, \"Event Generation and Statistical Sampling for Physics with Deep Generative Models and a Density Information Buffer\"</li> <li>Yap et al., 2013, \"An Application of Oversampling, Undersampling, Bagging and Boosting in Handling Imbalanced Datasets\"</li> <li>Au et al., 2010, \"Mining Rare Events Data by Sampling and Boosting: A Case Study\"</li> <li>Chawla et al., 2002, \"SMOTE: Synthetic Minority Over-sampling Technique\"</li> <li>He et al., 2010, \"ADASYN: Adaptive Synthetic Sampling Approach for Imbalanced Learning\"</li> <li>Erdman et al., 2020, \"Precise simulation of electromagnetic calorimeter showers using a Wasserstein Generative Adversarial Network\"</li> <li>Paganini et al., 2012, \"CaloGAN: Simulating 3D High Energy Particle Showers in Multi-Layer Electromagnetic Calorimeters with Generative Adversarial Networks\"</li> <li>Paganini et al., 2017, \"Accelerating Science with Generative Adversarial Networks: An Application to 3D Particle Showers in Multi-Layer Calorimeters\"</li> <li>Paganini et al., 2017, \"Learning Particle Physics by Example: Location-Aware Generative Adversarial Networks for Physics Synthesis\"</li> <li>ATLAS Collaboration, 2018, \"Deep generative models for fast shower simulation in ATLAS\"</li> <li>SHiP Collaboration, 2019, \"Fast simulation of muons produced at the SHiP experiment using Generative Adversarial Networks\"</li> </ul> <p>Content may be edited and published elsewhere by the author.</p> <p>Page author: Laurits Tani, 2022</p>"},{"location":"optimization/importance.html","title":"Feature Importance","text":"<p>Feature importance is the impact a specific input field has on a prediction model's output. In general, these impacts can range from no impact (i.e. a feature with no variance) to perfect correlation with the ouput. There are several reasons to consider feature importance: </p> <ul> <li>Important features can be used to create simplified models, e.g. to mitigate overfitting.</li> <li>Using only important features can reduce the latency and memory requirements of the model. </li> <li>The relative importance of a set of features can yield insight into the nature of an otherwise opaque model (improved interpretability). </li> <li>If a model is sensitive to noise, rejecting irrelevant inputs may improve its performance. </li> </ul> <p>In the following subsections, we detail several strategies for evaluating feature importance. We begin with a general discussion of feature importance at a high level before offering a code-based tutorial on some common techniques. We conclude with additional notes and comments in the last section. </p>"},{"location":"optimization/importance.html#general-discussion","title":"General Discussion","text":"<p>Most feature importance methods fall into one of three broad categories: filter methods, embedding methods, and wrapper methods. Here we give a brief overview of each category with relevant examples: </p>"},{"location":"optimization/importance.html#filter-methods","title":"Filter Methods","text":"<p>Filter methods do not rely on a specific model, instead considering features in the context of a given dataset. In this way, they may be considered to be pre-processing steps. In many cases, the goal of feature filtering is to reduce high dimensional data. However, these methods are also applicable to data exploration, wherein an analyst simply seeks to learn about a dataset without actually removing any features. This knowledge may help interpret the performance of a downstream predictive model. Relevant examples include, </p> <ul> <li> <p>Domain Knowledge: Perhaps the most obvious strategy is to select features relevant to the domain of interest. </p> </li> <li> <p>Variance Thresholding: One basic filtering strategy is to simply remove features with low variance. In the extreme case, features with zero variance do not vary from example to example, and will therefore have no impact on the model's final prediction. Likewise, features with variance below a given threshold may not affect a model's downstream performance.</p> </li> <li> <p>Fisher Scoring: Fisher scoring can be used to rank features; the analyst would then select the highest scoring features as inputs to a subsequent model. </p> </li> <li> <p>Correlations: Correlated features introduce a certain degree of redundancy to a dataset, so reducing the number of strongly correlated variables may not impact a model's downstream performance. </p> </li> </ul>"},{"location":"optimization/importance.html#embedded-methods","title":"Embedded Methods","text":"<p>Embedded methods are specific to a prediction model and independent of the dataset. Examples:</p> <ul> <li>L1 Regularization (LASSO): L1 regularization directly penalizes large model weights. In the context of linear regression, for example, this amounts to enforcing sparsity in the output prediction; weights corresponding to less relevant features will be driven to 0, nullifying the feature's effect on the output. </li> </ul>"},{"location":"optimization/importance.html#wrapper-methods","title":"Wrapper Methods","text":"<p>Wrapper methods iterate on prediction models in the context of a given dataset. In general they may be computationally expensive when compared to filter methods. Examples:</p> <ul> <li>Permutation Importance: Direct interpretation isn't always feasible, so other methods have been developed to inspect a feature's importance. One common and broadly-applicable method is to randomly shuffle a given feature's input values and test the degredation of model performance. This process allows us to measure permutation importance as follows. First, fit a model (\\(f\\)) to training data, yielding \\(f(X_\\mathrm{train})\\), where \\(X_\\mathrm{train}\\in\\mathbb{R}^{n\\times d}\\) for \\(n\\) input examples with \\(d\\) features. Next, measure the model's performance on testing data for some loss \\(\\mathcal{L}\\), i.e. \\(s=\\mathcal{L}\\big(f(X_\\mathrm{test}), y_\\mathrm{test}\\big)\\). For each feature \\(j\\in[1\\ ..\\ d]\\), randomly shuffle the corresponding column in \\(X_\\mathrm{test}\\) to form \\(X_\\mathrm{test}^{(j)}\\). Repeat this process \\(K\\) times, so that for \\(k\\in [1\\ ..\\ K]\\) each random shuffling of feature column \\(j\\) gives a corrupted input dataset \\(X_\\mathrm{test}^{(j,k)}\\). Finally, define the permutation importance of feature \\(j\\) as the difference between the un-corrupted validation score and average validation score over the corrupted \\(X_\\mathrm{test}^{(j,k)}\\) datasets: </li> </ul> \\[\\texttt{PI}_j = s - \\frac{1}{K}\\sum_{k=1}^{K} \\mathcal{L}[f(X_\\mathrm{test}^{(j,k)}), y_\\mathrm{test}]\\] <ul> <li>Recursive Feature Elimination (RFE): Given a prediction model and test/train dataset splits with \\(D\\) initial features, RFE returns the set of \\(d &lt; D\\) features that maximize model performance. First, the model is trained on the full set of features. The importance of each feature is ranked depending on the model type (e.g. for regression, the slopes are a sufficient ranking measure; permutation importance may also be used). The least important feature is rejected and the model is retrained. This process is repeated until the most significant \\(d\\) features remain. </li> </ul>"},{"location":"optimization/importance.html#introduction-by-example","title":"Introduction by Example","text":""},{"location":"optimization/importance.html#direct-interpretation","title":"Direct Interpretation","text":"<p>Linear regression is particularly interpretable because the prediction coefficients themselves can be interpreted as a measure of feature importance. Here we will compare this direct interpretation to several model inspection techniques. In the following examples we use the Diabetes Dataset available as a Scikit-learn toy dataset. This dataset maps 10 biological markers to a 1-dimensional quantitative measure of diabetes progression: </p> <p><pre><code>from sklearn.datasets import load_diabetes\nfrom sklearn.model_selection import train_test_split\n\ndiabetes = load_diabetes()\nX_train, X_val, y_train, y_val = train_test_split(diabetes.data, diabetes.target, random_state=0)\nprint(X_train.shape)\n&gt;&gt;&gt; (331,10)\nprint(y_train.shape)\n&gt;&gt;&gt; (331,)\nprint(X_val.shape)\n&gt;&gt;&gt; (111, 10)\nprint(y_val.shape)\n&gt;&gt;&gt; (111,)\nprint(diabetes.feature_names)\n['age', 'sex', 'bmi', 'bp', 's1', 's2', 's3', 's4', 's5', 's6']\n</code></pre> To begin, let's use Ridge Regression (L2-regularized linear regression) to model diabetes progression as a function of the input markers. The absolute value of a regression coefficient (slope) corresponding to a feature can be interpreted the impact of a feature on the final fit:</p> <p><pre><code>from sklearn.linear_model import Ridge\nfrom sklearn.feature_selection import RFE\n\nmodel = Ridge(alpha=1e-2).fit(X_train, y_train)\nprint(f'Initial model score: {model.score(X_val, y_val):.3f}')\n\nfor i in np.argsort(-abs(model.coef_)):\n    print(diabetes.feature_names[i], abs(model.coef_[i]))\n\n&gt;&gt;&gt; Initial model score: 0.357\n&gt;&gt;&gt; bmi: 592.253\n&gt;&gt;&gt; s5: 580.078\n&gt;&gt;&gt; bp: 297.258\n&gt;&gt;&gt; s1: 252.425\n&gt;&gt;&gt; sex: 203.436\n&gt;&gt;&gt; s3: 145.196\n&gt;&gt;&gt; s4: 97.033\n&gt;&gt;&gt; age: 39.103\n&gt;&gt;&gt; s6: 32.945\n&gt;&gt;&gt; s2: 20.906\n</code></pre> These results indicate that the bmi and s5 fields have the largest impact on the output of this regression model, while age, s6, and s2 have the smallest. Further interpretation is subject to the nature of the input data (see Common Pitfalls in the Interpretation of Coefficients of Linear Models). Note that scikit-learn has tools available to faciliate feature selections. </p>"},{"location":"optimization/importance.html#permutation-importance","title":"Permutation Importance","text":"<p>In the context of our ridge regression example, we can calculate the permutation importance of each feature as follows (based on scikit-learn docs):</p> <p><pre><code>from sklearn.inspection import permutation_importance\n\nmodel = Ridge(alpha=1e-2).fit(X_train, y_train)\nprint(f'Initial model score: {model.score(X_val, y_val):.3f}')\n\nr = permutation_importance(model, X_val, y_val, n_repeats=30, random_state=0)\nfor i in r.importances_mean.argsort()[::-1]:\n    print(f\"{diabetes.feature_names[i]:&lt;8}\"\n          f\"{r.importances_mean[i]:.3f}\"\n          f\" +/- {r.importances_std[i]:.3f}\")\n\n&gt;&gt;&gt; Initial model score: 0.357\n&gt;&gt;&gt; s5      0.204 +/- 0.050\n&gt;&gt;&gt; bmi     0.176 +/- 0.048\n&gt;&gt;&gt; bp      0.088 +/- 0.033\n&gt;&gt;&gt; sex     0.056 +/- 0.023\n&gt;&gt;&gt; s1      0.042 +/- 0.031\n&gt;&gt;&gt; s4      0.003 +/- 0.008\n&gt;&gt;&gt; s6      0.003 +/- 0.003\n&gt;&gt;&gt; s3      0.002 +/- 0.013\n&gt;&gt;&gt; s2      0.002 +/- 0.003\n&gt;&gt;&gt; age     -0.002 +/- 0.004\n</code></pre> These results are roughly consistent with the direct interpretation of the linear regression parameters; s5 and bmi are the most permutation-important features. This is because both have significant permutation importance scores (0.204, 0.176) when compared to the initial model score (0.357), meaning their random permutations significantly degraded the model perforamnce. On the other hand, s2 and age have approximately no permutation importance, meaning that the model's performance was robust to random permutations of these features. </p>"},{"location":"optimization/importance.html#l1-enforced-sparsity","title":"L1-Enforced Sparsity","text":"<p>In some applications it may be useful to reject features with low importance. Models biased towards sparsity are one way to achieve this goal, as they are designed to ignore a subset of features with the least impact on the model's output. In the context of linear regression, sparsity can be enforced by imposing L1 regularization on the regression coefficients (LASSO regression):</p> \\[\\mathcal{L}_\\mathrm{LASSO} = \\frac{1}{2n}||y - Xw||^2_2 + \\alpha||w||_1\\] <p>Depending on the strength of the regularization \\((\\alpha)\\), this loss function is biased to zero-out features of low importance. In our diabetes regression example, </p> <p><pre><code>model = Lasso(alpha=1e-1).fit(X_train, y_train)\nprint(f'Model score: {model.score(X_val, y_val):.3f}')\n\nfor i in np.argsort(-abs(model.coef_)):\n    print(f'{diabetes.feature_names[i]}: {abs(model.coef_[i]):.3f}')\n\n&gt;&gt;&gt; Model score: 0.355\n&gt;&gt;&gt; bmi: 592.203\n&gt;&gt;&gt; s5: 507.363\n&gt;&gt;&gt; bp: 240.124\n&gt;&gt;&gt; s3: 219.104\n&gt;&gt;&gt; sex: 129.784\n&gt;&gt;&gt; s2: 47.628\n&gt;&gt;&gt; s1: 41.641\n&gt;&gt;&gt; age: 0.000\n&gt;&gt;&gt; s4: 0.000\n&gt;&gt;&gt; s6: 0.000\n</code></pre> For this value of \\(\\alpha\\), we see that the model has rejected the age, s4, and s6 features as unimportant (consistent with the permutation importance measures above) while achieving a similar model score as the previous ridge regression strategy. </p>"},{"location":"optimization/importance.html#recursive-feature-elimination","title":"Recursive Feature Elimination","text":"<p>Another common strategy is recursive feature elimination (RFE). Though RFE can be used for regression applications as well, we turn our attention to a classification task for the sake of variety. The following discussions are based on the Breast Cancer Wisconsin Diagnostic Dataset, which maps 30 numeric features corresponding to digitized breast mass images to a binary classification of benign or malignant. </p> <pre><code>from sklearn.datasets import load_breast_cancer\nfrom sklearn.svm import SVC\nfrom sklearn.model_selection import StratifiedKFold\n\ndata = load_breast_cancer()\nX_train, X_val, y_train, y_val = train_test_split(data.data, data.target, random_state=0)\nprint(X_train.shape)\n&gt;&gt;&gt; (426, 30)\nprint(y_train.shape)\n&gt;&gt;&gt; (426,)\nprint(X_val.shape)\n&gt;&gt;&gt; (143, 30)\nprint(y_val.shape)\n&gt;&gt;&gt; (143,)\nprint(breast_cancer.feature_names)\n&gt;&gt;&gt; ['mean radius' 'mean texture' 'mean perimeter' 'mean area' 'mean smoothness' 'mean compactness' 'mean concavity' 'mean concave points' 'mean symmetry' 'mean fractal dimension' 'radius error' 'texture error' 'perimeter error' 'area error' 'smoothness error' 'compactness error' 'concavity error' 'concave points error' 'symmetry error' 'fractal dimension error' 'worst radius' 'worst texture' 'worst perimeter' 'worst area' 'worst smoothness' 'worst compactness' 'worst concavity' 'worst concave points' 'worst symmetry' 'worst fractal dimension']\n</code></pre> <p>Given a classifier and a classification task, recursive feature elimination (RFE, see original paper) is the process of identifying the subset of input features leading to the most performative model. Here we employ a support vector machine classifier (SVM) with a linear kernel to perform binary classification on the input data. We ask for the top \\(j\\in[1\\ .. \\ d]\\) most important features in a for loop, computing the classification accuracy when only these features are leveraged. </p> <p><pre><code>from sklearn.feature_selection import RFE\n\nfeatures = np.array(breast_cancer.feature_names)\nsvc = SVC(kernel='linear')\nfor n_features in np.arange(1, 30, 1):\n    rfe = RFE(estimator=svc, step=1, n_features_to_select=n_features)\n    rfe.fit(X_train, y_train)\n    print(f'n_features={n_features}, accuracy={rfe.score(X_val, y_val):.3f}')\n    print(f' - selected: {features[rfe.support_]}')\n\n&gt;&gt;&gt; n_features=1, accuracy=0.881\n&gt;&gt;&gt;  - selected: ['worst concave points']\n&gt;&gt;&gt; n_features=2, accuracy=0.874\n&gt;&gt;&gt;  - selected: ['worst concavity' 'worst concave points']\n&gt;&gt;&gt; n_features=3, accuracy=0.867\n&gt;&gt;&gt;  - selected: ['mean concave points' 'worst concavity' 'worst concave points']\n ...\n&gt;&gt;&gt; n_features=16, accuracy=0.930\n&gt;&gt;&gt; n_features=17, accuracy=0.965\n&gt;&gt;&gt; n_features=18, accuracy=0.951\n...\n&gt;&gt;&gt; n_features=27, accuracy=0.958\n&gt;&gt;&gt; n_features=28, accuracy=0.958\n&gt;&gt;&gt; n_features=29, accuracy=0.958\n</code></pre> Here we've shown a subset of the output. In the first output lines, we see that the 'worst concave points' feature alone leads to 88.1% accuracy. Including the next two most important features actually degrades the classification accuracy. We then skip to the top 17 features, which in this case we observe to yield the best performance for the linear SVM classifier. The addition of more features does not lead to additional perforamnce boosts. In this way, RFE can be treated as a model wrapper introducing an additional hyperparameter, n_features_to_select, which can be used to optimize model performance. A more principled optimization using k-fold cross validation with RFE is available in the scikit-learn docs. </p>"},{"location":"optimization/importance.html#feature-correlations","title":"Feature Correlations","text":"<p>In the above, we have focused specifically on interpreting the importance of single features. However, it may be that several features are correlated, sharing the responsibility for the overall prediction of the model. In this case, some measures of feature importance may inappropriately downweight correlated features in a so-called correlation bias (see Classification with Correlated Features: Unrelability of Feature Ranking and Solutions). For example, the permutation invariance of \\(d\\) correlated features is shown to decrease (as a function of correlation strength) faster for higher \\(d\\) (see Correlation and Variable importance in Random Forests). </p> <p>We can see these effects in action using the breast cancer dataset, following the corresponding scikit-learn example</p> <p><pre><code>from sklearn.ensemble import RandomForestClassifier\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.datasets import load_breast_cancer\n\ndata = load_breast_cancer()\nX, y = data.data, data.target\nX_train, X_test, y_train, y_test = train_test_split(X, y, random_state=42)\n\nclf = RandomForestClassifier(n_estimators=100, random_state=42)\nclf.fit(X_train, y_train)\nprint(\"Accuracy on test data: {:.2f}\".format(clf.score(X_test, y_test)))\n\n&gt;&gt;&gt; Accuracy on test data: 0.97\n</code></pre> Here we've implemented a random forest classifier and achieved a high accuracy (97%) on the benign vs. malignent predictions. The permutation importances for the 10 most important training features are:</p> <pre><code>r = permutation_importance(clf, X_train, y_train, n_repeats=10, random_state=42)\nfor i in r.importances_mean.argsort()[::-1][:10]:\n    print(f\"{breast_cancer.feature_names[i]:&lt;8}\"\n          f\"  {r.importances_mean[i]:.5f}\"\n          f\" +/- {r.importances_std[i]:.5f}\")\n\n&gt;&gt;&gt; worst concave points  0.00681 +/- 0.00305\n&gt;&gt;&gt; mean concave points  0.00329 +/- 0.00188\n&gt;&gt;&gt; worst texture  0.00258 +/- 0.00070\n&gt;&gt;&gt; radius error  0.00235 +/- 0.00000\n&gt;&gt;&gt; mean texture  0.00188 +/- 0.00094\n&gt;&gt;&gt; mean compactness  0.00188 +/- 0.00094\n&gt;&gt;&gt; area error  0.00188 +/- 0.00094\n&gt;&gt;&gt; worst concavity  0.00164 +/- 0.00108\n&gt;&gt;&gt; mean radius  0.00141 +/- 0.00115\n&gt;&gt;&gt; compactness error  0.00141 +/- 0.00115\n</code></pre> <p>In this case, even the most permutation important features have mean importance scores \\(&lt;0.007\\), which doesn't indicate much importance. This is surprising, because we saw via RFE that a linear SVM can achieve \\(\\approx 88\\%\\) classification accuracy with this feature alone. This indicates that worst concave points, in addition to other meaningful features, may belong to subclusters of correlated features. In the corresponding scikit-learn example, the authors show that subsets of correlated features can be extracted by calculating a dendogram and selecting representative features from each correlated subset. They achieve \\(97\\%\\) accuracy (the same as with the full dataset) by selecting only five such representative variables. </p>"},{"location":"optimization/importance.html#feature-importance-in-decision-trees","title":"Feature Importance in Decision Trees","text":"<p>Here we focus on decision trees, which are particularly interpretable classifiers that often appear as ensembles (or boosted decision tree (BDT) algorithms) in HEP. Consider a classification dataset \\(X=\\{x_n\\}_{n=1}^{N}\\), \\(x_n\\in\\mathbb{R}^{D}\\), with truth labels \\(Y=\\{y_n\\}_{n=1}^N\\), \\(y_n\\in\\{1,...,C\\}\\) corresponding \\(C\\) classes. These truth labels naturally partition \\(X\\) into subsets \\(X_c\\) with class probabilities \\(p(c)=|X_c|/|X|\\). Decision trees begin with a root node \\(t_0\\) containing all of \\(X\\). The tree is grown from the root by recursively splitting the input set \\(X\\) in a principled way; internal nodes (or branch nodes) correspond to a decision of the form </p> \\[\\begin{aligned} &amp;(x_n)_d\\leq\\delta \\implies\\ \\text{sample}\\ n\\ \\text{goes to left child node}\\\\ &amp;(x_n)_d&gt;\\delta \\implies\\ \\text{sample}\\ n\\ \\text{goes to right child node} \\end{aligned}\\] <p>We emphasize that the decision boundary is drawn by considering a single feature field \\(d\\) and partitioning the \\(n^\\mathrm{th}\\) sample by the value at that feature field. Decision boundaries at each internal parent node \\(t_P\\) are formed by choosing a \"split criterion,\" which describes how to partition the set of elements at this node into left and right child nodes \\(t_L\\), \\(t_R\\) with \\(X_{t_L}\\subset X_{t_P}\\) and \\(X_{t_R}\\subset X_{t_P}\\), \\(X_{t_L}\\cup X_{t_R}=X_{t_P}\\). This partitioning is optimal if \\(X_{t_L}\\) and \\(X_{t_R}\\) are pure, each containing only members of the same class. Impurity measures are used to evaluate the degree to which the set of data points at a given tree node \\(t\\) are not pure. One common impurity measure is Gini Impurity, </p> \\[\\begin{aligned}  I(t) = \\sum_{c=1}^C p(c|t)(1-p(c|t)) \\end{aligned}\\] <p>Here, \\(p(c|t)\\) is the probability of drawing a member of class \\(c\\) from the set of elements at node \\(t\\). For example, the Gini impurity at the root node (corresponding to the whole dataset) is </p> \\[\\begin{aligned}  I(t_0) = \\sum_{c=1}^C \\frac{|X_c|}{|X|}(1-\\frac{|X_c|}{|X|}) \\end{aligned}\\] <p>In a balanced binary dataset, this would give \\(I(t_0)=1/2\\). If the set at node \\(t\\) is pure, i.e. class labels corresponding to \\(X_t\\) are identical, then \\(I(t)=0\\). We can use \\(I(t)\\) to produce an optimal splitting from parent \\(t_p\\) to children \\(t_L\\) and \\(t_R\\) by defining an impurity gain, </p> \\[\\begin{aligned} \\Delta I = I(t_P) - I(t_L) - I(t_R) \\end{aligned}\\] <p>This quantity describes the relative impurity between a parent node and its children. If \\(X_{t_P}\\) contains only two classes, an optimal splitting would separate them into \\(X_{p_L}\\) and \\(X_{p_R}\\), producing pure children nodes with \\(I(t_L)=I(t_R)=0\\) and, correspondingly, \\(\\Delta I(t_p) = I(t_P)\\). Accordingly, good splitting decisions should maximize impurity gain. Note that the impurity gain is often weighted, for example Scikit-Learn defines:</p> \\[\\begin{aligned} \\Delta I(t_p) = \\frac{|X_{t_p}|}{|X|}\\bigg(I(t_p) - \\frac{|X_{t_L}|}{|X_{t_p}|} I(t_L) - \\frac{|X_{t_R}|}{|X_{t_p}|} I(t_R) \\bigg) \\end{aligned}\\] <p>In general, a pure node cannot be split further and must therefore be a leaf. Likewise, a node for which there is no splitting yielding \\(\\Delta I &gt; 0\\) must be labeled a leaf. These splitting decisions are made recursively at each node in a tree until some stopping condition is met. Stopping conditions may include maximum tree depths or leaf node counts, or threshhold on the maximum impurity gain. </p> <p>Impurity gain gives us insight into the importance of a decision. In particular, larger \\(\\Delta I\\) indicates a more important decision. If some feature \\((x_n)_d\\) is the basis for several decision splits in a decision tree, the sum of impurity gains at these splits gives insight into the importance of this feature. Accordingly, one measure of the feature importance of \\(d\\) is the average (with respect to the total number of internal nodes) impurity gain imparted by decision split on \\(d\\). This method generalizes to the case of BDTs, in which case one would average this quantity across all weak learner trees in the ensemble. </p> <p>Note that though decision trees are based on the feature \\(d\\) producing the best (maximum impurity gain) split at a given branch node, surrogate splits are often used to retain additional splits corresponding to features other than \\(d\\). Denote the feature maximizing the impurity gain \\(d_1\\) and producing a split boundary \\(\\delta_1\\). Surrogte splitting involves tracking secondary splits with boundaries \\(\\delta_2, \\delta_3,...\\) corresponding to \\(d_2,d_3,...\\) that have the highest correlation with the maximum impurity gain split. The upshot is that in the event that input data is missing a value at field \\(d_1\\), there are backup decision boundaries to use, mitigating the need to define multiple trees for similar data. Using this generalized notion of a decision tree, wherein each branch node contains a primary decision boundary maximizing impurity gain and several additional surrogate split boundaries, we can average the impurity gain produced at feature field \\(d\\) over all its occurances as a decision split or a surrogate split. This definition of feature importance generalizes the previous to include additional correlations. </p>"},{"location":"optimization/importance.html#example","title":"Example","text":"<p>Let us now turn to an example:  <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.datasets import load_wine\nfrom sklearn.inspection import DecisionBoundaryDisplay\nfrom sklearn.metrics import log_loss\nfrom sklearn.model_selection import train_test_split\n\nwine_data = load_wine() \nprint(wine_data.data.shape)\nprint(wine_data.feature_names)\nprint(np.unique(wine_data.target))\n&gt;&gt;&gt; (178, 13)\n&gt;&gt;&gt; ['alcohol', 'malic_acid', 'ash', 'alcalinity_of_ash', 'magnesium', 'total_phenols', 'flavanoids', 'nonflavanoid_phenols', 'proanthocyanins', 'color_intensity', 'hue', 'od280/od315_of_diluted_wines', 'proline']\n&gt;&gt;&gt; [0 1 2]\n</code></pre></p> <p>This sklearn wine dataset has 178 entries with 13 features and truth labels corresponding to membership in one of \\(C=3\\) classes. We can train a decision tree classifier as follows: </p> <pre><code>X, y = wine_data.data, wine_data.target\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25)\nclassifier = DecisionTreeClassifier(criterion='gini', splitter='best', random_state=27)\nclassifier.fit(X_train, y_train)\nX_test_pred = classifier.predict(X_test)\nprint('Test Set Performance')\nprint('Number misclassified:', sum(X_test_pred!=y_test))\nprint(f'Accuracy: {classifier.score(X_test, y_test):.3f}')\n&gt;&gt;&gt; Test Set Performance\n&gt;&gt;&gt; Number misclassified: 0\n&gt;&gt;&gt; Accuracy: 1.000\n</code></pre> <p>In this case, the classifier has generalized perfectly, fitting the test set with \\(100\\%\\) accuracy. Let's take a look into how it makes predictions:</p> <pre><code>tree = classifier.tree_\nn_nodes = tree.node_count\nnode_features = tree.feature\nthresholds = tree.threshold\nchildren_L = tree.children_left\nchildren_R = tree.children_right\nfeature_names = np.array(wine_data.feature_names)\n\nprint(f'The tree has {n_nodes} nodes')\nfor n in range(n_nodes):\n    if children_L[n]==children_R[n]: continue # leaf node\n    print(f'Decision split at node {n}:',\n          f'{feature_names[node_features[n]]}({node_features[n]}) &lt;=',\n          f'{thresholds[n]:.2f}')\n\n&gt;&gt;&gt; The tree has 13 nodes\n&gt;&gt;&gt; Decision split at node 0: color_intensity(9) &lt;= 3.46\n&gt;&gt;&gt; Decision split at node 2: od280/od315_of_diluted_wines(11) &lt;= 2.48\n&gt;&gt;&gt; Decision split at node 3: flavanoids(6) &lt;= 1.40\n&gt;&gt;&gt; Decision split at node 5: color_intensity(9) &lt;= 7.18\n&gt;&gt;&gt; Decision split at node 8: proline(12) &lt;= 724.50\n&gt;&gt;&gt; Decision split at node 9: malic_acid(1) &lt;= 3.33\n</code></pre> <p>Here we see that several features are used to generate decision boundaries. For example, the dataset is split at the root node by a cut on the \\(\\texttt{color_intensity}\\) feature. The importance of each feature can be taken to be the average impurity gain it generates across all nodes, so we expect that one (or several) of the five unique features used at the decision splits will be the most important features by this definition. Indeed, we see,</p> <pre><code>feature_names = np.array(wine_data.feature_names)\nimportances = classifier.feature_importances_\nfor i in range(len(importances)):\n    print(f'{feature_names[i]}: {importances[i]:.3f}')\nprint('\\nMost important features', \n      feature_names[np.argsort(importances)[-3:]])\n\n&gt;&gt;&gt; alcohol: 0.000\n&gt;&gt;&gt; malic_acid: 0.021\n&gt;&gt;&gt; ash: 0.000\n&gt;&gt;&gt; alcalinity_of_ash: 0.000\n&gt;&gt;&gt; magnesium: 0.000\n&gt;&gt;&gt; total_phenols: 0.000\n&gt;&gt;&gt; flavanoids: 0.028\n&gt;&gt;&gt; nonflavanoid_phenols: 0.000\n&gt;&gt;&gt; proanthocyanins: 0.000\n&gt;&gt;&gt; color_intensity: 0.363\n&gt;&gt;&gt; hue: 0.000\n&gt;&gt;&gt; od280/od315_of_diluted_wines: 0.424\n&gt;&gt;&gt; proline: 0.165\n\n&gt;&gt;&gt; Most important features ['proline' 'color_intensity' 'od280/od315_of_diluted_wines']\n</code></pre> <p>This is an embedded method for generating feature importance - it's cooked right into the decision tree model. Let's verify these results using a wrapper method, permutation importance:</p> <pre><code>from sklearn.inspection import permutation_importance\n\nprint(f'Initial classifier score: {classifier.score(X_test, y_test):.3f}')\n\nr = permutation_importance(classifier, X_test, y_test, n_repeats=30, random_state=0)\nfor i in r.importances_mean.argsort()[::-1]:\n    print(f\"{feature_names[i]:&lt;8}\"\n          f\" {r.importances_mean[i]:.3f}\"\n          f\" +/- {r.importances_std[i]:.3f}\")\n\n&gt;&gt;&gt; Initial classifier score: 1.000\n\n&gt;&gt;&gt; color_intensity 0.266 +/- 0.040\n&gt;&gt;&gt; od280/od315_of_diluted_wines 0.237 +/- 0.049\n&gt;&gt;&gt; proline  0.210 +/- 0.041\n&gt;&gt;&gt; flavanoids 0.127 +/- 0.025\n&gt;&gt;&gt; malic_acid 0.004 +/- 0.008\n&gt;&gt;&gt; hue      0.000 +/- 0.000\n&gt;&gt;&gt; proanthocyanins 0.000 +/- 0.000\n&gt;&gt;&gt; nonflavanoid_phenols 0.000 +/- 0.000\n&gt;&gt;&gt; total_phenols 0.000 +/- 0.000\n&gt;&gt;&gt; magnesium 0.000 +/- 0.000\n&gt;&gt;&gt; alcalinity_of_ash 0.000 +/- 0.000\n&gt;&gt;&gt; ash      0.000 +/- 0.000\n&gt;&gt;&gt; alcohol  0.000 +/- 0.000\n</code></pre> <p>The tree's performance is hurt the most if the \\(\\texttt{color_intensity}\\), \\(\\texttt{od280/od315_of_diluted_wines}\\), or \\(\\texttt{proline}\\) features are permuted, consistent with the impurity gain measure of feature importance. </p>"},{"location":"optimization/model_optimization.html","title":"Model optimization","text":"<p>This page summarizes the concepts shown in a contribution on Bayesian Optimization to the ML Forum and may be edited and published elsewhere by the author.</p>"},{"location":"optimization/model_optimization.html#what-we-talk-about-when-we-talk-about-model-optimization","title":"What we talk about when we talk about model optimization","text":"<p>Given some data \\(x\\) and a family of functionals parameterized by (a vector of) parameters \\(\\theta\\) (e.g. for DNN training weights), the problem of learning consists in finding \\(argmin_\\theta Loss(f_\\theta(x) - y_{true})\\). The treatment below focusses on gradient descent, but the formalization is completely general, i.e. it can be applied also to methods that are not explicitly formulated in terms of gradient descent (e.g. BDTs). The mathematical formalism for the problem of learning is briefly explained in a contribution on statistical learning to the ML forum: for the purposes of this documentation we will proceed through two illustrations.</p> <p>The first illustration, elaborated from an image by the huawei forums shows the general idea behind learning through gradient descent in a multidimensional parameter space, where the minimum of a loss function is found by following the function's gradient until the minimum.</p> The cartoon illustrates the general idea behind gradient descent to find the minimum of a function in a multidimensional parameter space (figure elaborated from an image by the huawei forums). <p>The model to be optimized via a loss function typically is a parametric function, where the set of parameters (e.g. the network weights in neural networks) corresponds to a certain fixed structure of the network. For example, a network with two inputs, two inner layers of two neurons, and one output neuron will have six parameters whose values will be changed until the loss function reaches its minimum.</p> <p>When we talk about model optimization we refer to the fact that often we are interested in finding which model structure is the best to describe our data. The main concern is to design a model that has a sufficient complexity to store all the information contained in the training data. We can therefore think of parameterizing the network structure itself, e.g. in terms of the number of inner layers and number of neurons per layer: these hyperparameters define a space where we want to again minimize a loss function. Formally, the parametric function \\(f_\\theta\\) is also a function of these hyperparameters \\(\\lambda\\): \\(f_{(\\theta, \\lambda)}\\), and the \\(\\lambda\\) can be optimized</p> <p>The second illustration, also elaborated from an image by the huawei forums, broadly illustrates this concept: for each point in the hyperparameters space (that is, for each configuration of the model), the individual model is optimized as usual. The global minimum over the hyperparameters space is then sought.</p> The cartoon illustrates the general idea behind gradient descent to optimize the model complexity (in terms of the choice of hyperparameters) multidimensional parameter and hyperparameter space (figure elaborated from an image by the huawei forums)."},{"location":"optimization/model_optimization.html#caveat-which-data-should-you-use-to-optimize-your-model","title":"Caveat: which data should you use to optimize your model","text":"<p>In typical machine learning studies, you should divide your dataset into three parts. One is used for training the model (training sample), one is used for testing the performance of the model (test sample), and the third one is the one where you actually use your trained model, e.g. for inference (application sample). Sometimes you may get away with using test data as application data: Helge Voss (Chap 5 of Behnke et al.) states that this is acceptable under three conditions that must be simultaneously valid:</p> <ul> <li>no hyperparameter optimization is performed;</li> <li>no overtraining is found;</li> <li>the number of training data is high enough to make statistical fluctuations negligible.</li> </ul> <p>If you are doing any kind of hyperparamters optimization, thou shalt NOT use the test sample as application sample. You should have at least three distinct sets, and ideally you should use four (training, testing, hyperparameter optimization, application).</p>"},{"location":"optimization/model_optimization.html#grid-search","title":"Grid Search","text":"<p>The most simple hyperparameters optimization algorithm is the grid search, where you train all the models in the hyperparameters space to build the full landscape of the global loss function, as illustrated in Goodfellow, Bengio, Courville: \"Deep Learning\".</p> The cartoon illustrates the general idea behind grid search (image taken from Goodfellow, Bengio, Courville: \"Deep Learning\"). <p>To perform a meaningful grid search, you have to provide a set of values within the acceptable range of each hyperparameters, then for each point in the cross-product space you have to train the corresponding model.</p> <p>The main issue with grid search is that when there are nonimportant hyperparameters (i.e. hyperparameters whose value doesn't influence much the model performance) the algorithm spends an exponentially large time (in the number of nonimportant hyperparameters) in the noninteresting configurations: having \\(m\\) parameters and testing \\(n\\) values for each of them leads to \\(\\mathcal{O}(n^m)\\) tested configurations. While the issue may be mitigated by parallelization, when the number of hyperparameters (the dimension of hyperparameters space) surpasses a handful, even parallelization can't help.</p> <p>Another issue is that the search is binned: depending on the granularity in the scan, the global minimum may be invisible.</p> <p>Despite these issues, grid search is sometimes still a feasible choice, and gives its best when done iteratively. For example, if you start from the interval \\(\\{-1, 0, 1\\}\\):</p> <ul> <li>if the best parameter is found to be at the boundary (1), then extend range (\\(\\{1, 2, 3\\}\\)) and do the search in the new range;</li> <li>if the best parameter is e.g. at 0, then maybe zoom in and do a search in the range \\(\\{-0.1, 0, 0.1\\}\\).</li> </ul>"},{"location":"optimization/model_optimization.html#random-search","title":"Random search","text":"<p>An improvement of the grid search is the random search, which proceeds like this:</p> <ul> <li>you provide a marginal p.d.f. for each hyperparameter;</li> <li>you sample from the joint p.d.f. a certain number of training configurations;</li> <li>you train for each of these configurations to build the loss function landscape.</li> </ul> <p>This procedure has significant advantages over a simple grid search: random search is not binned, because you are sampling from a continuous p.d.f., so the pool of explorable hyperparameter values is larger; random search is exponentially more efficient, because it tests a unique value for each influential hyperparameter on nearly every trial.</p> <p>Random search also work best when done iteratively. The differences between grid and random search are again illustrated in Goodfellow, Bengio, Courville: \"Deep Learning\".</p> The cartoon illustrates the general idea behind random search, as opposed to grid search (image taken from Goodfellow, Bengio, Courville: \"Deep Learning\")."},{"location":"optimization/model_optimization.html#model-based-optimization-by-gradient-descent","title":"Model-based optimization by gradient descent","text":"<p>Now that we have looked at the most basic model optimization techniques, we are ready to look into using gradient descent to solve a model optimization problem. We will proceed by recasting the problem as one of model selection, where the hyperparameters are the input (decision) variables, and the model selection criterion is a differentiable validation set error. The validation set error attempts to describe the complexity of the network by a single hyperparameter (details in [a contribution on statistical learning to the ML forum]) The problem may be solved with standard gradient descent, as illustrated above, if we assume that the training criterion \\(C\\) is continuous and differentiable with respect to both the parameters \\(\\theta\\) (e.g. weights) and hyperparameters \\(\\lambda\\) Unfortunately, the gradient is seldom available (either because it has a prohibitive computational cost, or because it is non-differentiable as is the case when there are discrete variables).</p> <p>A diagram illustrating the way gradient-based model optimization works has been prepared by Bengio, doi:10.1162/089976600300015187.</p> The diagram illustrates the way model optimization can be recast as a model selection problem, where a model selection criterion involves a differentiable validation set error (image taken from Bengio, doi:10.1162/089976600300015187)."},{"location":"optimization/model_optimization.html#model-based-optimization-by-surrogates","title":"Model-based optimization by surrogates","text":"<p>Sequential Model-based Global Optimization (SMBO) consists in replacing the loss function with a surrogate model of it, when the loss function (i.e. the validation set error) is not available. The surrogate is typically built as a Bayesian regression model, when one estimates the expected value of the validation set error for each hyperparameter together with the uncertainty in this expectation. The pseudocode for the SMBO algorithm is illustrated by Bergstra et al.</p> The diagram illustrates the pseudocode for the Sequential Model-based Global Optimization (image taken from Bergstra et al). <p>This procedure results in a tradeoff between: exploration, i.e. proposing hyperparameters with high uncertainty, which may result in substantial improvement or not; and exploitation (propose hyperparameters that will likely perform as well as the current proposal---usually this mean close to the current ones). The disadvantage is that the whole procedure must run until completion before giving as an output any usable information. By comparison, manual or random searches tend to give hints on the location of the minimum faster.</p>"},{"location":"optimization/model_optimization.html#bayesian-optimization","title":"Bayesian Optimization","text":"<p>We are now ready to tackle in full what is referred to as Bayesian optimization.</p> <p>Bayesian optimization assumes that the unknown function \\(f(\\theta, \\lambda)\\) was sampled from a Gaussian process (GP), and that after the observations it maintains the corresponding posterior. In this context, observations are the various validation set errors for different values of the hyperparameters \\(\\lambda\\). In order to pick the next value to probe, one maximizes some estimate of the expected improvement (see below). To understand the meaning of \"sampled from a Gaussian process\", we need to define what a Gaussian process is.</p>"},{"location":"optimization/model_optimization.html#gaussian-processes","title":"Gaussian processes","text":"<p>Gaussian processes (GPs) generalize the concept of Gaussian distribution over discrete random variables to the concept of Gaussian distribution over continuous functions. Given some data and an estimate of the Gaussian noise, by fitting a function one can estimate also the noise at the interpolated points. This estimate is made by similarity with contiguous points, adjusted by the distance between points. A GP is therefore fully described by its mean and its covariance function. An illustration of Gaussian processes is given in Kevin Jamieson's CSE599 lecture notes.</p> The diagram illustrates the evolution of a Gaussian process, when adding interpolating points (image taken from Kevin Jamieson's CSE599 lecture notes). <p>GPs are great for Bayesian optimization because they out-of-the-box provide the expected value (i.e. the mean of the process) and its uncertainty (covariance function).</p>"},{"location":"optimization/model_optimization.html#the-basic-idea-behind-bayesian-optimization","title":"The basic idea behind Bayesian optimization","text":"<p>Gradient descent methods are intrinsically local: the decision on the next step is taken based on the local gradient and Hessian approximations- Bayesian optimization (BO) with GP priors uses a model that uses all the information from the previous steps by encoding it in the model giving the expectation and its uncertainty. The consequence is that GP-based BO can find the minimum of difficult nonconvex functions in relatively few evaluations, at the cost of performing more computations to find the next point to try in the hyperparameters space.</p> <p>The BO prior is a prior over the space of the functions. GPs are especially suited to play the role of BO prior, because marginals and conditionals can be computed in closed form (thanks to the properties of the Gaussian distribution).</p> <p>There are several methods to choose the acquisition function (the function that selects the next step for the algorithm), but there is no omnipurpose recipe: the best approach is problem-dependent. The acquisition function involves an accessory optimization to maximize a certain quantity; typical choices are:</p> <ul> <li>maximize the probability of improvement over the current best value: can be calculated analytically for a GP;</li> <li>maximize the expected improvement over the current best value: can also be calculated analytically for a GP;</li> <li>maximize the GP Upper confidence bound: minimize \"regret\" over the course of the optimization.</li> </ul>"},{"location":"optimization/model_optimization.html#historical-note","title":"Historical note","text":"<p>Gaussian process regression is also called kriging in geostatistics, after Daniel G. Krige (1951) who pioneered the concept later formalized by Matheron (1962)</p>"},{"location":"optimization/model_optimization.html#bayesian-optimization-in-practice","title":"Bayesian optimization in practice","text":"<p>The figure below, taken by a tutorial on BO by Martin Krasser, clarifies rather well the procedure. The task is to approximate the target function (labelled noise free objective in the figure), given some noisy samples of it (the black crosses). At the first iteration, one starts from a flat surrogate function, with a given uncertainty, and fits it to the noisy samples. To choose the next sampling location, a certain acquisition function is computed, and the value that maximizes it is chosen as the next sampling location At each iteration, more noisy samples are added, until the distance between consecutive sampling locations is minimized (or, equivalently, a measure of the value of the best selected sample is maximized).</p> Practical illustration of Bayesian Optimization (images taken from a tutorial on BO by Martin Krasser])."},{"location":"optimization/model_optimization.html#limitations-and-some-workaround-of-bayesian-optimization","title":"Limitations (and some workaround) of Bayesian Optimization","text":"<p>There are three main limitations to the BO approach. A good overview of these limitations and of possible solutions can be found in arXiv:1206.2944.</p> <p>First of all, it is unclear what is an appropriate choice for the covariance function and its associated hyperparameters. In particular, the standard squared exponential kernel is often too smooth. As a workaround, alternative kernels may be used: a common choice is the Mat\u00e9rn 5/2 kernel, which is similar to the squared exponential one but allows for non-smoothness.</p> <p>Another issue is that, for certain problems, the function evaluation may take very long to compute. To overcome this, often one can replace the function evaluation with the Monte Carlo integration of the expected improvement over the GP hyperparameters, which is faster.</p> <p>The third main issue is that for complex problems one would ideally like to take advantage of parallel computation. The procedure is iterative, however, and it is not easy to come up with a scheme to make it parallelizable. The referenced paper proposed sampling over the expected acquisition, conditioned on all the pending evaluations: this is computationally cheap and is intrinsically parallelizable.</p>"},{"location":"optimization/model_optimization.html#alternatives-to-gaussian-processes-tree-based-models","title":"Alternatives to Gaussian processes: Tree-based models","text":"<p>Gaussian Processes model directly \\(P(hyperpar | data)\\) but are not the only suitable surrogate models for Bayesian optimization</p> <p>The so-called Tree-structured Parzen Estimator (TPE), described in Bergstra et al, models separately \\(P(data | hyperpar)\\) and \\(P(hyperpar)\\), to then obtain the posterior by explicit application of the Bayes theorem TPEs exploit the fact that the choice of hyperparameters is intrinsically graph-structured, in the sense that e.g. you first choose the number of layers, then choose neurons per layer, etc. TPEs run over this generative process by replacing the hyperparameters priors with nonparametric densities. These generative nonparametric densities are built by classifying them into those that result in worse/better loss than the current proposal.</p> <p>TPEs have been used in CMS already around 2017 in a VHbb analysis (see repository by Sean-Jiun Wang) and in a charged Higgs to tb search (HIG-18-004, doi:10.1007/JHEP01(2020)096).</p>"},{"location":"optimization/model_optimization.html#implementations-of-bayesian-optimization","title":"Implementations of Bayesian Optimization","text":"<ul> <li>Implementations in R are readily available as the R-studio <code>tuning</code> package;</li> <li>Scikit-learn provides a handy implementation of Gaussian processes;</li> <li>**scipy*  provides a handy implementation of the optimization routines;</li> <li><code>hyperopt</code> provides a handy implementation of distributed hyperparameter optimization routines;<ul> <li>GPs not coded by default, hence must rely on scikit-learn;</li> <li>Parzen tree estimators are implemented by default (together with random search);</li> </ul> </li> <li>Several handy tutorials online focussed on hyperparameters optimization<ul> <li>Tutorial by Martin Krasser;</li> <li>Tutorial by Jason Brownlee;</li> </ul> </li> <li>Early example of <code>hyperopt</code> in CMS<ul> <li>VHbb analysis: repository by Sean-Jiun Wang), for optimization of a BDT;</li> <li>Charged Higgs HIG-18-004, doi:10.1007/JHEP01(2020)096) for optimization of a DNN (no public link for the code, contact me if needed)</li> </ul> </li> <li>Several expansions and improvements (particularly targeted at HPC clusters) are available, see e.g. this talk by Eric Wulff.</li> </ul>"},{"location":"optimization/model_optimization.html#caveats-dont-get-too-obsessed-with-model-optimization","title":"Caveats: don't get too obsessed with model optimization","text":"<p>In general, optimizing model structure is a good thing. F. Chollet e.g. says \"If you want to get to the very limit of what can be achieved on a given task, you can't be content with arbitrary choices made by a fallible human\". On the other side, for many problems hyperparameter optimization does result in small improvements, and there is a tradeoff between improvement and time spent on the task: sometimes the time spent on optimization may not be worth, e.g. when the gradient of the loss in hyperparameters space is very flat (i.e. different hyperparameter sets give more or less the same results), particularly if you already know that small improvements will be eaten up by e.g. systematic uncertainties. On the other side, before you perform the optimization you don't know if the landscape is flat or if you can expect substantial improvements. Sometimes broad grid or random searches may give you a hint on whether the landscape of hyperparameters space is flat or not.</p> <p>Sometimes you may get good (and faster) improvements by model ensembling rather than by model optimization. To do model ensembling, you first train a handful models (either different methods---BDT, SVM, NN, etc---or different hyperparameters sets): \\(pred\\_a = model\\_a.predict(x)\\), ..., \\(pred\\_d = model\\_d.predict(x)\\). You then pool the predictions: \\(pooled\\_pred = (pred\\_a + pred\\_b + pred\\_c + pred\\_d)/4.\\). THis works if all models are kind of good: if one is significantly worse than the others, then \\(pooled\\_pred\\) may not be as good as the best model of the pool.</p> <p>You can also find ways of ensembling in a smarter way, e.g. by doing weighted rather than simple averages: \\(pooled\\_pred = 0.5\\cdot pred\\_a + 0.25\\cdot pred\\_b + 0.1\\cdot pred\\_c + 0.15\\cdot pred\\_d)/4.\\). Here the idea is to give more weight to better classifiers. However, you transfer the problem to having to choose the weights. These can be found empirically empirically by using random search or other algorithms like Nelder-Mead (<code>result = scipy.optimize.minimize(objective, pt, method='nelder-mead'</code>), where you build simplexes (polytope with <code>N+1</code> vertices in <code>N</code> dimensions, generalization of triangle) and stretch them towards higher values of the objective. Nelder-Mead can converge to nonstationary points, but there are extensions of the algorithm that may help.</p> <p>This page summarizes the concepts shown in a contribution on Bayesian Optimization to the ML Forum. Content may be edited and published elsewhere by the author. Page author: Pietro Vischia, 2022</p>"},{"location":"resources/cloud_resources/index.html","title":"Cloud Resources","text":"<p>Work in progress.</p>"},{"location":"resources/dataset_resources/index.html","title":"CMS-ML Dataset Tab","text":""},{"location":"resources/dataset_resources/index.html#introduction","title":"Introduction","text":"<p>Welcome to CMS-ML Dataset tab! Our tab is designed to provide accurate,  up-to-date, and relevant data across various purposes. We strive to make this tab resourceful for your analysis and decision-making needs. We are working on benchmarking more dataset and presenting them in a user-friendly format. This tab will be continuously updated      to reflect the latest developments. Explore, analyze, and derive insights        with ease!</p>"},{"location":"resources/dataset_resources/index.html#1-jetnet","title":"1. JetNet","text":""},{"location":"resources/dataset_resources/index.html#links","title":"Links","text":"<p>Github Repository</p> <p>Zenodo</p>"},{"location":"resources/dataset_resources/index.html#description","title":"Description","text":"<p>JetNet is a project aimed at enhancing accessibility and   reproducibility in jet-based machine learning. It offers easy-to-access    and standardized interfaces for several datasets, including JetNet,    TopTagging, and QuarkGluon. Additionally, JetNet provides standard     implementations of various generative evaluation metrics such as Fr\u00e9chet      Physics Distance (FPD), Kernel Physics Distance (KPD), Wasserstein-1 (W1),       Fr\u00e9chet ParticleNet Distance (FPND), coverage, and Minimum Matching Distance (MMD).       Beyond these, it includes a differentiable implementation of the energy mover's distance and other general jet utilities, making it a comprehensive resource for researchers and practitioners in the field.</p>"},{"location":"resources/dataset_resources/index.html#nature-of-objects","title":"Nature of Objects","text":"<ul> <li>Objects: Gluon (g), Top Quark (t), Light Quark (q), W boson (w), and Z boson (z) jets of ~1 TeV transverse momentum (\\(p_T\\))</li> <li>Number of Objects: N = 177252, 177945, 170679, 177172, 176952 for g, t, q, w, z jets respectively.</li> </ul>"},{"location":"resources/dataset_resources/index.html#format-of-dataset","title":"Format of Dataset","text":"<ul> <li>File Type: HDF5</li> <li>Structure: Each file has particle_features; and jet_features; arrays, containing the list of particles' features per jet and the corresponding jet's features, respectively. Particle_features is of shape [N, 30, 4], where N is the total number of jets, 30 is the max number of particles per jet, and 4 is the number of particle features, in order: []\\eta, \\varphi, \\p_T, mask]. See Zenodo for definitions of these. jet_features is of shape [N, 4], where 4 is the number of jet features, in order: [\\(p_T\\), \\(\\eta\\), mass, # of particles].</li> </ul>"},{"location":"resources/dataset_resources/index.html#related-projects","title":"Related Projects","text":"<ul> <li>Top tagging benchmark</li> <li>Particle Cloud Generation with Message Passing Generative Adversarial Networks</li> </ul>"},{"location":"resources/dataset_resources/index.html#2-top-tagging-benchmark-dataset","title":"2. Top Tagging Benchmark Dataset","text":""},{"location":"resources/dataset_resources/index.html#links_1","title":"Links","text":"<p>Zenodo</p>"},{"location":"resources/dataset_resources/index.html#description_1","title":"Description","text":"<p>A set of MC simulated training/testing events for the evaluation of top quark tagging architectures. - 14 TeV, hadronic tops for signal, qcd diets background, Delphes ATLAS detector card with Pythia8 - No MPI/pile-up included - Clustering of  particle-flow entries (produced by Delphes E-flow) into anti-kT 0.8 jets in the pT range [550,650] GeV - All top jets are matched to a parton-level top within \u2206R = 0.8, and to all top decay partons within 0.8 - Jets are required to have |eta| &lt; 2 - The leading 200 jet constituent four-momenta are stored, with zero-padding for jets with fewer than 200 - Constituents are sorted by pT, with the highest pT one first - The truth top four-momentum is stored as truth_px etc. - A flag (1 for top, 0 for QCD) is kept for each jet. It is called is_signal_new - The variable \"ttv\" (= test/train/validation) is kept for each jet. It indicates to which dataset the jet belongs. It is redundant as the different sets are already distributed as different files.</p>"},{"location":"resources/dataset_resources/index.html#nature-of-objects_1","title":"Nature of Objects","text":"<ul> <li>Objects: 14 TeV, hadronic tops for signal, qcd diets background, Delphes ATLAS detector card with Pythia8</li> <li>Number of Objects: In total 1.2M training events, 400k validation events and 400k test events.</li> </ul>"},{"location":"resources/dataset_resources/index.html#format-of-dataset_1","title":"Format of Dataset","text":"<ul> <li>File Type: HDF5</li> <li>Structure: Use \u201ctrain\u201d for training, \u201cval\u201d for validation during the training and \u201ctest\u201d for final testing and reporting results. For details, see the Zenodo link</li> </ul>"},{"location":"resources/dataset_resources/index.html#related-projects_1","title":"Related Projects","text":"<ul> <li>Butter, Anja; Kasieczka, Gregor; Plehn, Tilman and Russell, Michael (2017). Based on data from 10.21468/SciPostPhys.5.3.028 (1707.08966)</li> <li>Kasieczka, Gregor et al (2019). Dataset used for arXiv:1902.09914 (The Machine Learning Landscape of Top Taggers)</li> </ul>"},{"location":"resources/dataset_resources/index.html#more-dataset-coming-in","title":"More dataset coming in!","text":"<p>Have any questions? Want your dataset shown on this page? Contact the ML Knowledge Subgroup!</p>"},{"location":"resources/fpga_resources/index.html","title":"FPGA Resource","text":"<p>Work in progress.</p>"},{"location":"resources/gpu_resources/cms_resources/lxplus_gpu.html","title":"lxplus-gpu.cern.ch","text":""},{"location":"resources/gpu_resources/cms_resources/lxplus_gpu.html#how-to-use-it","title":"How to use it?","text":"<p><code>lxplus-gpu</code> are special lxplus nodes with GPU support. You can access these nodes by executing</p> <pre><code>ssh &lt;your_user_name&gt;@lxplus-gpu.cern.ch\n</code></pre> <p></p> <p>The configuration of the software environment for lxplus-gpu is described in the Software Environments page.</p>"},{"location":"resources/gpu_resources/cms_resources/lxplus_htcondor.html","title":"HTCondor With GPU resources","text":"<p>In general, HTCondor supports GPU jobs if there are some worker nodes which are configured with GPU devices. CMS Connect and lxplus both have access to worker nodes equipped with GPUs.</p>"},{"location":"resources/gpu_resources/cms_resources/lxplus_htcondor.html#how-to-require-gpus-in-htcondor","title":"How to require GPUs in HTCondor","text":"<p>People can require their jobs to have GPU support by adding the following requirements to the condor submission file.</p> <pre><code>request_gpus = n # n equal to the number of GPUs required\n</code></pre>"},{"location":"resources/gpu_resources/cms_resources/lxplus_htcondor.html#further-documentation","title":"Further documentation","text":"<p>There are good materials providing detailed documentation on how to run HTCondor jobs with GPU support at both machines. </p> <p>The configuration of the software environment for lxplus-gpu and HTcondor is described in the Software Environments page. Moreover the page Using container explains step by step how to build a docker image to be run on HTCondor jobs. </p>"},{"location":"resources/gpu_resources/cms_resources/lxplus_htcondor.html#more-available-resources","title":"More available resources","text":"<ol> <li>A complete documentation can be found from the <code>GPUs</code> section in CERN Batch Docs. Where a <code>Tensorflow</code> example is supplied. This documentation also contains instructions on advanced HTCondor configuration, for instance constraining GPU device or CUDA version.</li> <li> <p>A good example on submitting GPU HTCondor job @ Lxplus is the <code>weaver-benchmark</code> project. It provides a concrete example on how to setup environment for <code>weaver</code> framework and operate trainning and testing process within a single job. Detailed description can be found at section <code>ParticleNet</code> of this documentation.  </p> <p>In principle, this example can be run elsewhere as HTCondor jobs. However, paths to the datasets should be modified to meet the requirements. </p> </li> <li> <p>CMS Connect also provides a documentation on GPU job submission. In this documentation there is also a <code>Tensorflow</code> example. </p> <p>When submitting GPU jobs @ CMS Connect, especially for Machine Learning purpose, EOS space @ CERN are not accessible as a directory, therefore one should consider using <code>xrootd</code> utilities as documented in this page</p> </li> </ol>"},{"location":"resources/gpu_resources/cms_resources/ml_cern_ch.html","title":"ml.cern.ch","text":"<p>ml.cern.ch is a <code>Kubeflow</code> based ML solution provided by CERN.</p>"},{"location":"resources/gpu_resources/cms_resources/ml_cern_ch.html#kubeflow","title":"<code>Kubeflow</code>","text":"<p><code>Kubeflow</code> is a Kubernetes based ML toolkits aiming at making deployments of ML workflows simple, portable and scalable. In Kubeflow, pipeline is an important concept. Machine Learning workflows are discribed as a Kubeflow pipeline for execution.</p>"},{"location":"resources/gpu_resources/cms_resources/ml_cern_ch.html#how-to-access","title":"How to access","text":"<p><code>ml.cern.ch</code> only accepts connections from within the CERN network. Therefore, if you are outside of CERN, you will need to use a network tunnel (eg. via <code>ssh -D</code> dynamic port forwarding as a SOCKS5 proxy)... The main website are shown below.</p> <p></p>"},{"location":"resources/gpu_resources/cms_resources/ml_cern_ch.html#examples","title":"Examples","text":"<p>After logging into the main website, you can click on the <code>Examples</code> entry to browser a gitlab repository containing a lot of examples. For instance, below are two examples from that repository with a well-documented <code>readme</code> file.</p> <ol> <li><code>mnist-kfp</code> is an example on how to use jupyter notebooks to create a Kubeflow pipeline (kfp) and how to access CERN EOS files.</li> <li><code>katib</code> gives an example on how to use the <code>katib</code> to operate hyperparameter tuning for jet tagging with ParticleNet.</li> </ol>"},{"location":"resources/gpu_resources/cms_resources/swan.html","title":"SWAN","text":""},{"location":"resources/gpu_resources/cms_resources/swan.html#preparation","title":"Preparation","text":"<ol> <li> <p>Registration:</p> <p>To require GPU resources for SWAN: According to this thread, one can create a ticket through this link to ask for GPU support at SWAN, it is now in beta version and limited to a small scale. 2. Setup SWAN with GPU resources:</p> <ol> <li> <p>Once the registration is done, one can login SWAN with Kerberes8 support and then create his SWAN environment.</p> <p> \ud83d\udca1 Note: When configuring the SWAN environment you will be given your choice of software stack. Be careful to use a software release with GPU support as well as an appropriate CUDA version. If you need to install additional software, it must be compatible with your chosen CUDA version. </p> </li> </ol> </li> </ol> <p></p> <p></p> <p>Another important option is the environment script, which will be discussed later in this document.</p>"},{"location":"resources/gpu_resources/cms_resources/swan.html#working-with-swan","title":"Working with SWAN","text":"<ol> <li> <p>After creation, one will browse the SWAN main directory <code>My Project</code> where all existing projects are displayed. A new project can be created by clicking the upper right \"+\" button. After creation one will be redirected to the newly created project, at which point the \"+\" button on the upper right panel can be used for creating new notebook.</p> <p></p> <p></p> </li> <li> <p>It is possible to use the terminal for installing new packages or monitoring computational resources.</p> <ol> <li> <p>For package installation, one can install packages with package management tools, e.g. <code>pip</code> for <code>python</code>. To use the installed packages, you will need to wrap the environment configuration in a scrip, which will be executed by SWAN. Detailed documentation can be found by clicking the upper right \"?\" button.</p> </li> <li> <p>In addition to using top and htop to monitor ordinary resources, you can use nvidia-smi to monitor GPU usage.</p> </li> </ol> <p></p> </li> </ol>"},{"location":"resources/gpu_resources/cms_resources/swan.html#examples","title":"Examples","text":"<p>After installing package, you can then use GPU based machine learning algorithms. Two examples are supplied as an example.</p> <ol> <li> <p>The first example aims at using a CNN to perform handwritten digits classification with <code>MNIST</code> dataset. The whole notebook can be found at pytorch_mnist. This example is modified from an official <code>pytorch</code> example.</p> </li> <li> <p>The second example is modified from the simple MLP example from <code>weaver-benchmark</code>. The whole notebook can be found at toptagging_mlp.</p> </li> </ol>"},{"location":"resources/gpu_resources/cms_resources/notebooks/pytorch_mnist.html","title":"Pytorch mnist","text":"<pre><code>from __future__ import print_function\nimport argparse\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport torch.optim as optim\nfrom torchvision import datasets, transforms\nfrom torch.optim.lr_scheduler import StepLR\n</code></pre> <pre><code>class Net(nn.Module):\n    def __init__(self):\n        super(Net, self).__init__()\n        self.conv1 = nn.Conv2d(1, 32, 3, 1)\n        self.conv2 = nn.Conv2d(32, 64, 3, 1)\n        self.dropout1 = nn.Dropout(0.25)\n        self.dropout2 = nn.Dropout(0.5)\n        self.fc1 = nn.Linear(9216, 128)\n        self.fc2 = nn.Linear(128, 10)\n\n    def forward(self, x):\n        x = self.conv1(x)\n        x = F.relu(x)\n        x = self.conv2(x)\n        x = F.relu(x)\n        x = F.max_pool2d(x, 2)\n        x = self.dropout1(x)\n        x = torch.flatten(x, 1)\n        x = self.fc1(x)\n        x = F.relu(x)\n        x = self.dropout2(x)\n        x = self.fc2(x)\n        output = F.log_softmax(x, dim=1)\n        return output\n</code></pre> <pre><code>def train(args, model, device, train_loader, optimizer, epoch):\n    model.train()\n    for batch_idx, (data, target) in enumerate(train_loader):\n        data, target = data.to(device), target.to(device)\n\n        optimizer.zero_grad()\n        output = model(data)\n        loss = F.nll_loss(output, target)\n        loss.backward()\n        optimizer.step()\n        if batch_idx % args[\"log_interval\"] == 0:\n            print('Train Epoch: {} [{}/{} ({:.0f}%)]\\tLoss: {:.6f}'.format(\n                epoch, batch_idx * len(data), len(train_loader.dataset),\n                100. * batch_idx / len(train_loader), loss.item()))\n            if args[\"dry_run\"]:\n                break\n</code></pre> <pre><code>def test(model, device, test_loader):\n    model.eval()\n    test_loss = 0\n    correct = 0\n    with torch.no_grad():\n        for data, target in test_loader:\n            data, target = data.to(device), target.to(device)\n            output = model(data)\n            test_loss += F.nll_loss(output, target, reduction='sum').item()  # sum up batch loss\n            pred = output.argmax(dim=1, keepdim=True)  # get the index of the max log-probability\n            correct += pred.eq(target.view_as(pred)).sum().item()\n\n    test_loss /= len(test_loader.dataset)\n\n    print('\\nTest set: Average loss: {:.4f}, Accuracy: {}/{} ({:.0f}%)\\n'.format(\n        test_loss, correct, len(test_loader.dataset),\n        100. * correct / len(test_loader.dataset)))\n</code></pre> <pre><code>torch.cuda.is_available() # Check if cuda is available\n</code></pre> <pre><code>train_kwargs = {\"batch_size\":64}\ntest_kwargs = {\"batch_size\":1000}\n</code></pre> <pre><code>cuda_kwargs = {'num_workers': 1,\n               'pin_memory': True,\n               'shuffle': True}\ntrain_kwargs.update(cuda_kwargs)\ntest_kwargs.update(cuda_kwargs)\n</code></pre> <pre><code>transform=transforms.Compose([\n    transforms.ToTensor(),\n    transforms.Normalize((0.1307,), (0.3081,))\n    ])\n</code></pre> <pre><code>dataset1 = datasets.MNIST('./data', train=True, download=True,\n                   transform=transform)\ndataset2 = datasets.MNIST('./data', train=False,\n                   transform=transform)\ntrain_loader = torch.utils.data.DataLoader(dataset1,**train_kwargs)\ntest_loader = torch.utils.data.DataLoader(dataset2, **test_kwargs)\n</code></pre> <pre><code>device = torch.device(\"cuda\")\nmodel = Net().to(device)\noptimizer = optim.Adadelta(model.parameters(), lr=1.0)\nscheduler = StepLR(optimizer, step_size=1, gamma=0.7)\n</code></pre> <pre><code>args = {\"dry_run\":False, \"log_interval\":100}\nfor epoch in range(1, 14 + 1):\n    train(args, model, device, train_loader, optimizer, epoch)\n    test(model, device, test_loader)\n    scheduler.step()\n</code></pre>"},{"location":"resources/gpu_resources/cms_resources/notebooks/toptagging_mlp.html","title":"Toptagging mlp","text":"<p><pre><code>import torch\nimport torch.nn as nn\nfrom torch.utils.data.dataset import Dataset\nimport pandas as pd\nimport numpy as np\nimport uproot3\nimport torch.optim as optim\nfrom torch.optim.lr_scheduler import StepLR\nimport torch.nn.functional as F\nimport awkward0\n</code></pre> <pre><code>class MultiLayerPerceptron(nn.Module):\n    r\"\"\"Parameters\n    ----------\n    input_dims : int\n        Input feature dimensions.\n    num_classes : int\n        Number of output classes.\n    layer_params : list\n        List of the feature size for each layer.\n    \"\"\"\n\n    def __init__(self, input_dims, num_classes,\n                 layer_params=(256,64,16),\n                 **kwargs):\n\n        super(MultiLayerPerceptron, self).__init__(**kwargs)\n        channels = [input_dims] + list(layer_params) + [num_classes]\n        layers = []\n        for i in range(len(channels) - 1):\n            layers.append(nn.Sequential(nn.Linear(channels[i], channels[i + 1]),\n                                        nn.ReLU()))\n        self.mlp = nn.Sequential(*layers)\n\n    def forward(self, x):\n        # x: the feature vector initally read from the data structure, in dimension (N, C, P)\n        x = x.flatten(start_dim=1) # (N, L), where L = C * P\n        return self.mlp(x)\n\n    def predict(self,x):\n        pred = F.softmax(self.forward(x))\n        ans = []\n        for t in pred:\n            if t[0] &gt; t[1]:\n                ans.append(1)\n            else:\n                ans.append(0)\n        return torch.tensor(ans)\n</code></pre></p> <pre><code>def train(args, model, device, train_loader, optimizer, epoch):\n    model.train()\n    for batch_idx, (data, target) in enumerate(train_loader):\n        data, target = data.to(device), target.to(device)\n        optimizer.zero_grad()\n        output = model(data)\n        loss = F.nll_loss(output, target)\n        loss.backward()\n        optimizer.step()\n        if batch_idx % args[\"log_interval\"] == 0:\n            print('Train Epoch: {} [{}/{} ({:.0f}%)]\\tLoss: {:.6f}'.format(\n                epoch, batch_idx * len(data), len(train_loader.dataset),\n                100. * batch_idx / len(train_loader), loss.item()))\n            if args[\"dry_run\"]:\n                break\n</code></pre> <pre><code>input_branches = [\n                  'Part_Etarel',\n                  'Part_Phirel',\n                  'Part_E_log',\n                  'Part_P_log'\n                 ]\n\noutput_branches = ['is_signal_new']\n</code></pre> <pre><code>train_dataset = uproot3.open(\"TopTaggingMLP/train.root\")[\"Events\"].arrays(input_branches+output_branches,namedecode='utf-8')\ntrain_dataset = {name:train_dataset[name].astype(\"float32\") for name in input_branches+output_branches}\ntest_dataset = uproot3.open(\"/eos/user/c/coli/public/weaver-benchmark/top_tagging/samples/prep/top_test_0.root\")[\"Events\"].arrays(input_branches+output_branches,namedecode='utf-8')\ntest_dataset = {name:test_dataset[name].astype(\"float32\") for name in input_branches+output_branches}\n</code></pre> <pre><code>for ds in [train_dataset,test_dataset]:\n    for name in ds.keys():\n        if isinstance(ds[name],awkward0.JaggedArray):\n            ds[name] = ds[name].pad(30,clip=True).fillna(0).regular().astype(\"float32\")\n</code></pre> <pre><code>class PF_Features(Dataset):\n    def __init__(self,mode = \"train\"):\n        if mode == \"train\":\n            self.x = {key:train_dataset[key] for key in input_branches}\n            self.y = {'is_signal_new':train_dataset['is_signal_new']}\n        elif mode == \"test\":\n            self.x = {key:test_dataset[key] for key in input_branches}\n            self.y = {'is_signal_new':test_dataset['is_signal_new']}\n        elif model == \"val\":\n            self.x = {key:test_dataset[key] for key in input_branches}\n            self.y = {'is_signal_new':test_dataset['is_signal_new']}\n\n    def __len__(self):\n        return len(self.y['is_signal_new'])\n\n    def __getitem__(self,idx):\n        X = [self.x[key][idx].copy() for key in input_branches]\n        X = np.vstack(X)\n        y = self.y['is_signal_new'][idx].copy()\n        return X,y\n</code></pre> <pre><code>torch.cuda.is_available() # Check if cuda is available\n</code></pre> <pre><code>True\n</code></pre> <pre><code>device = torch.device(\"cuda\")\n</code></pre> <pre><code>train_kwargs = {\"batch_size\":1000}\ntest_kwargs = {\"batch_size\":10}\ncuda_kwargs = {'num_workers': 1,\n               'pin_memory': True,\n               'shuffle': True}\ntrain_kwargs.update(cuda_kwargs)\ntest_kwargs.update(cuda_kwargs)\n</code></pre> <pre><code>model = MultiLayerPerceptron(input_dims = 4 * 30, num_classes=2).to(device)\n</code></pre> <pre><code>optimizer = optim.Adam(model.parameters(), lr=0.01)\n</code></pre> <pre><code>train_loader = torch.utils.data.DataLoader(PF_Features(mode=\"train\"),**train_kwargs)\ntest_loader = torch.utils.data.DataLoader(PF_Features(mode=\"test\"),**test_kwargs)\n</code></pre> <pre><code>loss_func = torch.nn.CrossEntropyLoss()\n</code></pre> <pre><code>args = {\"dry_run\":False, \"log_interval\":500}\nfor epoch in range(1,10+1):\n    for batch_idx, (data, target) in enumerate(train_loader):\n        inputs = data.to(device)#.flatten(start_dim=1)\n        target = target.long().to(device)\n        optimizer.zero_grad()\n        output = model.forward(inputs)\n        loss = loss_func(output,target)\n        loss.backward()\n        optimizer.step()\n        if batch_idx % args[\"log_interval\"] == 0:\n            print('Train Epoch: {} [{}/{} ({:.0f}%)]\\tLoss: {:.6f}'.format(\n                epoch, batch_idx * len(data), len(train_loader.dataset),\n                100. * batch_idx / len(train_loader), loss.item()))\n</code></pre>"},{"location":"software_envs/containers.html","title":"Using containers","text":"<p>Containers are a great solution to isolate a software environment, especially in batch systems like lxplus.  Currently, two container solutations are supported  Apptainer (previously called Singularity), and Docker.</p>"},{"location":"software_envs/containers.html#using-apptainer","title":"Using Apptainer","text":""},{"location":"software_envs/containers.html#quickstart","title":"Quickstart","text":"<p>One-line access to TensorFlow + PyTorch + Numpy + JupyterLab on lxplus: <pre><code>apptainer shell -B /afs -B /eos --nv /cvmfs/unpacked.cern.ch/registry.hub.docker.com/cmsml/cmsml:latest\n</code></pre></p>"},{"location":"software_envs/containers.html#more-information","title":"More information","text":"<p>The unpacked.cern.ch service mounts on CVMFS contains many apptainer images, some of which are suitable for machine  learning applications. A description of each image is beyond the scope of this document.  However, if you find an image useful for your application, you can use it by running an Apptainer container  with the appropriate options.   For example: <pre><code>apptainer run --nv --bind &lt;bind_mount_path&gt; /cvmfs/unpacked.cern.ch/&lt;path_to_image&gt;\n</code></pre></p>"},{"location":"software_envs/containers.html#examples","title":"Examples","text":"<p>After installing the package, you can then use GPU-based machine learning algorithms. Two examples are supplied.</p> <ol> <li> <p>The first example aims at using a CNN to perform handwritten digits classification with <code>MNIST</code> dataset. The notebook can be found at pytorch_mnist. This example is modified from an official <code>pytorch</code> example.</p> </li> <li> <p>The second example is modified from the simple MLP example from <code>weaver-benchmark</code>. The notebook can be found at toptagging_mlp.</p> </li> </ol>"},{"location":"software_envs/containers.html#using-docker","title":"Using Docker","text":"<p>Docker is currently supported on lxplus9 interactive nodes (through emulation of the CLI with Podman) and on HTCondor for job submission.</p> <p>This option can be very handy for users, as HTCondor can pull images from any public registry, like DockerHub or GitLab registry.  The user can follow this workflow: 1. Define a custom image on top of a commonly available pytorch or tensorflow image 2. Add the desired packages and configuration 3. Push the docker image on a registry 4. Use the image in a HTCondor job</p> <p>The rest of the page is a step-by-step tutorial for this workflow.</p>"},{"location":"software_envs/containers.html#define-the-image","title":"Define the image","text":"<ol> <li> <p>Define a file <code>Dockerfile</code> </p> <pre><code>FROM pytorch/pytorch:latest\n\nADD localfolder_with_code /opt/mycode\n\n\nRUN  cd /opt/mycode &amp;&amp; pip install -e . # or pip install requirements\n\n# Install the required Python packages\nRUN pip install \\\n    numpy \\\n    sympy \\\n    scikit-learn \\\n    numba \\\n    opt_einsum \\\n    h5py \\\n    cytoolz \\\n    tensorboardx \\\n    seaborn \\\n    rich \\\n    pytorch-lightning==1.7\n\nor \nADD requirements.txt \npip install -r requirements.txt\n</code></pre> </li> <li> <p>Build the image</p> <pre><code>docker build -t username/pytorch-condor-gpu:tag .\n</code></pre> <p>and push it (after having setup the credentials with <code>docker login hub.docker.com</code>)</p> <pre><code>docker push username/pytorch-condor-gpu:tag\n</code></pre> </li> <li> <p>Setup the condor job with a submission file <code>submitfile</code> as:</p> <pre><code>universe                = docker\ndocker_image            = user/pytorch-condor-gpu:tag\nexecutable              = job.sh\nwhen_to_transfer_output = ON_EXIT\noutput                  = $(ClusterId).$(ProcId).out\nerror                   = $(ClusterId).$(ProcId).err\nlog                     = $(ClusterId).$(ProcId).log\nrequest_gpus            = 1\nrequest_cpus            = 2\n+Requirements           = OpSysAndVer =?= \"CentOS7\"\n+JobFlavour = espresso\nqueue 1\n</code></pre> </li> <li> <p>For testing purpose one can start a job interactively and debug</p> <pre><code>condor_submit -interactive submitfile\n</code></pre> </li> </ol>"},{"location":"software_envs/lcg_environments.html","title":"LCG environments","text":""},{"location":"software_envs/lcg_environments.html#software-environment","title":"Software Environment","text":"<p>The software environment for ML application trainings can be setup in different ways.  In this page we focus on the CERN lxplus environment. </p>"},{"location":"software_envs/lcg_environments.html#lcg-release-software","title":"LCG release software","text":"<p>Checking out an ideal software bundle with Cuda support at <code>http://lcginfo.cern.ch/</code>, one can set up an LCG environment by executing</p> <pre><code>source /cvmfs/sft.cern.ch/lcg/views/&lt;name of bundle&gt;/**x86_64-centos*-gcc11-opt**/setup.sh\n</code></pre> <p>On <code>lxplus-gpu</code> nodes, usually equipped with AlmaLinux 9.1 (also called Centos9), one should use the proper lcg release. At the time of writing (May 2023) the recommended environment to use GPUs is: </p> <pre><code>source /cvmfs/sft.cern.ch/lcg/views/LCG_103cuda/x86_64-centos9-gcc11-opt/setup.sh\n</code></pre>"},{"location":"software_envs/lcg_environments.html#customized-environments","title":"Customized environments","text":"<p>One can create custom Python environment using <code>virtualenv</code> or <code>venv</code> tools, in order to avoid messing up with the global python environment.</p> <p>The user has the choice of building a virtual environment from scratch or by basing on top of a LCG release. </p>"},{"location":"software_envs/lcg_environments.html#virtual-environment-from-scratch","title":"Virtual environment from scratch","text":"<p>The first approach is cleaner but requires downloading the full set of libraries needed for pytorch or TensorFlow    (very heavy). Moreover the compatibility with the computing environment (usually lxplus-gpu) is not guaranteed.</p> <ol> <li> <p>Create the environment in a folder of choice, usually called <code>myenv</code></p> <pre><code>python3 -m venv --system-site-packages myenv\nsource myenv/bin/activate   # activate the environment\n# Add following line to .bashrc if you want to activate this environment by default (not recommended)\n# source \"/afs/cern.ch/user/&lt;first letter of your username&gt;/&lt;username&gt;/&lt;path-to-myenv-folder&gt;/myenv/bin/activate\"\n</code></pre> </li> <li> <p>To install packages properly, one should carefully check the CUDA version with <code>nvidia-smi</code> (as shown in figure before), and then find a proper version, pytorch is used as an example.</p> <p></p> <pre><code># Execute the command shown in your terminal\npip install torch==1.10.0+cu113 torchvision==0.11.1+cu113 torchaudio==0.10.0+cu113 -f https://download.pytorch.org/whl/cu113/torch_stable.html\npip install jupyterlab matplotlib scikit-hep # install other packages if they are needed\n</code></pre> </li> </ol>"},{"location":"software_envs/lcg_environments.html#virtual-environment-on-top-of-lcg","title":"Virtual environment on top of LCG","text":"<p>Creating a virtual environment only to add packages on top of a specific LCG release can be a very effective and inexpesive way to manage the Python environment in lxplus. </p> <p>N.B A caveat is that the users needs to remember to activate the lcg environment before activating his virtual environment. </p> <ol> <li> <p>Activate the lcg environment of choice</p> <pre><code>source /cvmfs/sft.cern.ch/lcg/views/LCG_103cuda/x86_64-centos9-gcc11-opt/setup.sh\n</code></pre> </li> <li> <p>Create the enviroment as above</p> <pre><code>python3 -m venv --system-site-packages myenv\nsource myenv/bin/activate   # activate the environment\n</code></pre> </li> <li> <p>Now the user can work in the environment as before but Pytorch and tensorflow libraries will be available. If a    single package needs to be update one can do</p> </li> </ol> <pre><code>pip install --upgrade tensorflow=newer.version\n</code></pre> <p>This will install the package in the local environment. </p> <p>At the next login, the user will need to perform these steps to get back the environment: </p> <pre><code>source /cvmfs/sft.cern.ch/lcg/views/LCG_103cuda/x86_64-centos9-gcc11-opt/setup.sh\nsource myenv/bin/activate\n</code></pre>"},{"location":"software_envs/lcg_environments.html#conda-environments","title":"Conda environments","text":"<p>Using <code>conda</code> package manager: <code>conda</code> pacakge manager is more convenient to install and use. To begin with, obtaining an <code>Anaconda</code> or <code>Miniconda</code> installer for Linux x86_64 platform. Then execute it on Lxplus.</p> <pre><code>1. Please note that if you update your shell configuration (e.g. `.bashrc` file) by `conda init`, you may encounter failure due to inconsistent environment configuration.\n2. Installing packages via `conda` also needs special consideration on selecting proper CUDA version as discussed in `pip` part.\n</code></pre>"},{"location":"training/Decorrelation.html","title":"Decorrelation","text":"<p>When preparing to train a machine learning algorithm, it is important to think about the correlations of the output and their impact on how the trained model is used. Generally, the goal of any training is to maximize correlations with variables of interests. For example, a classifier is trained specifically to be highly correlated with the classification categories.  However, there is often another set of variables that high correlation with the ML algorithm's output is not desirable and could make the ML algorithm useless regardless of its overall performance.</p> <p>There are numerous methods that achieve the goal of minimizing correlations of ML algorithms. Choosing the correct decorrelation method depends on the situation, e.g., which ML algorithm is being used and the type of the undesirable variables.  Below, we detail various methods for common scenarios focusing on BDT (boosted decision tree) and neural network algorithms. </p>"},{"location":"training/Decorrelation.html#impartial-training-data","title":"Impartial Training Data","text":"<p>Generally, the best method for making a neural network's or BDT's output independent of some known variable is to remove any bias in the training dataset, which is commonly done by adding or removing information.</p>"},{"location":"training/Decorrelation.html#adding-information","title":"Adding Information","text":"<ul> <li>Training on a mix of signals with different masses can help prevent the BDT from learning the mass.</li> </ul>"},{"location":"training/Decorrelation.html#removing-information","title":"Removing Information","text":"<ul> <li>If you have any input variables that are highly correlated with the mass, you may want to omit them. There may be a loss of raw discrimination power with this approach, but the underlying interpretation will be more sound.</li> </ul>"},{"location":"training/Decorrelation.html#reweighting","title":"Reweighting","text":"<ul> <li>One method to achieve correlation by weighting data is reweighting the network's input samples to match a reference distribution. Examples input variables include mass, or an input to invariant mass, like the \\(p_T\\). This method is distinct from flattening the data since it is weighted to match a target distribution rather than a flat distribution. Flattening can also require very large weights that could potentially affect training. This is one way to avoid having the network sculpt, or learn, a certain kinematic quantity, like the background mass. An example of this technique is given in EXO-19-020.<ul> <li>This is what is done for the ImageTop tagger and ParticleNet group of taggers.  BDT scores from EXO-10-020 where the jet \\(p_T\\) distribution is reweighted to match a reference distribution for each sample.</li> </ul> </li> </ul>"},{"location":"training/Decorrelation.html#adversarial-approach","title":"Adversarial Approach","text":"<p>Adversarial approaches to decorrelation revolve around including a penalty, or regularization, term in the loss function in training. The loss function can be modified to enforce uniformity in the variable of interest (i.e. mass). Check out these links (1, 2, 3) for some examples of this. One way to technically implement this type of approach is using the \"flatness loss function\" (i.e. BinFlatnessLossFunction in the hep-ml package). This type of decorrelation what is done for the DeepAK8-MD taggers.</p> <p>Another type of regularization one can do to acheive decorrelation is penalizing the loss function on a certain type of correlation, for example distance. In the seminal distance correlation in HEP-ML paper ((DisCo Fever: Robust Networks Through Distance Correlation)), distance is in this case is defined as distance correlation (DisCo), a measure derived from distance covariance, first introduced here. This distance correlation function calculates the non-linear correlation between the NN output and some variables that you care about, e.g. jet mass, that you can force the network to minimize which decorrelates the two variables by including it as a penalty term in the loss function. An extension of this can be found in the Double DisCo method, given below, which highlights the distance correlation term in the loss function at the bottom. The Double DisCo network leverages the ABCD method for background estimation, which is why it requires two separate discriminants. Below is the Double DisCo NN architecture used in MLG-23-003. Notice the two separate discriminant paths consisting of a Dense layer, a Dropout layer, and another Dense layer before outputting a single discriminant per path.</p> <p> Source: CMS AN-22-101 for MLG-23-003.</p> <p>Many thanks to Kevin Pedro for his input on this section and the previous one.</p>"},{"location":"training/Decorrelation.html#parametric-cut","title":"Parametric Cut","text":"<p>When designing jet taggers, variables of interest for discriminators include N-subjettiness derived quantities. Often, these quantities will be correlated with, for example, the \\(p_T\\) of the jet. One example of this type of correlation is called \"mass scuplting\" and happens when the distribution of the discriminating variable in background begins to exhibit a shape similar to that of the signal with successive cuts. This correlation can have confounding effects in the tagger and one way to remove these effects is to parametrically cut on the discriminant. </p> <p>One such prescription to remove these correlations is described here and focuses on removing the \\(p_T\\) dependence in the soft-drop mass variable \\(\\rho\\). The authors note that there is a \\(p_T\\) dependence in the N-subjettiness ratio \\(\\tau_2/\\tau_1\\) as a function of the QCD jet scaling (soft-drop) variable, defined as \\(\\rho = log(m^2)(p_T^2)\\), which leads to mass sculpting. In order to alleviate this issue, the authors introduce a modified version of the soft-drop variable, \\(\\rho' = \\rho + log(p_T/\\mu)\\) where \\(\\mu\\) is chosen to be 1 GeV. It can also be noted that there is a linear depedence between \\(\\tau_2/\\tau_1\\) and \\(\\rho'\\). Here, the authors remedy this by modelling the linear depedence with \\(\\tau_{21}' + \\tau_2/\\tau_1 - M \\times \\rho'\\) where \\(M\\) is fit from the data. Applying both these transformations flattens out the relationship between the ratio and the soft-drop variable and removes the mass sculpting effects. It is imperative that the transformation between variables are smooth, as discontinuous functions may lead to artificial features in the data.</p>"},{"location":"training/Decorrelation.html#methods-for-mass-parameterized-bdts","title":"Methods for mass parameterized BDTs","text":"<p>Finally, when using a BDT that is parameterized by a mass quantity of interest, the output can be decorrelated from that mass by three different methods: randomization, oversampling, and variable profiling. Randomization entails randomly pairing a mass quanitity to a background training event so the BDT does not learn any meaningful associations between the mass and the output. For oversampling, this is a bootstrapping method where every input background event is paired with a potential mass point so the effective statistics for all the mass points are the same. Finally, variable profiling has the user profile each BDT input as a function of the mass quantity of interest. Examples of each of these methods is given below in the context of a di-higgs search.</p> <p>A di-higgs multilepton search (HIG-21-002) made use of a BDT for signal discrimination, parameterized by the di-higgs invariant mass. In order to avoid correlations in the BDT output and invariant mass of the di-higgs system, they looked at decorrelation via randomization, oversampling, and variable profiling. All of the methods utilized a (more or less) 50/50 dataset train/test split where one iteration of the BDT was trained on \"even\" numbered events and the datacards were produced with the \"odd\" numbered events. This procedure was repeated for the opposite configuration. Then, to deteremine if the BDT was correctly interpolating the signal masses, one mass point was omitted from training and the results of this BDT were compared to a BDT trained on only this single, omitted mass point. For each train/test configuration (even/odd or odd/even), the BDT's performance gain, as well as loss, were evaluated with ROC curves with two ommitted mass points (done separately).</p> <p>In the randomization method, a generator-level di-higgs invariant mass was randomly assigned to each background event the BDT was trained on. For the oversampling method, every signal mass point was assigned to a duplicate of each background event. Obviously the oversampling method leads to slower execution but the same effective statistics for all backgrounds and each signal mass. Conversely, the randomization approach is quicker, but leads to reduced effective statistics. Lastly, to improve performance over lower signal masses, each BDT input variable was profiled as a function of \\(m_{HH}\\). This profile was fit with a polynomial function, and then each point in the input distribution is divided by the fit function value. This corrected ratio is used as the new input to the BDT. The authors also found that splitting the BDT training into high and low mass regions helped.</p> <p>In the end, oversampling, especially when combined with input variable corrections, provided a sizable performance gain (5.6%) over the randomization method. This gain is determined from ROC curves made for each training iteration (even/odd or odd/event) and each method. The performance loss is also a 5% improvement over the randomization method. </p> <p>For more information on these methods, see the HIG-21-002. Below are some example BDT output scores for the \\(2\\ell ss\\)  and \\(3 \\ell\\) channels for this analysis.</p> <p> Source: HIG-21-002</p> <p>So far we have seen decorrelation achieved by using inputs that are decorrelated for the classifier and regularizing the output to penalize learning correlations. Another approach can be to learn decorrelation by maximizing performance metrics that more closely align with the sensitivity of the analysis, like in this paper and their corresponding Python-based package, ThickBrick. In this case, the authors study the dependence of the event selection threshold on the signal purity in a given bin of the distribution of an observable. They demonstrate that the threshold increases with signal purity, \"implying that the threshold is stronger in the x-'bins' of higher purity.\" This parametric event selection threshold \"naturally leads to decorrelation of the event selection criteria from the event variable x.\" The failure to incorporate the dependencies on observable distributions is framed as a misalignment between the ML-based selector and the sensitivity of the physics analysis. A demo of their package, ThickBrick, was given at PyHEP2020.</p>"},{"location":"training/MLaaS4HEP.html","title":"MLaaS4HEP","text":""},{"location":"training/MLaaS4HEP.html#machine-learning-as-a-service-for-hep","title":"Machine Learning as a Service for HEP","text":"<p>MLaaS for HEP is a set of Python-based modules to support reading HEP data and stream them to the ML tool of the user's choice. It consists of three independent layers: - Data Streaming layer to handle remote data, see reader.py - Data Training layer to train ML model for given HEP data, see workflow.py - Data Inference layer, see tfaas_client.py</p> <p>The MLaaS4HEP resopitory can be found here.</p> <p>The general architecture of MLaaS4HEP looks like this: </p> <p>Even though this architecture was originally developed for dealing with HEP ROOT files, we extend it to other data formats. As of right now, following data formats are supported: JSON, CSV, Parquet, and ROOT. All of the formats support reading files from the local file system or HDFS, while the ROOT format supports reading files via the XRootD protocol.</p> <p>The pre-trained models can be easily uploaded to TFaaS inference server for serving them to clients. The TFaaS documentation can be found here.</p>"},{"location":"training/MLaaS4HEP.html#dependencies","title":"Dependencies","text":"<p>Here is a list of the dependencies: - pyarrow for reading data from HDFS file system - uproot for reading ROOT files - numpy, pandas for data representation - modin for fast panda support - numba for speeing up individual functions</p>"},{"location":"training/MLaaS4HEP.html#installation","title":"Installation","text":"<p>The easiest way to install and run MLaaS4HEP and TFaaS is to use pre-build docker images <pre><code># run MLaaS4HEP docker container\ndocker run veknet/mlaas4hep\n# run TFaaS docker container\ndocker run veknet/tfaas\n</code></pre></p>"},{"location":"training/MLaaS4HEP.html#reading-root-files","title":"Reading ROOT files","text":"<p>MLaaS4HEP python repository provides the <code>reader.py</code> module that defines a DataReader class able to read either local or remote ROOT files (via xrootd) in chunks. It is based on the uproot framework.</p> <p>Basic usage <pre><code># setup the proper environment, e.g.\n# export PYTHONPATH=/path/src/python # path to MLaaS4HEP python framework\n# export PATH=/path/bin:$PATH # path to MLaaS4HEP binaries\n\n# get help and option description\nreader --help\n\n# here is a concrete example of reading local ROOT file:\nreader --fin=/opt/cms/data/Tau_Run2017F-31Mar2018-v1_NANOAOD.root --info --verbose=1 --nevts=2000\n\n# here is an example of reading remote ROOT file:\nreader --fin=root://cms-xrd-global.cern.ch//store/data/Run2017F/Tau/NANOAOD/31Mar2018-v1/20000/6C6F7EAE-7880-E811-82C1-008CFA165F28.root --verbose=1 --nevts=2000 --info\n\n# both of aforementioned commands produce the following output\nReading root://cms-xrd-global.cern.ch//store/data/Run2017F/Tau/NANOAOD/31Mar2018-v1/20000/6C6F7EAE-7880-E811-82C1-008CFA165F28.root\n# 1000 entries, 883 branches, 4.113945007324219 MB, 0.6002757549285889 sec, 6.853425235896175 MB/sec, 1.6659010326328503 kHz\n# 1000 entries, 883 branches, 4.067909240722656 MB, 1.3497390747070312 sec, 3.0138486148558896 MB/sec, 0.740883937302516 kHz\n###total time elapsed for reading + specs computing: 2.2570559978485107 sec; number of chunks 2\n###total time elapsed for reading: 1.9500117301940918 sec; number of chunks 2\n\n--- first pass: 1131872 events, (648-flat, 232-jagged) branches, 2463 attrs\nVMEM used: 29.896704 (MB) SWAP used: 0.0 (MB)\n&lt;__main__.RootDataReader object at 0x7fb0cdfe4a00&gt; init is complete in 2.265552043914795 sec\nNumber of events  : 1131872\n# flat branches   : 648\nCaloMET_phi values in [-3.140625, 3.13671875] range, dim=N/A\nCaloMET_pt values in [0.783203125, 257.75] range, dim=N/A\nCaloMET_sumEt values in [820.0, 3790.0] range, dim=N/A\n</code></pre></p> <p>More examples about using uproot may be found here and here.</p>"},{"location":"training/MLaaS4HEP.html#how-to-train-ml-models-on-hep-root-data","title":"How to train ML models on HEP ROOT data","text":"<p>The MLaaS4HEP framework allows to train ML models in different ways: - using full dataset (i.e. the entire amount of events stored in input ROOT files) - using chunks, as subsets of a dataset, which dimension can be chosen directly by the user and can vary between 1 and the total number of events - using local or remote ROOT files.</p> <p>The training phase is managed by the <code>workflow.py</code> module which performs the following actions: - read all input ROOT files in chunks to compute a specs file (where the main information about the ROOT files are stored: the dimension of branches, the minimum and the maximum for each branch, and the number of events for each ROOT file) - perform the training cycle (each time using a new chunk of events)   - create a new chunk of events taken proportionally from the input ROOT files     - extract and convert each event in a list of NumPy arrays     - normalize the events     - fix the Jagged Arrays dimension     - create the masking vector   - use the chunk to train the ML model provided by the user</p> <p>A schematic representation of the steps performed in the MLaaS4HEP pipeline, in particular those inside the Data Streaming and Data Training layers, is: </p> <p> If the dataset is large and exceed the amount of RAM on the training node, then the user should consider the chunk approach. This allows to train the ML model each time using a different chunk, until the entire dataset is completely read. In this case the user should pay close attention to the ML model convergence, and validate it after each chunk. For more information look at this, this and this. Using different training approach has pros and cons. For instance, training on entire dataset can guarantee the ML model convergence, but the dataset should fits into RAM of the training node. While chunk approach allows to split the dataset to fit in the hardware resources, but it requires proper model evaluation after each chunk training. In terms of training speed, this choice should be faster than training on the entire dataset, since after having used a chunk for training, that chunk is no longer read and used subsequently (this effect is prominent when remote ROOT files are used). Finally, user should be aware of potential divergence of ML model when training last chunk of the dataset and check for bias towards last chunk. For instance, user may implement a K-fold cross validation approach to train on N-1 chunks (i.e. folds in this case) and use one chunk for validation.</p> <p>A detailed description of how to use the <code>workflow.py</code> module for training a ML model reading ROOT files from the opendata portal, can be found here. Please see how the user has to provide several information when run the <code>workflow.py</code> module, e.g. the definition of the ML model, and then is task of MLaaS4HEP framework to perform all the training procedure using the ML model provided by the user.</p> <p>For a complete description of MLaaS4HEP see this paper.</p>"},{"location":"training/autoencoders.html","title":"Autoencoders","text":""},{"location":"training/autoencoders.html#introduction","title":"Introduction","text":"<p>Autoencoders are a powerful tool that has gained popularity in HEP and beyond recently. These types of algorithms are neural networks that learn to decompress data with minimal reconstruction error (Goodfellow, et. al.).</p> <p>The idea of using neural networks for dimensionality reduction or feature learning dates back to the early 1990s. Autoencoders, or \"autoassociative neural networks,\" were originally proposed as a nonlinear generalization of principle component analysis (PCA) (Kramer). More recently, connections between autoencoders and latent variable models have brought these types of algorithms into the generative modeling space.</p> <p>The two main parts of an autoencoder algorithm are the encoder function \\(f(x)\\) and the decoder function \\(g(x)\\). The learning process of an autoencoder is a minimization of a loss function, \\(L(x,g(f(x)))\\), that compares the original data to the output of the decoder, similar to that of a neural network. As such, these algorithms can be trained using the same techniques, like minibatch gradient descent with backpropagation. Below is a representation of an autoencoder from Mathworks.</p> <p></p>"},{"location":"training/autoencoders.html#constrained-autoencoders-undercomplete-and-regularized","title":"Constrained Autoencoders (Undercomplete and Regularized)","text":"<p>Information in this section can be found in Goodfellow, et. al.</p> <p>An autoencoder that is able to perfectly reconstruct the original data one-to-one, such that \\(g(f(x)) = x\\), is not very useful for extracting salient information from the data. There are several methods imposed on simple autoencoders to encourage them to extract useful aspects of the data.</p> <p>One way of avoiding perfect data reconstruction is by constraining the dimension of the encoding function \\(f(x)\\) to be less than the data \\(x\\). These types of autoencoders are called undercomplete autoencoders, which force the imperfect copying of the data such that the encoding and decoding networks can prioritize the most useful aspects of the data. </p> <p>However, if undercomplete encoders are given too much capacity, they will struggle to learn anything of importance from the data. Similarly, this problem occurs in autoencoders with encoder dimensionality greater than or equal to the data (the overcomplete case). In order to train any architecture of AE successfully, constraints based on the complexity of the target distribution must be imposed, apart from small dimensionality. These regularized autoencoders can have constraints on  sparsity, robustness to noise, and robustness to changes in data (the derivative).</p>"},{"location":"training/autoencoders.html#sparse-autoencoders","title":"Sparse Autoencoders","text":"<p>Sparse autoencoders place a penalty to enforce sparsity in the encoding layer \\(\\mathbf{h} = f(\\mathbf{x})\\) such that \\(L(\\mathbf{x}, g(f(\\mathbf{x}))) + \\Omega(\\mathbf{h})\\). This penalty prevents the autoencoder from learning the identity transformation, extracting useful features of the data to be used in later tasks, such as classification. While the penalty term can be thought of as a regularizing term for a feedforward network, we can expand this view to think of the entire sparse autoencoder framework as approximating the maximum likelihood estimation of a generative model with latent variables \\(h\\). When approximating the maximum likelihood, the joint distribution \\(p_{\\text{model}}(\\mathbf{x}, \\mathbf{h})\\) can be approximated as</p> \\[ \\text{log} [ p_{\\text{model}}(\\mathbf{x})] = \\text{log} [p_{\\text{model}}(\\mathbf{h})] + [\\text{log} p_{\\text{model}}(\\mathbf{x} | \\mathbf{h})] \\] <p>where \\(p_{\\text{model}}(\\mathbf{h})\\) is the prior distribution over the latent variables, instead of the model's parameters. Here, we approximate the sum over all possible prior distribution values to be a point estimate at one highly likely value of \\(\\mathbf{h}\\). This prior term is what introduces the sparsity requirement, for example with the Laplace prior, $$ p_{\\text{model}}(h_i) = \\frac{\\lambda}{2}e^{-\\lambda|h_i|}. $$</p> <p>The log-prior is then</p> <p>$$ \\text{log} [p_{\\text{model}}(\\mathbf{h})] = \\sum_i (\\lambda|h_i| - \\text{log}\\frac{\\lambda}{2}) = \\Omega(\\mathbf{h}) + \\text{const}. $$ This example demonstrates how the model's distribution over latent variables (prior) gives rise to a sparsity penalty.</p>"},{"location":"training/autoencoders.html#penalized-autoencoders","title":"Penalized Autoencoders","text":"<p>Similar to sparse autoencoders, a traditional penalty term can be introduced to the cost function to regularize the autoencoder, such that the function to minimize becomes $$ L(\\mathbf{x},g(f(\\mathbf{x}))) + \\Omega(\\mathbf{h},\\mathbf{x}). $$ where  $$ \\Omega(\\mathbf{h},\\mathbf{x}) = \\lambda\\sum_i ||\\nabla_{\\mathbf{x}}h_i||^2. $$ Because of the dependence on the gradient of the latent variables with respect to the input variables, if \\(\\mathbf{x}\\) changes slightly, the model is penalized for learning those slight variations. This type of regularization leads to a contractive autoencoder (CAE).</p>"},{"location":"training/autoencoders.html#denoising-autoencoders","title":"Denoising Autoencoders","text":"<p>Another way to encourage autoencoders to learn useful features of the data is training the algorithm to minimize a cost function that compares the original data (\\(\\mathbf{x}\\)) to encoded and decoded data that has been injected with noise (\\(f(g(\\mathbf{\\tilde{x}}))\\),  $$ L(\\mathbf{x},g(f(\\mathbf{\\tilde{x}}))) $$ Denoising autoencoders then must learn to undo the effect of the noise in the encoded/decoded data. The autoencoder is able to learn the structure of the probability density function of the data (\\(p_{\\text{data}}\\)) as a function of the input variables (\\(x\\)) through this process (Alain, Bengio, Bengio, et. al.). With this type of cost function, even overcomplete, high-capacity autoencoders can avoid learning the identity transformation.</p>"},{"location":"training/autoencoders.html#variational-autoencoders","title":"Variational Autoencoders","text":"<p>Variational autoencoders (VAEs), introduced by Kigma and Welling, are similar to normal AEs. They are comprised of neural nets, which maps the input to latent space (encoder) and back (decoder), where the latent space is a low-dimensional, variational distribution. VAEs are bidirectional, generating data or estimating distributions, and were initially designed for unsupervised learning but can also be very useful in semi-supervised and fully supervised scenarios (Goodfellow, et. al.).</p> <p>VAEs are trained by maximizing the variational lower bound associated with data point \\(\\mathbf{x}\\), which is a function of the approximate posterior (inference network, or encoder), \\(q(\\mathbf{z})\\). Latent variable \\(\\mathbf{z}\\) is drawn from this encoder distribution, with \\(p_\\text{model}(\\mathbf{x} | \\mathbf{z})\\) viewed as the decoder network. The variational lower bound (also called the evidence lower bound or ELBO) is a trade-off between the join log-likelihood of the visible and latent variables, and the KL divergence between the model prior and the approximate posterior, shown below (Goodfellow, et. al.).</p> <p>$$ \\mathcal{L}(q) = E_{\\mathbf{z} \\sim q(\\mathbf{z} | \\mathbf{x})} \\text{log}p_\\text{model}(\\mathbf{x} | \\mathbf{z}) - D_\\text{KL}(q || p) $$.</p> <p>Methods for optimizing the VAE by learning the variational lower bound include EM meta-algorithms like probabilistic PCA (Goodfellow, et. al.).</p>"},{"location":"training/autoencoders.html#applications-in-hep","title":"Applications in HEP","text":"<p>One of the more popular applications of AEs in HEP include anomaly detection. Because autoencoders are trained to learn latent features of a dataset, any new data that does not match those features could be classified as an anomaly and picked out by the AE. Examples of AEs for anomaly detection in HEP are listed below:</p> <ul> <li>Anomaly detection in high-energy physics using a quantum autoencoder</li> <li>Particle Graph Autoencoders and Differentiable, Learned Energy Mover's Distance </li> <li>Bump Hunting in Latent Space</li> </ul> <p>Another application of (V)AEs in HEP is data generation, as once the likelihood of the latent variables is approximated it can be used to generate new data. Examples of this application in HEP for simulation of various physics processes are listed below:</p> <ul> <li>Deep generative models for fast shower simulation in ATLAS</li> <li>Sparse Data Generation for Particle-Based Simulation of Hadronic Jets in the LHC </li> <li>Variational Autoencoders for Jet Simulation </li> <li>Anomaly detection using Deep Autoencoders for the assessment of the quality of the data acquired by the CMS experiment</li> <li>Autoencoders on FPGAs for real-time, unsupervised new physics detection at 40 MHz at the Large Hadron Collider</li> </ul> <p>Finally, the latent space learned by (V)AEs give a parsimonious and information-rich phase space from which one can make inferences. Examples of using (V)AEs to learn approximate and/or compressed representations of data are given below:</p> <ul> <li>An Exploration of Learnt Representations of W Jets</li> <li>Machine-Learning Compression for Particle Physics Discoveries</li> <li>Decoding Photons: Physics in the Latent Space of a BIB-AE Generative Network</li> </ul> <p>More examples of (V)AEs in HEP can be found at the HEP ML Living Review.</p>"},{"location":"training/autoencoders.html#references","title":"References","text":"<ul> <li>Goodfellow, et. al., 2016, Deep Learning</li> <li>Alain, Bengio, 2013, \"What Regularized Auto-Encoders Learn from the Data Generating Distribution\"</li> <li>Bengio, et. al., 2013, \"Generalized Denoising Auto-Encoders as Generative Models\"</li> <li>Kramer, 1991, \"Nonlinear principle component analysis using autoassociative neural networks\"</li> <li>Kingma, Welling, 2013, \"Auto-Encoding Variational Bayes\"</li> </ul>"}]}